# План миграции с Shift на Control+N

## 📊 Текущая архитектура обработки клавиш

### Схема текущей логики работы с Shift

```
┌─────────────────────────────────────────────────────────────────┐
│                    unified_config.yaml                          │
│  key_to_monitor: "left_shift"                                   │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│           UnifiedConfigLoader.get_keyboard_config()             │
│  Создает KeyboardConfig с key_to_monitor="left_shift"            │
└────────────────────────┬────────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────────┐
│         InputProcessingIntegration._initialize_keyboard()       │
│  Выбирает backend: QuartzKeyboardMonitor (macOS) или           │
│                     KeyboardMonitor (fallback/pynput)           │
└────────────┬───────────────────────────┬────────────────────────┘
             │                           │
             ▼                           ▼
┌──────────────────────────┐  ┌──────────────────────────┐
│  QuartzKeyboardMonitor  │  │   KeyboardMonitor        │
│  (macOS нативный)        │  │   (pynput fallback)      │
└────────────┬─────────────┘  └──────────┬───────────────┘
             │                           │
             │                           │
             ▼                           ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Обработка событий клавиатуры                   │
│                                                                   │
│  KEYCODES = {"left_shift": 56}                                   │
│                                                                   │
│  События Quartz:                                                 │
│  - kCGEventFlagsChanged (для модификаторов)                      │
│  - kCGEventKeyDown / kCGEventKeyUp                               │
│                                                                   │
│  Логика:                                                         │
│  1. Отслеживание keycode=56 (left_shift)                         │
│  2. Определение состояния: pressed/released                      │
│  3. Генерация событий: PRESS, SHORT_PRESS, LONG_PRESS, RELEASE   │
└────────────┬─────────────────────────────────────────────────────┘
             │
             ▼
┌─────────────────────────────────────────────────────────────────┐
│          InputProcessingIntegration обработчики                 │
│                                                                   │
│  _handle_press()      → PRESS (подготовка сессии)               │
│  _handle_short_press() → SHORT_PRESS (отмена/прерывание)         │
│  _handle_long_press()  → LONG_PRESS (начало записи)             │
│  _handle_key_release() → RELEASE (остановка записи)              │
└─────────────────────────────────────────────────────────────────┘
```

### Детальная схема обработки событий

```
Пользователь нажимает Shift
         │
         ▼
┌─────────────────────────────────────┐
│  Quartz Event Tap Callback         │
│  - Определяет keycode=56             │
│  - Проверяет flagsChanged/keyDown   │
└────────────┬────────────────────────┘
             │
             ▼
┌─────────────────────────────────────┐
│  PRESS Event                       │
│  - pending_session_id = timestamp    │
│  - Публикует keyboard.press         │
└────────────┬────────────────────────┘
             │
             ├──────────────────────────┐
             │                          │
             ▼                          ▼
    ┌─────────────────┐      ┌──────────────────────┐
    │ Держим < 0.6s   │      │ Держим >= 0.6s       │
    │ (short_press)   │      │ (long_press)         │
    └────────┬────────┘      └──────────┬───────────┘
             │                          │
             ▼                          ▼
    ┌─────────────────┐      ┌──────────────────────┐
    │ SHORT_PRESS     │      │ LONG_PRESS           │
    │ - Отмена        │      │ - voice.recording_   │
    │ - Прерывание    │      │   start              │
    │ - SLEEPING      │      │ - LISTENING mode     │
    └────────┬────────┘      └──────────┬───────────┘
             │                          │
             └──────────┬───────────────┘
                        │
                        ▼
              ┌─────────────────┐
              │ RELEASE Event   │
              │ - voice.recording_│
              │   stop          │
              │ - PROCESSING    │
              └─────────────────┘
```

## 🎯 План замены на Control+N

### Проблемы и вызовы

1. **Одновременное удержание**: Комбинация активна только если Control и N зажаты одновременно; одиночные нажатия игнорируются
2. **Разные keycodes и источники событий**: Control (flagsChanged с keycodes 59/62) и N (keyDown/keyUp c keycode 45)
3. **Два пути отпускания**: Комбо завершается при отпускании ЛЮБОЙ клавиши (Ctrl или N)
4. **Логика удержания**: LONG_PRESS считается только пока combo_active=true; при отпускании любой клавиши combo завершается
5. **Разные backend’ы**: Quartz и pynput обрабатывают модификаторы по‑разному

### Варианты решения

#### Вариант 1: Отслеживание комбинации Control+N (Рекомендуемый)
**Сложность**: Средняя  
**Время**: 4-6 часов  
**Описание**: Модифицировать QuartzKeyboardMonitor и fallback для отслеживания комбинации Control+N с точной стейт-машиной и подавлением событий

**Преимущества**:
- Сохраняет текущую логику событий (PRESS, SHORT_PRESS, LONG_PRESS, RELEASE)
- Минимальные изменения в InputProcessingIntegration
- Поддерживает удержание Control+N (как удержание Shift)

**Недостатки**:
- Требует изменения логики определения комбинации
- Нужно отслеживать состояние Control и N одновременно

**Изменения**:
1. Расширить KEYCODES для Control и N
2. Модифицировать callback для отслеживания комбинации
3. Обновить конфигурацию: `key_to_monitor: "ctrl_n"`

#### Вариант 2: Отслеживание только N с проверкой Control
**Сложность**: Простая  
**Время**: 2-3 часа  
**Описание**: Отслеживать только N, но проверять, что Control нажат

**Преимущества**:
- Проще реализовать
- Меньше изменений в коде

**Недостатки**:
- Может срабатывать на случайные нажатия N при удержании Control
- Сложнее обрабатывать удержание комбинации

#### Вариант 3: Глобальный hotkey через Carbon/Cocoa
**Сложность**: Сложная  
**Время**: 8-12 часов  
**Описание**: Использовать системные API для регистрации глобального hotkey

**Преимущества**:
- Нативная поддержка macOS
- Меньше конфликтов с другими приложениями

**Недостатки**:
- Требует значительных изменений архитектуры
- Может конфликтовать с системными hotkeys
- Сложнее обрабатывать удержание

### Рекомендуемое решение: Вариант 1

## 📝 Детальный план реализации

### Шаг 1: Обновление конфигурации и валидации

**Файл**: `config/unified_config.yaml`
```yaml
keyboard:
  key_to_monitor: ctrl_n  # Было: left_shift
```

**Файл**: `config/unified_config_loader.py`
- Добавить whitelist поддерживаемых клавиш (`left_shift`, `ctrl_n`), логировать предупреждение для неподдерживаемых.

### Шаг 2: Стейт-машина и ключевые правила
- Состояния: `control_down`, `n_down`, `combo_active`, `combo_start_time`, `_long_sent`.
- Активируем combo (и генерируем PRESS) только при переходе `combo_active` из False в True, когда одновременно зажаты Control и N (порядок нажатий не важен).
- LONG_PRESS генерируется из hold_monitor пока `combo_active` и `duration >= long_press_threshold`.
- Любое отпускание Control или N завершает combo: если LONG_PRESS уже был — отправляем RELEASE; иначе SHORT_PRESS, затем RELEASE. Одиночные нажатия Ctrl или N без второй клавиши не генерируют событий.
- Автоповтор N: если `n_down` уже True, повторные `keyDown` N игнорируются (не трогаем combo/last_event_time); работаем только с первым `keyDown` и финальным `keyUp`.
- Тайминг: берем длительность combo от `combo_start_time` (момент, когда обе клавиши зажаты); используем те же `long_press_threshold/short_press_threshold`.
- Event suppression: при активной комбо подавляем прохождение `keyDown` для N в другие приложения (Quartz: возвращаем None/CGEventTapCallBack = NULL для N, если зажат Ctrl). Control не подавляем, чтобы не ломать другие хоткеи.

### Шаг 3: QuartzKeyboardMonitor (macOS)

**Файл**: `modules/input_processing/keyboard/mac/quartz_monitor.py`
- Убрать «combo» из KEYCODES; добавить числовые keycodes: `CONTROL_KEYCODES={59,62}` (если нужен только левый Control — оставить `{59}`), `N_KEYCODE=45`; таргет — строка `ctrl_n`.
- Добавить флаги `control_pressed`, `n_pressed`, `combo_active`, `combo_start_time`.
- `kCGEventFlagsChanged`: отслеживать Control (59/62) через `kCGEventFlagMaskControl`, обновлять `control_pressed`.
- `kCGEventKeyDown/KeyUp`: отслеживать N (45), обновлять `n_pressed`.
- После каждого изменения состояния пересчитывать combo: при активации генерировать PRESS и запускать hold_monitor; при деактивации — вычислять duration (от `combo_start_time`) и слать SHORT_PRESS/RELEASE или только RELEASE (если LONG уже отправлен).
- Адаптировать антидвоинную защиту (`_event_processed`, `_last_event_timestamp`) для двух источников отпускания (Ctrl и N), чтобы RELEASE/SHORT_PRESS отправлялись один раз.
- cooldown применять только к повторным keyDown для N; flagsChanged для Control не должны ломать combo.
- Раскладки: keycode 45 соответствует US/EN. Либо задокументировать ограничение (рекомендуется), либо сделать настраиваемым `n_keycode` в конфиге. Проверять раскладку и логировать предупреждение при не-US (опционально).
- Secure Input: логировать, если события перестают приходить (tap отключён), чтобы показать подсказку пользователю.

### Шаг 4: KeyboardMonitor (fallback, pynput)

**Файл**: `modules/input_processing/keyboard/keyboard_monitor.py`
- Не использовать приватные `_modifiers`; вести собственные `control_down` (Key.ctrl / Key.ctrl_l / Key.ctrl_r) и `n_down` (KeyCode.from_char('n') / name 'n').
- Реализовать ту же стейт-машину combo: PRESS при первом combo_active, LONG_PRESS из hold_monitor, SHORT/RELEASE при отпускании любой клавиши.
- Игнорировать одиночные нажатия; не генерировать события при авто-повторе N (key repeat).
- Если нужен только левый Control — учитывать только Key.ctrl/Key.ctrl_l.
- Раскладки: pynput по символу 'n' зависит от раскладки; использовать vk_code/scan code если доступен, или задокументировать поддержку US/EN и дать настраиваемый KeyCode. Кириллицу не поддерживаем.
- Подавление событий: pynput чаще всего пассивен (не блокирует keyDown). Для macOS это ограничение — предупреждать пользователя/логировать, что в fallback могут проходить события в активное окно.

### Шаг 8: Дополнительные проверки/UX
- False positives: прогнать сценарии быстрой печати и быстрых хоткеев (Ctrl+C/V), чтобы убедиться, что случайное касание N не даёт ложных PRESS (при необходимости добавить минимальный debounce на активацию combo).
- Выбор Control: по умолчанию левый Ctrl, но документировать, что Command (⌘) не используется; избежать случайного листенинга Cmd+N.

### Шаг 5: Интеграция и логи

**Файл**: `integration/integrations/input_processing_integration.py`
- Убрать хардкод `left_shift` в логах/сообщениях; использовать `event.key` или `self.config.keyboard.key_to_monitor`.
- Проверить, что логика не зависит от имени клавиши (только на события PRESS/SHORT/LONG/RELEASE).

### Шаг 6: Типы (опционально)

**Файл**: `modules/input_processing/keyboard/types.py`
- Можно добавить `CTRL_N` в KeyType для явной явной поддержки, но не обязательно для работы.

### Шаг 7: Тестирование

Покрыть сценарии:
1. Быстрый одновременный tap Ctrl+N → SHORT_PRESS, затем RELEASE.
2. Удержание Ctrl→N (или N→Ctrl) ≥ long_press_threshold → PRESS, LONG_PRESS, RELEASE.
3. Отпускание Control раньше N (и наоборот) после активации → SHORT_PRESS/RELEASE (если LONG не был) или только RELEASE (если LONG был).
4. Одиночные нажатия Ctrl или N без второй клавиши → никаких событий.
5. Повторные нажатия в cooldown не должны задваивать PRESS.
Обновить существующие интеграционные тесты (`tests/test_microphone_activation.py`, `tests/test_interrupt_playback.py`) под `ctrl_n`.

### Дополнительные нюансы реализации
- Quartz: разводим обработку отпусканий через flagsChanged (Ctrl) и keyUp (N) — используем раздельные timestamps/флаги, чтобы не слать RELEASE/SHORT дважды.
- Pynput: не трогаем приватные `_modifiers`, отслеживаем ctrl_l/ctrl_r и N своими флагами; игнорируем key repeat для N.
- Раскладка: по умолчанию US keycode 45; опционально `n_keycode` в конфиге и/или предупреждение, если раскладка не US.
- Если нужен только левый Ctrl — ограничиваемся keycode 59 (Quartz) и Key.ctrl/Key.ctrl_l (pynput).
- Тесты: обязательно проверяем оба порядка нажатия/отпускания, одиночные нажатия, короткий tap и удержание.

## 🧪 Пошаговый план реализации и проверки
- Шаг 1: Конфиг и валидация — обновить `config/unified_config.yaml` на `ctrl_n`, whitelist в `config/unified_config_loader.py`. Проверка: вызвать `get_keyboard_config` (юнит/диагностика) и убедиться, что возвращает `ctrl_n` без ошибок.
- Шаг 2: Quartz монитор — внедрить стейт-машину ctrl/n/combo, suppression keyDown N при зажатом Ctrl, антидвоение отпусканий, игнор repeat N, выбор левого Ctrl (или обоих). Проверка: мок/юнит с последовательностями events (flagsChanged ctrl_down/up, keyDown/up N) для tap, hold, отпускания любой; убедиться, что в активной комбо callback возвращает None на N keyDown.
- Шаг 3: pynput fallback — собственные флаги ctrl/n, та же стейт-машина, игнор repeat, левый Ctrl по умолчанию, без suppression (задокументировать). Проверка: юнит через вызов on_press/on_release (Key.ctrl_l/KeyCode('n')); события только для комбо, одиночные клавиши игнорируются.
- Шаг 4: Интеграция и логи — убрать хардкод `left_shift` в `integration/integrations/input_processing_integration.py`, использовать `event.key`/config. Проверка: существующие интеграционные тесты (микрофон/interrupt), логи без “left_shift”.
- Шаг 5 (опц.): Типы — при необходимости добавить `CTRL_N` в `modules/input_processing/keyboard/types.py`. Проверка: статический импорт/линтер.
- Шаг 6: Тесты — обновить `tests/test_microphone_activation.py`, `tests/test_interrupt_playback.py` на `ctrl_n`; добавить сценарии: быстрый tap, удержание >= threshold, отпускание Ctrl раньше N и наоборот, одиночные нажатия, suppression в Quartz. Проверка: прогон тестового набора.
- Шаг 7: Документация — проверить/обновить упоминания Shift в гидах. Проверка: визуальный просмотр Docs.

## 🔍 Keycodes для macOS (US layout)

```
Control (Left):  59
Control (Right): 62
N:               45
Shift (Left):    56
Shift (Right):   60
```

## ⚠️ Риски и предупреждения

### Критические риски
1. **Конфликт с системными hotkeys**: Control+N может использоваться другими приложениями
   - **Решение**: Проверить конфликты, возможно использовать Control+Option+N
   
2. **Потеря событий**: При быстром нажатии/отпускании могут теряться события
   - **Решение**: Добавить debounce и проверку состояния

3. **Разные раскладки клавиатуры**: Keycode N может отличаться
   - **Решение**: Использовать символ 'n' вместо keycode, где возможно

### Средние риски
1. **Производительность**: Отслеживание двух клавиш может быть медленнее
   - **Решение**: Оптимизировать проверки в callback

2. **Совместимость с fallback**: pynput может по-другому обрабатывать комбинации
   - **Решение**: Тщательное тестирование обоих backends

## 📋 Чеклист реализации

- [ ] Обновить unified_config.yaml
- [ ] Расширить KEYCODES в QuartzKeyboardMonitor
- [ ] Добавить отслеживание состояния Control и N
- [ ] Модифицировать callback для обработки комбинации
- [ ] Обновить KeyboardMonitor (fallback)
- [ ] Обновить типы (опционально)
- [ ] Добавить логирование для отладки
- [ ] Протестировать все сценарии
- [ ] Обновить документацию

## 🔄 Обратная совместимость

Для поддержки старой конфигурации:
- Оставить поддержку `left_shift` в KEYCODES
- Добавить валидацию в `__init__` для проверки поддерживаемых значений
- Выдать предупреждение при использовании устаревших значений
