# Nexy Client Development Rules

## 1. Документы перед началом

### 1.0 Flags Discovery (ОБЯЗАТЕЛЬНО перед изменениями)

**ОБЯЗАТЕЛЬНО**: Перед любыми правками логики запустить discovery режим для модуля/интеграции:

```bash
# Для клиента
python scripts/verify_feature_flags.py --module <path>

# Для сервера
python scripts/verify_feature_flags.py --module <path>
```

**Результаты discovery**:
- Все найденные флаги (env и config) с метаданными из реестра
- Контекст использования (файл, строка, функция/класс, код)
- YAML пути для config-флагов
- Незарегистрированные флаги помечены как `[UNREGISTERED]`

**Включение в план**: Результаты discovery должны быть включены в план изменений в раздел "Flags Discovery" для предотвращения дублирования и конфликтов.

Перед изменениями обнови контекст по ключевым файлам:
- `Docs/PROJECT_REQUIREMENTS.md` — единый snapshot требований (обязательно при изменении логики, см. раздел 11.3)
- `Docs/REQUIREMENTS_SOURCE_MAP.md` — карта всех документов требований с их статусом
- `Docs/PRODUCT_CONCEPT.md` — пользовательские сценарии и режимы
- `Docs/ARCHITECTURE_OVERVIEW.md` — связь модулей и интеграций
- `Docs/CURRENT_STATUS_REPORT.md` — актуальные истории, риски и тесты
- `Docs/GLOBAL_DELIVERY_PLAN.md` — фазы поставки, Azure/AppCast (обновлён с ссылками на новый процесс)
- `Docs/PACKAGING_FINAL_GUIDE.md` и `client/modules/*/MACOS_PACKAGING_GUIDE.md` — пайплайн сборки и подписи (обновлён с ссылками на новый процесс)
- `Docs/PRE_PACKAGING_VERIFICATION.md` + `Docs/PACKAGING_READINESS_CHECKLIST.md` — фактические результаты чек-листов упаковки
- `PERMISSIONS_REPORT.md` + `Docs/first_run_flow_spec.md` — статусы разрешений/TCC и логика first-run

**ВАЖНО:** Любое изменение логики начинается с обновления `Docs/PROJECT_REQUIREMENTS.md` (см. раздел 11.3). Это обязательный процесс регулярного аудита требований.

### 1.3 Механизм обмена документами между ассистентами

Если работа требует взаимодействия нескольких ассистентов (Codex, Cursor, Antigravity), используем единый протокол:
- Документируем задачи/анализ/ревью в `Docs/assistant_exchange/` по правилам `Docs/ASSISTANT_COORDINATION_PROTOCOL.md`.
- Каждый ассистент пишет в свой подкаталог, имена фиксированы: `codex`, `cursor`, `antigravity`.
- Для перекрестной проверки создается документ типа `review` с ссылкой на проверяемый файл.
- После каждого выполненного задания создается отчетный документ (новый файл, без перезаписи) по шаблону `Docs/assistant_exchange/TEMPLATE.md`.
- Индивидуальные prompt-файлы ассистентов: `Docs/ANTIGRAVITY_PROMPT.md`, `Docs/CODEX_PROMPT.md`.

### 1.1 Принципы устранения конфликтов и дубликатов

**ОБЯЗАТЕЛЬНО**: Следующие принципы применяются для предотвращения конфликтов состояния, дублирования запросов и обеспечения единого источника истины:

- **Request-scoped state**: состояние обработки запроса не хранится на уровне экземпляра интеграции, только внутри контекста запроса (session_id).
- **Single-flight по session_id**: один активный запрос на `session_id`, повторные отклоняются без очереди ожидания.
- **Source of Truth**: `session_id` генерируется в ApplicationStateManager и передается дальше без переопределений. Все интеграции используют `state_manager.get_current_session_id()` и `state_manager.update_session_id()`.
- **Централизация guard-логики**: ограничения (backpressure/rate limit) и проверки состояния живут в одном слое (gateways/selectors), без дублирования.
- **Политика ошибок стрима**: ошибка до начала стрима = gRPC статус + error_message, после частичных данных = тихое завершение без смешивания данных и ошибок.

### 1.2 Источник истины для TCC/First-Run/Restart

**ВАЖНО**: Единый источник истины для осей состояния и правил взаимодействия:

**Что делаем** (поведение и правила):
- `Docs/STATE_CATALOG.md` — единый источник истины для всех осей состояния (permissions.mic, device.input, network, firstRun, appMode)
  - **Таблица ownership**: см. раздел "Таблица ownership" в STATE_CATALOG.md (владельцы осей и артефактов)
- `config/interaction_matrix.yaml` — правила взаимодействия осей и приоритеты решений (hard_stop, graceful, preference)

**Как делаем** (реализация):
- `Docs/first_run_flow_spec.md` — детальная логика запроса разрешений и перезапуска
- `PERMISSIONS_REPORT.md` — актуальные статусы TCC, открытые задачи
- `Docs/TAL_TESTING_CHECKLIST.md` — чек-лист TAL/permission restart с логами и тестами
- `integration/core/gateways.py` — логика принятия решений на основе осей состояния

**Machine-enforced правила**:
- Запрет прямого доступа к состоянию: `pyproject.toml` настроен на проверку паттернов (см. раздел 21.3)
- Валидация схем: `client/config/schemas/` + `tests/test_schemas.py` (см. раздел 9.1)

**Синхронизация**: Любое изменение оси или правила → обновить STATE_CATALOG.md → interaction_matrix.yaml → gateways.py → тесты (см. раздел 11 "Чеклист изменений").

### 1.1.1 Процедура синхронизации осей (явное правило)

**ОБЯЗАТЕЛЬНАЯ ПРОЦЕДУРА**: Любые правки осей → сначала правим STATE_CATALOG.md, затем interaction_matrix.yaml, затем gateways.py + тесты.

**Порядок действий:**
1. **STATE_CATALOG.md** — добавить/изменить ось, обновить владельцев/читателей, источник истины, метрики
2. **interaction_matrix.yaml** — добавить/изменить правило взаимодействия с приоритетами (hard_stop/graceful/preference)
3. **gateways.py** — реализовать логику в соответствующем gateway (decide_* функции)
4. **Тесты gateways** — добавить/обновить тесты (≥8–14 pairwise + 2 негативных) с проверкой decision-логов

**Owner оси разрешает споры**: При любом разногласии по оси/артефакту — окончательное решение принимает Owner из таблицы ownership в STATE_CATALOG.md (см. раздел "Таблица ownership").

## 2. Среда и запуск
- macOS 13+, Python 3.11, работа ведётся из `client/`.
- Точка входа: `python client/main.py` (создаёт EventBus и запускает `SimpleModuleCoordinator`).
- ffmpeg для pydub должен лежать в `client/resources/ffmpeg/ffmpeg` или паковаться внутрь `.app`.
- При разработке держи `PYTHONPATH` чистым: `client/main.py` сам добавляет нужные пути.
- **Сборка `.app`/PKG**: единственная инструкция по упаковке — `Docs/PACKAGING_FINAL_GUIDE.md` (PyInstaller + pkgbuild/productbuild + нотарификация). **Не используй другие источники** — это исключает дубли и рассинхронизацию.

## 3. Архитектурное устройство
- **Core** (`client/integration/core/`): `EventBus`, `SimpleModuleCoordinator`, `ApplicationStateManager`, `ErrorHandler`.
- **Модули** (`client/modules/`): ответственны за низкоуровневую логику.
  - См. полный список: `client/modules/`
- **Интеграции** (`client/integration/integrations/`): тонкие обёртки над модулями.
  - См. полный список: `client/integration/integrations/`
  - **ОБНОВЛЕНО:** Модуль `permissions` теперь имеет `first_run_permissions_integration.py` для системы первого запуска.
  - **ОБНОВЛЕНО:** Добавлены MCP-модули (`action_errors`, `mcp_action`) и интеграции (`action_execution_integration.py`, `tts_integration.py`) для выполнения команд от ассистента.
- **Workflows** (`client/integration/workflows/`): `ListeningWorkflow`, `ProcessingWorkflow` управляют переходами между режимами.
- **Режимы** (`AppMode`): SLEEPING → LISTENING → PROCESSING, переходы только через события `mode.request`.
- **EventBus**: все коммуникации — события, приоритеты задаются через `EventPriority`.

## 4. Порядок модулей и инициализации
`SimpleModuleCoordinator` создаёт интеграции в `_create_integrations()` и запускает их в `startup_order`. Порядок создания и запуска различается для оптимизации зависимостей.

**Порядок создания интеграций** (`_create_integrations()`):
InstanceManager → HardwareId → Tray → Input → Updater → PermissionRestart → UpdateNotification → Network → Interrupt → ScreenshotCapture → VoiceRecognition → ModeManagement → GrpcClient → ActionExecution (если enabled) → SpeechPlayback → Signals → AutostartManager → WelcomeMessage → VoiceOverDucking → **FirstRunPermissions (ПОСЛЕДНЯЯ в создании)**.

**Порядок запуска интеграций** (`startup_order`):
InstanceManager (1-й, блокирующий) → Tray (2-й, неблокирующий) → HardwareId (3-й) → **FirstRunPermissions (4-я в запуске, блокирующая - ПОСЛЕ tray!)** → PermissionRestart (5-я) → ModeManagement → InputProcessing → VoiceRecognition → Network → Interrupt → ScreenshotCapture → GrpcClient → ActionExecution → SpeechPlayback → Signals → UpdateNotification → Updater → WelcomeMessage → VoiceOverDucking → AutostartManager (ПОСЛЕДНИЙ, неблокирующий).

**ВАЖНО:** FirstRunPermissionsIntegration создаётся ПОСЛЕДНЕЙ в `_create_integrations()`, но запускается 4-й в `startup_order` (после tray). Это обеспечивает правильную последовательность: tray готов → first_run_permissions → permission_restart.

**АКТУАЛЬНЫЕ СПИСКИ:**
- Модули: см. `client/modules/` (21 модуль, включая action_errors, mcp_action)
- Интеграции: см. `client/integration/integrations/` (22 интеграции, включая action_execution_integration, tts_integration)
- Порядок создания: см. `SimpleModuleCoordinator._create_integrations()`
- Порядок запуска: см. `SimpleModuleCoordinator.start()` → `startup_order`

**Политика расширения:** прежде чем изменять структуру или добавлять новую интеграцию, проверь существующие модули и workflows; их допускается расширять конфигом или событиями. Новый модуль/интеграция создаём только если требуемого поведения нет и его нельзя разумно добавить через текущие компоненты. В этом случае документируй причину и зависимостей в `../Docs/CURRENT_STATUS_REPORT.md` и обнови `unified_config.yaml`.

**ЗАЩИТА МОДУЛЕЙ ОТ ИЗМЕНЕНИЙ:**
- **Каждый модуль должен быть изолированным** и иметь четко определенные границы
- **Изменения в модули возможны только в случае критической необходимости** и только через ADR (Architecture Decision Record)
- **Интеграция с модулями ТОЛЬКО через отдельные интеграции** в `client/integration/integrations/`
- **Прямые изменения в модули запрещены** без обоснования в ADR и согласования с владельцем модуля
- **Новая функциональность добавляется через расширение интеграций** или создание новых интеграций
- **Модули должны иметь стабильные интерфейсы** - breaking changes требуют создания новой версии модуля

## 5. Паттерн интеграции
- Наследуй `BaseIntegration` и подключай существующий модуль.
- **ОБЯЗАТЕЛЬНО создай контракт EventBus** (см. раздел 16) перед началом разработки.
- Подписки и публикации только через `event_bus`.
- Обработка ошибок — через `error_handler.handle_error` с указанием контекста.
- Все инициирующие события включают `session_id` (строка uuid4).
- Возвращаемые события именуй `<feature>.<action>` согласно контракту.

## 6. Конфигурация
- Единственный источник правды: `config/unified_config.yaml` (загрузка через `UnifiedConfigLoader`).
- Раздел `integrations` управляет включением и приоритетами обёрток; не дублируй настройки в коде.
- Новые параметры добавляй в `unified_config.yaml`, обновляя документацию и пример (если нужен).
- Секреты не коммить: используем Keychain/окружение.

### 6.1 Feature Flags и Kill-Switches (обязательный слой управления)

**ОБЯЗАТЕЛЬНО**: Любое поведение, затрагивающее >2 оси состояния, **ОБЯЗАНО** раскатываться через feature flag и иметь мгновенный откат (kill-switch).

**Реестр флагов**: См. `Docs/FEATURE_FLAGS.md` — единый источник истины для всех feature flags/kill-switches.

**Правило регистрации флагов (ОБЯЗАТЕЛЬНО)**:
- **Новый флаг запрещён без добавления в `Docs/FEATURE_FLAGS.md`** и прохождения `scripts/verify_feature_flags.py`
- Перед использованием любого флага в коде он **ОБЯЗАН** быть зарегистрирован в реестре:
  - **env-флаги**: `NEXY_FEATURE_*`, `NEXY_KS_*`, `NEXY_DISABLE_*` (переменные окружения)
  - **config-флаги**: `features.*` в `unified_config.yaml` (например: `use_events_for_update_status`, `serial_tcc_prompts`)
- Формат регистрации: `| name | type | owner | default | scope | kill_switch | description |`
- Скрипт `scripts/verify_feature_flags.py` автоматически проверяет:
  - Все env-флаги в коде (regex поиск `NEXY_*`)
  - Все config-флаги из `unified_config.yaml` секции `features.*`
- Проверка интегрирована в `scripts/verify_architecture.py` и выполняется перед мерджем

**Конкретные флаги для first-run/permission-restart:**
- `NEXY_FEATURE_FIRST_RUN_V2` — включить систему первого запуска (v2)
- `NEXY_FEATURE_PERMISSION_RESTART_V2` — включить автоматический перезапуск после разрешений (v2)
- `NEXY_KS_PERMISSION_RESTART_V2` — kill-switch для мгновенного отключения перезапуска (env переменная или unified_config)
- `NEXY_DISABLE_AUTO_RESTART` — env-переключатель для dry-run режима (перезапуск не выполняется)

**Правила использования:**
- Feature flags: постепенный роллаут (1% → 25% → 100%) через `unified_config.yaml` или env переменные
- Kill-switches: мгновенный откат без релиза (env переменная или `unified_config.yaml`)
- Все флаги должны быть зарегистрированы в `Docs/FEATURE_FLAGS.md` перед мерджем (см. раздел 19 «Роллаут»)

## 7. Взаимодействие с сервером
- gRPC настройки (`grpc.server_host`, `grpc.server_port`, TLS) берутся из unified_config.
- Сообщения/стриминг определены `../server/modules/grpc_service/streaming.proto`; при изменениях сервера обновляй клиентские stubs и проводи совместное тестирование.
- Сетевые ошибки должны транслироваться через события ошибок и обрабатываться дружелюбно (без падения режима).

## 8. Логирование и телеметрия
- **Формат**: `YYYY-MM-DD HH:MM:SS - Nexy - LEVEL - [session_id] - Message` (см. `client/main.py`).
- **Структурированные события**: `module.start|ok|fail` с session_id, duration_ms, контекстом.
- **Ошибки**: через ErrorHandler с кодами (E_INPUT_INVALID, E_STATE_INVAR, E_DEP_TIMEOUT, E_DEP_UNAVAILABLE, E_RATE_LIMITED, E_UNKNOWN).
- **Логируй**: переходы режимов, сетевые события, ошибки устройств, автообновления.
- **Избегай**: PII/секретов (микрофонные данные, токены, URL).
- **Для DIAG**: добавлять config_hash, build_id, git_sha в контекст.

### 8.1 Shadow-mode и Expected Logs (Definition of Done)

**ОБЯЗАТЕЛЬНО**: Перед мерджем изменений, затрагивающих first-run/permission-restart, **ОБЯЗАНА** быть сверка со «спецификацией логов первого запуска».

**Спецификация логов**: Логи первого запуска проверяются через `tests/test_golden_first_run_logs.py` и соответствуют спецификации в `Docs/first_run_flow_spec.md`.

**Проверочный чек-лист** (перед мерджем):
- [ ] Логи сверены со спецификацией через `tests/test_golden_first_run_logs.py`
- [ ] Нет «проигрывания приветствия до рестарта» в старом процессе
- [ ] Нет публикации `permissions.first_run_completed` в старом процессе (только `restart_pending`)
- [ ] Нет логов CoreAudio о записи микрофона до перезапуска
- [ ] В новом процессе есть `Перезапуск после first_run завершён успешно`
- [ ] Приветствие играет **ТОЛЬКО** после перезапуска (в новом процессе)

**Shadow-mode**: Для постепенного роллаута изменений используй shadow-mode (параллельная публикация событий/состояний для наблюдения без применения изменений).

**Decision-лог (канонический формат, обязателен для всех gateways):**
`decision=<start|abort|retry|degrade> ctx={mic=...,screen=...,device=...,network=...,firstRun=...,appMode=...} source=<domain> duration_ms=<int>`

**ОБЯЗАТЕЛЬНОСТЬ**: Этот формат **ОБЯЗАТЕЛЕН** для всех FSM/интеграций/gateways, принимающих решения на основе множественных осей состояния. Проверяется при ревью и релизе (см. раздел 11 "Impact-гейт" и раздел 15.1 для примеров).

**Метрики (обязательные для decision-логов):**
- `decision_rate{type}` — распределение решений (start/abort/retry/degrade) по типам
- `tcc_prompt_duration_ms` — длительность последовательности разрешений (p95, цель: ≤ 5 сек)
- `permission_flow_success` — процент успешных завершений потока разрешений (цель: ≥ 99%)
- `permission_restart_success_rate` — процент успешных автоматических перезапусков (цель: ≥ 98%)
- `permission_restart_latency_ms` — задержка перезапуска (p95, цель: ≤ 15 сек)

**Gate-проверка**: Тесты gateways **ОБЯЗАНЫ** проверять наличие decision-логов в каноническом формате (1 позитив + 1 негатив минимум). См. `tests/test_gateways.py` для примеров.

## 9. Разрешения и системные интеграции
- При работе с микрофоном, screen capture или Accessibility выполняй проверки через `permissions` модуль.
- Обновляй `PERMISSIONS_REPORT.md`, если добавляешь новые запросы или меняешь UX.
- В VoiceOver режимах следи за `voiceover_control` и `voiceover_ducking_integration` — они должны уважать системные настройки.

### 9.1 Permission Monitoring Config (источник истины)

**ВАЖНО**: Все тайминги и ограничения мониторинга разрешений — единственный источник истины:

**Первичные значения** (в `config/unified_config.yaml`):
```yaml
permission_restart:
  restart_delay_sec: 5.0              # Задержка перед перезапуском (показать уведомление)
  poll_interval_sec: 3.0              # Интервал polling мониторинга разрешений (если polling_enabled: true)
  max_restart_attempts: 3             # Максимум попыток перезапуска
  # MAX_WAIT_SECONDS: 600.0          # Максимальное ожидание безопасных условий (hardcoded в restart_scheduler.py)

first_run_permissions:
  pause_between_requests_sec: 1.0    # Пауза между запросами разрешений
  activation_hold_duration_sec: 13.0  # Пауза между диалогами для комфортного UX (13 секунд)
```

**Ссылки в других местах**: В документации (README, KEY_POINTS, BLOCKERS) указывай только ссылку на `unified_config.yaml`, не дублируй значения. **Источник истины — `unified_config.yaml`** (см. раздел 6).

**Использование в коде**: Все интеграции читают значения из `unified_config.yaml` через соответствующие config-менеджеры. Hardcoded значения допускаются только для констант (например, `MAX_WAIT_SECONDS = 600.0` в `restart_scheduler.py`), но должны быть документированы с указанием причины.

## 10. Тестирование
- Модульные тесты (если есть) держим рядом с модулями (`modules/*/tests` или `integration/tests`).
- Обязательные ручные проверки: push-to-talk, переходы режимов, Tray меню, автообновление Sparkle, VoiceOver ducking.
- Для регрессии глянь сценарии в `../Docs/CURRENT_STATUS_REPORT.md` и адаптируй плейлист.

### 10.1 Shadow-mode и Expected Logs (для first-run/restart)

**ОБЯЗАТЕЛЬНО**: Перед мерджем изменений, затрагивающих first-run/permission-restart, **ОБЯЗАНА** быть сверка со «спецификацией логов первого запуска» (см. раздел 8.1).

**Спецификация логов**: Логи первого запуска проверяются через `tests/test_golden_first_run_logs.py` и соответствуют спецификации в `Docs/first_run_flow_spec.md`.

**Проверка логов**: Используй `tests/test_golden_first_run_logs.py` для валидации последовательности логов перед мерджем.

## 11. Чеклист изменений
**Перед началом**
- Просмотри существующие модули/интеграции, чтобы не дублировать функционал.
- **Создай контракт EventBus** (см. раздел 16) для новой интеграции.
- Проверь unified_config и активность нужных интеграций.
- Определи какие события EventBus потребуются и как они влияют на режимы.
- **Проверь источник истины**: см. раздел 1.1 для STATE_CATALOG.md и interaction_matrix.yaml.

**Во время**
- Соблюдай архитектуру: интеграция → модуль → EventBus, никаких прямых вызовов между модулями.
- Сохраняй порядок инициализации SimpleModuleCoordinator.
- Сначала ищи возможность переиспользовать существующий модуль/интеграцию; если расширяешь, делай это через конфигурацию или дополнительные события.
- Добавляй новые события в явный список и документируй формат payload.
- Не забывай о `session_id`, `source` в событиях и об обработке ошибок.

**Инвариант: изменил поведение? обнови 4 артефакта**

Если изменение затрагивает оси состояния или правила взаимодействия, **ОБЯЗАТЕЛЬНО** обновить:
1. ✅ `Docs/STATE_CATALOG.md` — добавить/изменить ось, обновить владельцев/читателей
2. ✅ `config/interaction_matrix.yaml` — добавить/изменить правило взаимодействия
3. ✅ `integration/core/gateways.py` — реализовать логику в соответствующем gateway
4. ✅ Тесты gateways — добавить/обновить тесты (≥8–14 pairwise + 2 негативных) с проверкой decision-логов

**Machine-enforced правила** (машинно-проверяемые условия):
- **Запрет прямого доступа к состоянию**: `pyproject.toml` + `scripts/verify_no_direct_state_access.py` проверяют паттерны доступа к состоянию
- **Валидация схем**: `tests/test_schemas.py` + `scripts/validate_schemas.py` проверяют соответствие unified_config.yaml и interaction_matrix.yaml схемам
- **CI-гейты**: `.github/workflows/ci.yml` (lint, schema-validate, contracts-test, impact-gate) обязательны перед мерджем

**Проверка синхронизации** (перед мерджем):
- [ ] Все оси из STATE_CATALOG.md присутствуют в interaction_matrix.yaml (если влияют на решения)
- [ ] Все правила из interaction_matrix.yaml реализованы в gateways.py
- [ ] Все gateways покрыты тестами (≥8–14 pairwise + 2 негативных) с проверкой decision-логов в каноническом формате
- [ ] Machine-enforced правила пройдены (lint, schema-validate, verify_no_direct_state_access)
- [ ] **Требования обновлены**: Если изменение логики затрагивает требования, обновлён `Docs/PROJECT_REQUIREMENTS.md` и запущены `scripts/update_requirements_snapshot.py --check` + `scripts/check_requirements_mapping.py`

**Перед мерджем — SIMPLE-гейт**

- [ ] Решение доступно в v0: ≤60 LOC, ≤1 файл, без новых фича-флагов/зависимостей/демонов
- [ ] Использованы только существующие selectors/gateways и события EventBus
- [ ] Добавлены 1 happy + 1 негативный тест на gateway

Если нарушено — приложить микро-ADR (7 строк: причина → почему v0 не хватило → откат).

**Перед мерджем — Impact-гейт**

- [ ] Приложен `change_impact.yaml` (оси условий, инварианты, guards, тест-стратегия, метрики, роллаут)
- [ ] Обновлены `Docs/STATE_CATALOG.md` и/или `config/interaction_matrix.yaml` (если задето)
- [ ] `STATE_CATALOG.md` обновлён (оси/владельцы/читатели) под текущее изменение
- [ ] Есть минимум 8–14 pairwise тестов по выбранным осям + 2 негативных
- [ ] Логи решений видны локально: `decision=<...> ctx={...} source=<domain>` (см. раздел 8.x для канонического формата)
- [ ] Фича-флаг + kill-switch прописаны (см. раздел 19 «Роллаут»)
- [ ] Выполнены тест-планы из `required_test_plans` в `change_impact.yaml`, отчёт приложен (логи/события/метрики)

### 11.1 Impact Map (обязательный артефакт)
- Перед любыми правками ассистент формирует Impact Map и прикладывает её к задаче до внесения кода. Без заполненной карты изменение не стартует.
- Impact Map описывает полную цепочку влияния: какие оси/инварианты задеты, какие модули/интеграции/события EventBus/конфиги/флаги/kill-switches нужно синхронизировать, какие артефакты и тесты обновить.
- Минимальный шаблон:

| Ось или инвариант | Модули/интеграции | EventBus события/контракты | Конфиги/флаги | Тест-планы/скрипты |
| --- | --- | --- | --- | --- |
| permissions.mic | VoiceRecognitionIntegration, first_run_permissions_integration | voice.recognition.start/result | unified_config.yaml (`NEXY_FEATURE_PERMISSION_RESTART_V2`) | tests/test_gateways.py, scripts/verify_no_direct_state_access.py |

- Для каждой строки ассистент указывает конкретные файлы и проверки, которые нужно затронуть (STATE_CATALOG.md, interaction_matrix.yaml, gateways.py, Docs, scripts).
- После реализации Impact Map обновляется фактическими ссылками (PR diff, лог команд) и сверяется с `change_impact.yaml`.

**После**
- Если добавлена новая интеграция/модуль — зафиксируй обоснование в `../Docs/CURRENT_STATUS_REPORT.md`.
- **Проверь контракт EventBus** согласно чек-листу (раздел 16.6).
- Добавь интеграцию в `SimpleModuleCoordinator._create_integrations()` (если новая) и настрой приоритеты.
- Обнови `unified_config.yaml`, документацию и при необходимости паковочные гайты.
- Прогоняй ручные проверки и убедись, что логи чисты от ошибок.
- Если менялись gRPC контракты — синхронизируй изменения с серверной командой.
- **Если изменение логики затрагивает требования**: обнови `Docs/PROJECT_REQUIREMENTS.md` и запусти `scripts/update_requirements_snapshot.py --update` + `scripts/check_requirements_mapping.py` (см. раздел 11.3).
- **Перед мерджем**: запусти `scripts/pre_build_gate.sh` для проверки всех обязательных проверок (см. раздел 11.4).

### 11.3 Процесс обновления требований (RELEASE_INTEGRITY_PLAN этап 1)

**ОБЯЗАТЕЛЬНО**: Любое изменение логики, затрагивающее требования, начинается с обновления `Docs/PROJECT_REQUIREMENTS.md`.

**Before (подготовка)**:
1. Проверить текущий `Docs/PROJECT_REQUIREMENTS.md`
2. Определить, какие требования (REQ-XXX) затрагиваются
3. Уведомить Owner требования о планируемых изменениях

**During (внесение изменений)**:
1. Обновить `Docs/PROJECT_REQUIREMENTS.md`:
   - Добавить/изменить требование (REQ-XXX) с полями: Домен, Критичность, Описание, Источник, Owner, Ожидаемый результат, Implementation, Verification
   - Обновить Implementation Map (таблица соответствия требований реализации и тестам)
2. Обновить исходный документ (если требуется)
3. Обновить код/тесты согласно требованию
4. Запустить `scripts/update_requirements_snapshot.py --check` для валидации структуры
5. Запустить `scripts/check_requirements_mapping.py` для проверки соответствия Implementation/Verification

**After (проверка синхронизации)**:
1. ✅ Все требования из исходных документов присутствуют в snapshot
2. ✅ Все требования имеют Implementation и Verification
3. ✅ Скрипты проверки пройдены (`update_requirements_snapshot.py --check`, `check_requirements_mapping.py`)
4. ✅ Owner требования уведомлён и одобрил изменения
5. ✅ Обновлён `client/VERSION_INFO.json` через `scripts/update_requirements_snapshot.py --update`

**Связанные документы**:
- `Docs/PROJECT_REQUIREMENTS.md` — единый snapshot требований
- `Docs/REQUIREMENTS_SOURCE_MAP.md` — карта всех документов требований
- `scripts/update_requirements_snapshot.py` — валидация и обновление snapshot
- `scripts/check_requirements_mapping.py` — проверка соответствия требований коду и тестам

### 11.4 Pre-build Gate (RELEASE_INTEGRITY_PLAN этап 2)

**ОБЯЗАТЕЛЬНО**: Перед мерджем и сборкой запускается `scripts/pre_build_gate.sh` для проверки всех обязательных проверок.

**Что проверяет pre-build gate**:
1. **Линтеры и форматтеры**: ruff lint, проверка прямого доступа к состоянию
2. **Unit-тесты**: тесты схем, gateways, порядка инициализации, permission restart, golden tests, SLO
3. **Статические проверки**: валидация схем, 4-артефактный инвариант, покрытие правил/предикатов, регистрация feature flags, валидация snapshot требований
4. **Специализированные проверки**: TAL assertion, permission monitoring, критические пути, tray termination

**Использование**:
```bash
# Полная проверка
./scripts/pre_build_gate.sh

# С опциями
./scripts/pre_build_gate.sh --skip-tests    # Пропустить тесты
./scripts/pre_build_gate.sh --skip-lint     # Пропустить линтеры
./scripts/pre_build_gate.sh --verbose       # Подробный вывод
```

**В CI**: Pre-build gate запускается автоматически в `.github/workflows/ci.yml` (job `pre-build-gate`).

**Exit codes**:
- `0` — все проверки пройдены, можно продолжать сборку
- `1` — хотя бы одна проверка провалена, сборка блокируется

**Связанные документы**:
- `scripts/pre_build_gate.sh` — скрипт pre-build gate
- `.github/workflows/ci.yml` — CI интеграция
- `Docs/PROJECT_REQUIREMENTS.md` — требования REQ-023 (Machine-enforced правила)

### 11.5 Release Suite (RELEASE_INTEGRITY_PLAN этап 3)

**ОБЯЗАТЕЛЬНО**: Перед релизом запускается `scripts/run_release_suite.py` для выполнения полного цикла интеграционных проверок.

**Что проверяет Release Suite**:
1. **Pre-build gate**: все обязательные проверки перед сборкой
2. **Сборка dev-билда**: PyInstaller сборка клиента
3. **Проверка логов**: headless запуск и проверка логов на соответствие спецификациям (AppKit fix, TAL удержание, first-run)
4. **Интеграционные тесты**: критические тесты (gateways, init order, permission restart)
5. **Проверки сервера**: gRPC health check, AppCast доступность
6. **Сверка требований**: соответствие PROJECT_REQUIREMENTS с тестами

**Использование**:
```bash
# Полный цикл проверок
python scripts/run_release_suite.py

# С опциями
python scripts/run_release_suite.py --smoke         # Smoke mode: быстрые проверки без сборки и сервера
python scripts/run_release_suite.py --skip-build    # Пропустить сборку
python scripts/run_release_suite.py --skip-server   # Пропустить проверки сервера
python scripts/run_release_suite.py --output report.json  # Сохранить отчёт
```

**JSON-отчёт**: Release Suite возвращает JSON-отчёт с результатами всех проверок (`release_suite_report.json`).

**Exit codes**:
- `0` — все проверки пройдены, можно продолжать релиз
- `1` — хотя бы одна проверка провалена, релиз блокируется

**Связанные документы**:
- `scripts/run_release_suite.py` — скрипт Release Suite
- `Docs/PROJECT_REQUIREMENTS.md` — требования для сверки
- Процесс Release Suite описан в разделе 11.5 данного документа

### 11.6 Prepare Release (RELEASE_INTEGRITY_PLAN этап 4)

**ОБЯЗАТЕЛЬНО**: Перед релизом запускается `scripts/prepare_release.sh` для выполнения полной цепочки подготовки релиза.

**Что выполняет prepare_release**:
1. **Pre-build gate**: все обязательные проверки перед сборкой
2. **Release Suite**: полный цикл интеграционных проверок
3. **PyInstaller сборка**: создание .app через rebuild_from_scratch.sh
4. **Встраивание метаданных**: копирование VERSION_INFO.json и release_suite_report.json в .app
5. **PKG создание**: pkgbuild и productbuild через build_final.sh
6. **Нотарификация**: проверка статуса нотарификации (выполняется в build_final.sh)
7. **Валидация бандла**: проверка метаданных и отчётов через validate_release_bundle.py

**Использование**:
```bash
# Полная цепочка подготовки релиза
./scripts/prepare_release.sh

# С опциями
./scripts/prepare_release.sh --skip-tests          # Пропустить тесты в pre-build gate
./scripts/prepare_release.sh --skip-notarization    # Пропустить проверку нотарификации
./scripts/prepare_release.sh --dry-run             # Режим dry-run (команды не выполняются)
```

**Exit codes**:
- `0` — все шаги пройдены, релиз готов
- `1` — хотя бы один шаг провален, релиз блокируется

**Связанные документы**:
- `scripts/prepare_release.sh` — скрипт подготовки релиза
- `scripts/validate_release_bundle.py` — валидация релизного бандла
- `packaging/build_final.sh` — финальная сборка и нотарификация
- Процесс Prepare Release описан в разделе 11.6 данного документа

### 11.7 Validate Release Bundle

**ОБЯЗАТЕЛЬНО**: Перед загрузкой на сервер запускается `scripts/validate_release_bundle.py` для проверки метаданных артефакта.

**Что проверяет validate_release_bundle**:
1. **Структура .app**: наличие обязательных путей (Contents/Info.plist, Contents/MacOS/Nexy, Contents/Resources)
2. **Info.plist**: валидность и наличие обязательных ключей (CFBundleIdentifier, CFBundleVersion)
3. **VERSION_INFO.json**: наличие и валидность метаданных (version, req_version, req_checksum)
4. **release_suite_report.json**: наличие и валидность отчёта Release Suite
5. **Подпись кода**: проверка через `codesign --verify`
6. **Нотарификация**: проверка через `xcrun stapler validate`
7. **PKG (опционально)**: проверка подписи и нотарификации PKG

**Использование**:
```bash
# Валидация .app
python scripts/validate_release_bundle.py dist/Nexy.app

# Валидация .app и .pkg
python scripts/validate_release_bundle.py dist/Nexy.app dist/Nexy.pkg
```

**Exit codes**:
- `0` — все проверки пройдены
- `1` — есть ошибки валидации

**Связанные документы**:
- `scripts/validate_release_bundle.py` — скрипт валидации
- Процесс Validate Release Bundle описан в разделе 11.7 данного документа

### 11.8 Continuous Verification (RELEASE_INTEGRITY_PLAN этап 5)

**ОБЯЗАТЕЛЬНО**: CI обеспечивает непрерывную проверку качества через автоматические проверки.

**Что включает Continuous Verification**:
1. **На PR**: pre-build gate + усечённый release suite (smoke mode)
2. **Nightly**: полный release suite + отчёт о покрытии требований
3. **Автоматические отчёты**: покрытие требований (что проверено, что нет)

**CI Workflow**:
- **pre-build-gate**: запускается на всех событиях (PR, push, schedule, workflow_dispatch)
- **release-suite-smoke**: запускается только на PR (быстрые проверки без сборки и сервера)
- **release-suite-full**: запускается на schedule (nightly) и workflow_dispatch (ручной запуск)

**Отчёты**:
- `release_suite_report.json` — результаты Release Suite (загружается как артефакт)
- `requirements_coverage_report.json` — покрытие требований (только в nightly)

**Использование**:
```bash
# Генерация отчёта о покрытии требований
python scripts/generate_requirements_coverage.py --output requirements_coverage_report.json
```

**Связанные документы**:
- `.github/workflows/ci.yml` — CI workflow с nightly builds
- `scripts/generate_requirements_coverage.py` — генерация отчёта о покрытии требований
- Процесс Continuous Verification описан в разделе 11.8 данного документа

### 11.9 Continuous Monitoring (RELEASE_INTEGRITY_PLAN этап 8)

**ОБЯЗАТЕЛЬНО**: Непрерывный мониторинг метрик и SLO обеспечивает контроль качества в production.

**Что включает Continuous Monitoring**:
1. **Мониторинг метрик**: анализ логов и извлечение метрик из `client/metrics/registry.md`
2. **Проверка SLO**: автоматическая проверка соответствия метрик SLO порогам
3. **Отчёты**: генерация JSON-отчётов о производительности и нарушениях SLO
4. **Интеграция в CI**: проверка SLO в nightly builds и перед релизом

**Использование**:
```bash
# Анализ метрик из лог-файла
python scripts/monitor_metrics.py --log-file log.md --output metrics_report.json

# Проверка SLO с выходом при нарушениях
python scripts/monitor_metrics.py --log-file log.md --check-slo

# Автоматический поиск последнего лог-файла
python scripts/monitor_metrics.py --output metrics_report.json
```

**SLO пороги**: Определены в `client/metrics/registry.md` и проверяются автоматически.

**Exit codes**:
- `0` — все метрики соответствуют SLO порогам (или проверка не выполнялась)
- `1` — обнаружены нарушения SLO (только с флагом `--check-slo`)

**Связанные документы**:
- `scripts/monitor_metrics.py` — скрипт мониторинга метрик
- `client/metrics/registry.md` — реестр метрик и SLO порогов
- `tests/perf/test_slo.py` — тесты SLO
- Процесс Continuous Monitoring описан в разделе 11.9 данного документа

### 11.2 Packaging Regression Checklist
- Любые изменения, влияющие на рантайм, ресурсы, конфигурацию, зависимости или упаковку, сопровождаются заполненным checklist до ревью.
- Checklist ссылается на `Docs/PACKAGING_FINAL_GUIDE.md` и соответствующие `client/modules/*/MACOS_PACKAGING_GUIDE.md`; шаги нельзя пропускать без ADR.
- Минимальный набор проверок:
  1. PyInstaller сборка (`rebuild_from_scratch.sh` или аналог) — приложить лог выполнения.
  2. `pkgbuild` + `productbuild` + notarization dry-run — зафиксировать команды и статусы.
  3. Валидация `unified_config.yaml`, `Docs/PACKAGING_FINAL_GUIDE.md`, модульных MACOS_PACKAGING_GUIDE на актуальность после изменений.
  4. Smoke-тест `cold_start_diagnostics.sh` и запуск собранной `.app` из `dist/` (логи приложены).
  5. Проверка ресурсов (ffmpeg, assets) на присутствие в пакете и валидные пути.
- Итоговый статус фиксируй в `Docs/PACKAGING_READINESS_CHECKLIST.md` (ссылка на обновлённый `Docs/PRE_PACKAGING_VERIFICATION.md`).
- Результаты checklist прикладываются к PR/таске вместе с логами. Без выполненного checklist правки не мержим.

## 12. Распространённые риски
- Изменение режима без `mode.request` ломает FSM и workflows.
- Дублирование конфигурации приводят к рассинхронизации при сборке.
- Прямые вызовы модулей минуя интеграции нарушают масштабируемость.
- Отсутствие проверок разрешений вызывает краши в production.
- Непрожатые события `session_id` делают сложным трекинг цепочек в логах.

## 13. Напоминание
Клиентская часть должна оставаться совместимой с уже завершёнными интеграциями. При сомнениях синхронизируйся с владельцем сервера и UX прежде чем менять контракт или пользовательский поток.

**ОБНОВЛЕНО:** Создана `first_run_permissions_integration.py` - полноценная система первого запуска с умными паузами и блокирующей логикой. Проверка разрешений также выполняется через специализированные интеграции (VoiceRecognitionIntegration, ScreenshotCaptureIntegration и т.д.).

## 14. Принципы архитектуры "быстрой диагностики"

### 14.1 Модули и границы (адаптировано под Nexy)
- **Модуль = изолированная ответственность** + собственная "экосистема" в `client/modules/`
- **Вход только через интеграции** (`client/integration/integrations/`), выход — через EventBus события
- **Зависимости строго внутрь** (core → types), core не импортирует platform-specific код
- **После принятия модуля в "рабочий" режим изменения — только через ADR + тест-план**
- **Запрет на дублирование**: один capability — один владелец (указан в README модуля)

**Definition of Done (модуль):** README, публичные интерфейсы в types.py, конфигурация, логирование событий, тесты (если есть), диагностические эндпоинты.

### 14.2 Интеграции и контракты (адаптировано под EventBus)
- **У каждой интеграции есть четкий контракт** через EventBus события + payload схемы
- **Совместимость**: несовместимые изменения → новая мажорная версия события, совместимые — минор
- **Интеграция только по "Инструкции модуля"**: входные события валидируются на границе

**FSM-домены с guard-условиями (нормирование):**
Для доменов `audio`, `permissions`, `mode_management`, `first_run`, `permission_restart` решения принимаются **ТОЛЬКО через FSM-таблицы и gateways**:
- `(state, event) --[guard]--> (new_state, action)`
- Guard-условия обязаны проверять критичные оси: permissions, device, network, firstRun
- Все проверки состояния через selectors, все решения через gateways (см. раздел 21)
- Запрещены скрытые записи состояний в чужие домены — только через EventBus

**Нормирование FirstRunPermissions/PermissionRestart:**
- FirstRunPermissions: решения через gateways (`decide_start_listening` с проверкой `first_run`)
- PermissionRestart: решения через gateways (см. `modules/permission_restart/core/restart_scheduler.py`)
- Поведение фиксируется в `interaction_matrix.yaml` с приоритетами (hard_stop/graceful)
- Все блокировки и отсрочки отражены в `config/interaction_matrix.yaml` с приоритетами (hard_stop/graceful)

### 14.3 Конфигурация и состояние (уже реализовано)
- **Единый источник конфигурации** (`unified_config.yaml`) + схемы конфигурации
- **Минимум shared state**; глобальные состояния — только в ApplicationStateManager
- **Конфиг инициализируется один раз на старте** и логируется

### 14.4 Наблюдаемость "по умолчанию" (адаптировано под текущее логирование)
- **Структурированные логи** с session_id для трекинга цепочек
- **Таксономия ошибок** через ErrorHandler с кодами и контекстом
- **Метрики**: error-rate, latency по интеграциям, счетчики событий
- **Диагностический режим**: расширенные логи, health checks через EventBus

### 14.5 Качество кода и стандарты
- **Код-стайл и линтеры** — обязательны
- **Запрет копипаста интерфейсов** (single source of truth — types.py в модулях)
- **Guards/asserts для инвариантов** домена; Result вместо исключений внутри домена

### 14.6 Тест-стратегия (минимум для Nexy)
- **Unit тесты** для core логики модулей (<10мс, без IO)
- **Contract тесты** для интеграций (EventBus события + payload)
- **Интеграционные тесты** — локальный стенд с реальными модулями
- **Smoke тесты** — 5–10 happy-path сценариев перед релизом
- **Ручные проверки** — push-to-talk, переходы режимов, Tray меню

### 14.7 Поставка и изменения
- **ADR (Architecture Decision Record)** для значимых изменений в модули
- **Фича-флаги** через unified_config для постепенного rollout
- **Миграции двунаправленные**; форматы событий — совместимые на время перехода
- **Если SLO пробит — стоп релизы**, приоритет стабильности
 - **ADR-минимум**: один абзац «что/почему/альтернативы/дата» для любого изменения модуля или матрицы взаимодействий

### 14.8 Безопасность и приватность (адаптировано под macOS)
- **Секреты — из Keychain**; в логах маскировка PII
- **Лейблы в событиях без чувствительных данных**
- **Поведенческие лимиты**: rate-limits как часть контракта интеграций

### 14.9 Производительность и бюджет
- **Для ключевых usecase заданы latency-бюджеты** (p95) через EventBus
- **"Тяжёлые" пути** — с профилировкой и отдельными метриками

## 15. Мини-спецификации качества

### 15.1 Требования к логированию (каждый модуль)
- **Формат логов**: `YYYY-MM-DD HH:MM:SS - Nexy - LEVEL - [session_id] - Message`
- **События**: `module.start|ok|fail` с session_id, duration_ms, ключевым контекстом
- **Ошибки**: code, reason, module, retries, timeout_ms через ErrorHandler
- **Лог-уровни**: warn — ожид. аномалии; error — потеря функции. info — бизнес-события
- **Для DIAG**: добавлять config_hash, build_id, git_sha

**Decision-лог**: см. раздел 8.x для канонического формата. Используется для FSM/интеграций, принимающих решения на основе множественных осей состояния.

**Метрики**:
- `decision_rate{type}` — распределение решений
- `stream_open_success_rate` — доля удачных запусков аудио
- `tcc_prompt_duration_ms` — длительность последовательности разрешений (p95)

**Примеры**:
- `2024-01-15 10:30:45 - Nexy - INFO - [abc123] - voice_recognition.start - duration_ms=150`
- `2024-01-15 10:30:46 - Nexy - ERROR - [abc123] - E_DEP_TIMEOUT - gRPC connection failed`

### 15.2 Таксономия ошибок (адаптированная под Nexy)
- **Коды ошибок**: E_INPUT_INVALID, E_STATE_INVAR, E_DEP_TIMEOUT, E_DEP_UNAVAILABLE, E_RATE_LIMITED, E_UNKNOWN
- **Категории ErrorHandler**: INITIALIZATION, RUNTIME, CONFIGURATION, NETWORK, PERMISSION, UNKNOWN
- **Политики живут в unified_config** (timeouts/retries), код их читает
- **Маппинг**: коды ошибок → категории ErrorHandler → уровни логирования

### 15.3 Инструкция модуля (README шаблон)
- **Назначение, владельцы**
- **Публичные интерфейсы** (types.py) + ссылки на EventBus события
- **Инварианты и ошибки** (маппинг кодов)
- **Метрики и ключевые логи**
- **Диаг-эндпоинты и self-checks**
- **Примеры сценариев** (fixtures + команда запуска)

### 15.4 Чек-лист "принять модуль"
- **Контракт EventBus создан** согласно разделу 16 (обязательно!)
- **Контракты и схемы** лежат в types.py
- **Валидаторы входа** включены на границе интеграции
- **Логи/метрики/трейсинг** соответствуют стандарту
- **Unit/Contract/Integration/Smoke** — зелёные
- **Diag-режим и health-пробы** работают
- **ADR на рисковые решения** добавлен

## 16. Руководство по созданию контрактов интеграции

### 16.1 Обязательность контрактов
- **Каждая интеграция ДОЛЖНА иметь четкий контракт** через EventBus события
- **Без контракта интеграция не принимается** в production
- **Контракт документируется** в README модуля и в интеграции

### 16.2 Структура контракта EventBus
```python
# Пример контракта для voice_recognition_integration
CONTRACT = {
    "module": "voice_recognition",
    "version": "1.0",
    "events": {
        "input": {
            "voice.recognition.start": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "language": "string (optional, default: en-US)",
                    "timeout_sec": "float (optional, default: 10.0)"
                },
                "required": ["session_id"]
            },
            "voice.recognition.stop": {
                "payload": {
                    "session_id": "string (uuid4)"
                },
                "required": ["session_id"]
            }
        },
        "output": {
            "voice.recognition.result": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "text": "string",
                    "confidence": "float (0.0-1.0)",
                    "language": "string",
                    "duration_ms": "int"
                },
                "required": ["session_id", "text"]
            },
            "voice.recognition.error": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "error_code": "string (E_INPUT_INVALID|E_DEP_TIMEOUT|E_UNKNOWN)",
                    "error_message": "string",
                    "retry_count": "int (optional)"
                },
                "required": ["session_id", "error_code", "error_message"]
            }
        }
    }
}
```

### 16.3 Правила именования событий
- **Формат**: `<module>.<action>` (например: `voice.recognition.start`)
- **Модуль**: название модуля в snake_case
- **Действие**: глагол в present tense (start, stop, result, error, request, response)
- **Версионирование**: мажорные изменения → новое событие `v2` (например: `voice.recognition.start.v2`)

### 16.4 Схемы payload
- **Обязательные поля**: `session_id` для всех событий
- **Типы данных**: string, int, float, bool, dict, list
- **Валидация**: на границе интеграции через pydantic или dataclasses
- **Документация**: каждый payload документируется с примерами

### 16.5 Версионирование контрактов
- **Мажорные изменения** (breaking): новая версия события (`module.action.v2`)
- **Минорные изменения** (совместимые): добавление optional полей
- **Обратная совместимость**: старые события поддерживаются 2 версии
- **Миграция**: через unified_config флаги

### 16.5.1 Migration Playbook (безопасные breaking changes)

**Цель**: Безопасный переход от `module.action.v1` к `module.action.v2` без потери функциональности.

#### Чек-лист миграции событий

**Before (подготовка)**:
1. [ ] Определить breaking changes в payload/семантике события
2. [ ] Создать новую версию события (`module.action.v2`)
3. [ ] Добавить feature flag для новой версии (`NEXY_FEATURE_<MODULE>_V2`)
4. [ ] Обновить контракт EventBus с обеими версиями
5. [ ] Уведомить всех потребителей события о планах миграции

**During (shadow-mode)**:
1. [ ] Обе версии публикуются параллельно (v1 + v2)
2. [ ] Новая версия включена только для тестовых пользователей (1% → 25% → 100%)
3. [ ] Мониторинг метрик: нет регрессий на новой версии
4. [ ] Мониторинг ошибок: нет критических ошибок в v2

**Migration timeline**:
- **Week 1-2**: Shadow-mode (1% пользователей)
- **Week 3-4**: Gradual rollout (25% → 50% → 75%)
- **Week 5**: Full rollout (100%)
- **Week 6**: Deprecation notice для v1 (логирование warning)
- **Week 8+**: Удаление v1 (после 2 версий поддержки)

**After (завершение миграции)**:
1. [ ] Все потребители переведены на v2
2. [ ] Feature flag удалён (v2 по умолчанию)
3. [ ] v1 код удалён из кодовой базы
4. [ ] Контракт обновлён (только v2)
5. [ ] Документация обновлена

#### Пример миграции

```python
# Shadow-mode: обе версии поддерживаются
def publish_event(self, event_name: str, payload: dict):
    # Старая версия (для обратной совместимости)
    self.event_bus.publish(f"{event_name}", payload)
    
    # Новая версия (если feature flag включен)
    if self._config.get("use_v2", False):
        v2_payload = migrate_to_v2(payload)
        self.event_bus.publish(f"{event_name}.v2", v2_payload)
```

#### Правила безопасности

- **НЕ удаляй v1** пока не прошло минимум 2 версии релизов после полного rollout v2
- **НЕ меняй v1** после начала миграции (только deprecation warnings)
- **ВСЕГДА используй feature flags** для контроля rollout
- **ВСЕГДА мониторь метрики** во время миграции
- **ВСЕГДА имей kill-switch** для мгновенного отката

### 16.6 Чек-лист контракта
- ✅ **События документированы** с полными payload схемами
- ✅ **Валидация payload** на границе интеграции
- ✅ **Обработка ошибок** через ErrorHandler с кодами
- ✅ **Тесты контракта** (unit + integration)
- ✅ **Примеры использования** в README
- ✅ **Версионирование** для breaking changes
- ✅ **Обратная совместимость** соблюдена

### 16.7 Примеры контрактов
- **signals**: см. `modules/signals/INTEGRATION_GUIDE.md`
- **voice_recognition**: события start/stop/result/error
- **grpc_client**: события request/response/error с session_id
- **mode_management**: события mode.request/mode.changed

### 16.8 Инструменты для контрактов
- **Валидация**: pydantic, dataclasses с type hints
- **Тестирование**: contract tests с фикстурами
- **Документация**: OpenAPI-подобные схемы в README
- **Мониторинг**: метрики по событиям и ошибкам


## 17. Базовые архитектурные принципы

### 17.1 SOLID принципы
- **Single Responsibility**: каждый модуль отвечает за одну задачу
- **Open/Closed**: модули открыты для расширения, закрыты для модификации
- **Liskov Substitution**: интеграции взаимозаменяемы через BaseIntegration
- **Interface Segregation**: четкие интерфейсы в types.py
- **Dependency Inversion**: зависимости через EventBus, не прямые импорты

### 17.2 Dependency Injection
- **Внедрение через конструктор**: EventBus, StateManager, ErrorHandler
- **Инверсия зависимостей**: модули не знают о конкретных реализациях
- **Конфигурация извне**: unified_config.yaml, не хардкод в модулях
- **Тестируемость**: легко подменить зависимости в тестах

### 17.3 Separation of Concerns
- **Модули**: бизнес-логика и низкоуровневые операции
- **Интеграции**: координация и адаптация к EventBus
- **Core**: инфраструктура (EventBus, StateManager, ErrorHandler)
- **Workflows**: управление состояниями приложения

### 17.4 Design Patterns
- **Factory**: создание модулей через SimpleModuleCoordinator
- **Observer**: подписка на события через EventBus
- **Strategy**: разные реализации через интеграции
- **Adapter**: интеграции как адаптеры между модулями и EventBus
- **Singleton**: ApplicationStateManager, ErrorHandler (один экземпляр)

### 17.5 Принципы качества кода
- **DRY (Don't Repeat Yourself)**: переиспользование через интеграции
- **KISS (Keep It Simple)**: простые интерфейсы, сложность в модулях
- **YAGNI (You Aren't Gonna Need It)**: только необходимая функциональность
- **Composition over Inheritance**: предпочтение композиции наследованию

## 18. Каталог состояний и матрица взаимодействий

### 18.1 STATE_CATALOG (Docs/STATE_CATALOG.md)

- Оси/флаги: `permissions.mic|screen|accessibility`, `device.input`, `network`, `firstRun`, `appMode`, `update_in_progress`, ...
- Для каждой оси: допустимые состояния, владелец, кто пишет/читает, источник истины, метрики.
- Ответственный: один владелец документа (по умолчанию: Tech Lead клиента).

**НОВАЯ ОСЬ**: `update_in_progress` — статус обновления приложения (см. STATE_CATALOG.md раздел 10). Владелец: UpdaterIntegration owner. Используется для безопасного рестарта во время обновлений.

### 18.2 INTERACTION_MATRIX (config/interaction_matrix.yaml)

- Фиксирует только взаимозависимые оси (без полного перебора).
- Формат правила:
  - `when: {Permission.mic: denied, appMode: listen} -> decision: abort_listen`
  - `priority: hard_stop | graceful | preference`
- Любое изменение >2 осей должно обновлять эту матрицу.
- Правила приоритетов условий:
  1. `hard_stop`: безопасность/разрешения/инварианты — всегда прерывают действие;
  2. `graceful`: деградация (сеть/квоты) — урезаем функционал, но живём;
  3. `preference`: UX-предпочтения — только если не конфликтуют с 1–2.

**Правила для `update_in_progress`**:
- `graceful` при `update_in_progress=true` → блокирует permission restart (через gateway `decide_permission_restart_safety`)
- `hard_stop` при `update_in_progress=true` + `appMode=LISTENING|PROCESSING` → блокирует запуск обновления
- Селекторы и gateways должны проверять `update_in_progress` в паре с `interaction_matrix.yaml` (см. STATE_CATALOG.md раздел 10)

## 19. Политика роллаута изменяющих взаимодействия

- Любое изменение, затрагивающее >2 осей, включается через фича-флаг.
- Этапы: 1% → 25% → 100% (config-driven), с возможностью shadow-mode (считаем решение, но не применяем).
- Kill-switch: `NEXY_KS_<FEATURE>` в окружении/конфиге, выключает поведение немедленно без релиза.
- В `change_impact.yaml` обязательно указать: флаг, план раскатки, условие отката.

### 19.1 Feature Flags и Kill-Switches (обязательный слой)

**ОБЯЗАТЕЛЬНО**: Любое поведение, затрагивающее >2 оси состояния, **ОБЯЗАНО** раскатываться через feature flag и иметь мгновенный откат (kill-switch).

**Реестр флагов**: См. `Docs/FEATURE_FLAGS.md` — единый источник истины для всех feature flags/kill-switches.

**Правило регистрации флагов (ОБЯЗАТЕЛЬНО)**:
- **Новый флаг запрещён без добавления в `Docs/FEATURE_FLAGS.md`** и прохождения `scripts/verify_feature_flags.py`
- Перед использованием любого флага в коде он **ОБЯЗАН** быть зарегистрирован в реестре:
  - **env-флаги**: `NEXY_FEATURE_*`, `NEXY_KS_*`, `NEXY_DISABLE_*` (переменные окружения)
  - **config-флаги**: `features.*` в `unified_config.yaml` (например: `use_events_for_update_status`, `serial_tcc_prompts`)
- Формат регистрации: `| name | type | owner | default | scope | kill_switch | description |`
- Скрипт `scripts/verify_feature_flags.py` автоматически проверяет:
  - Все env-флаги в коде (regex поиск `NEXY_*`)
  - Все config-флаги из `unified_config.yaml` секции `features.*`
- Проверка интегрирована в `scripts/verify_architecture.py` и выполняется перед мерджем

**Конкретные флаги для first-run/permission-restart:**
- `NEXY_FEATURE_FIRST_RUN_V2` — включить систему первого запуска (v2)
- `NEXY_FEATURE_PERMISSION_RESTART_V2` — включить автоматический перезапуск после разрешений (v2)
- `NEXY_KS_PERMISSION_RESTART_V2` — kill-switch для мгновенного отключения перезапуска (env переменная или unified_config)
- `NEXY_DISABLE_AUTO_RESTART` — env-переключатель для dry-run режима (перезапуск не выполняется)

**Правила использования:**
- Feature flags: постепенный роллаут (1% → 25% → 100%) через `unified_config.yaml` или env переменные
- Kill-switches: мгновенный откат без релиза (env переменная или `unified_config.yaml`)
- Все флаги должны быть зарегистрированы в `Docs/FEATURE_FLAGS.md` перед мерджем (см. раздел 6.1)

## 20. SLO и стоп-релизы (beta)

- `p95 start_listening ≤ 600ms`
- `stream_open_success_rate ≥ 98%`
- `permission_flow_success ≥ 99%` (микрофон+экран на first-run)
- Если SLO пробит на beta-канале — стоп всех функциональных релизов до восстановления.

## 21. Selectors и Gateways (архитектура принятия решений)

### 21.1 Принцип разделения ответственности

**Selectors** (`integration/core/selectors.py`): чистые функции для проверки состояний из `Snapshot`.
- Только чтение: не меняют состояние, не имеют side-effects
- Один источник истины: все проверки состояния через selectors
- Примеры: `mic_ready(s)`, `device_idle(s)`, `network_online(s)`, `is_listening_mode(s)`

**Gateways** (`integration/core/gateways.py`): функции принятия решений на основе `Snapshot` и selectors.
- Бизнес-логика: реализуют правила переходов состояний и обработку ошибок
- Используют selectors: никогда не читают состояние напрямую
- Возвращают `Decision`: START, RETRY, ABORT, DEGRADE
- Примеры: `decide_start_listening(s)`, `decide_process_audio(s)`, `decide_with_backoff(s, retry_count)`

### 21.2 Snapshot — единая точка доступа

```python
@dataclass(frozen=True)
class Snapshot:
    perm_mic: PermissionStatus
    perm_screen: PermissionStatus
    perm_accessibility: PermissionStatus
    device_input: DeviceStatus
    network: NetworkStatus
    first_run: bool
    app_mode: AppMode
```

`Snapshot` — неизменяемый снимок всех осей состояния системы. Создается один раз на момент принятия решения и передается в selectors/gateways.

### 21.3 Запрет прямого доступа к состоянию

**Правило**: все проверки состояния ТОЛЬКО через selectors. Прямой доступ к `state_manager` или конфигурации для проверки осей запрещен.

**Исключения**: только файлы `**/selectors.py`, `**/gateways.py`, `**/gateways/**/*.py` могут читать состояние напрямую.

**Линтер**: `pyproject.toml` настроен на проверку паттернов доступа к состоянию (`perm_mic`, `network_online`, `first_run`, `feature_*`, `ks_*`) и фейлит, если файл не в списке исключений.

### 21.4 Использование в интеграциях

```python
from integration.core.selectors import Snapshot, PermissionStatus, DeviceStatus, NetworkStatus, AppMode
from integration.core.gateways import decide_start_listening, Decision
from integration.core.state_manager import ApplicationStateManager

# Создаем snapshot
snapshot = Snapshot(
    perm_mic=PermissionStatus.GRANTED,
    perm_screen=PermissionStatus.GRANTED,
    perm_accessibility=PermissionStatus.GRANTED,
    device_input=DeviceStatus.DEFAULT_OK,
    network=NetworkStatus.ONLINE,
    first_run=False,
    app_mode=AppMode.SLEEPING
)

# Принимаем решение через gateway
decision = decide_start_listening(snapshot)

if decision == Decision.START:
    # Начать listening
    pass
elif decision == Decision.ABORT:
    # Прервать с ошибкой
    pass
elif decision == Decision.RETRY:
    # Повторить с backoff
    pass
elif decision == Decision.DEGRADE:
    # Деградировать функционал
    pass
```

### 21.5 Логирование решений

Все решения логируются в каноническом формате (см. раздел 8.x):

```
decision=<start|abort|retry|degrade> ctx={mic=...,screen=...,device=...,network=...,firstRun=...,appMode=...} source=<domain> duration_ms=<int>
```

Gateways автоматически логируют решения с контекстом из `Snapshot`.

### 21.6 Тестирование selectors/gateways

- **Unit тесты**: selectors — чистые функции, тестируются изолированно с mock `Snapshot`
- **Unit тесты**: gateways — тестируются с различными комбинациями `Snapshot`
- **Pairwise тесты**: покрытие комбинаций осей согласно `interaction_matrix.yaml`
- **Contract тесты**: проверка соответствия логики gateways правилам из `interaction_matrix.yaml`

### 21.7 Связь с interaction_matrix.yaml

Правила из `interaction_matrix.yaml` реализованы в gateways:
- `priority: hard_stop` → `Decision.ABORT`
- `priority: graceful` → `Decision.RETRY` или `Decision.DEGRADE`
- `priority: preference` → учитывается в последнюю очередь

При изменении `interaction_matrix.yaml` обновляются соответствующие gateways и добавляются тесты.

## 22. CRM Task Management (Federated Workspaces)

### 22.1 Ваш Workspace
Cursor работает в **client/** директории. Создаёт задачи в:
- `client/.crm/TASKS.json` — префикс `CLI-`

### 22.2 Жизненный цикл задачи

**Статусы:**
| Статус | Описание | Когда ставить |
|:-------|:---------|:--------------|
| `plan` | Запланировано | Новая задача, ещё не начата |
| `in_progress` | В работе | Активно работаем над задачей |
| `testing` | Тестируется | Код готов, проверяем |
| `released` | Готово к релизу | Полностью завершено |

**Переходы:**
```
plan → in_progress → testing → released
         ↓              ↓
       plan ←——————— plan (откат)
```

### 22.3 Создание задачи

**Когда создавать:**
- Начинаете новую работу (фикс, фича, рефакторинг)
- Получили запрос от пользователя
- Обнаружили баг во время работы

**Обязательные поля:**
```json
{
    "id": "CLI-002",
    "epicId": "EPIC-MVP",
    "title": "Краткое описание (что делаем)",
    "status": "plan",
    "priority": "P1",
    "created_by": "Cursor",
    "modified_by": "Cursor",
    "updated_at": "2026-01-05T19:50:00-05:00",
    "workspace": "client"
}
```

**После создания:**
- Инкрементировать `next_id` в файле

**Рекомендуемые поля:**
- `description`: Детальное описание проблемы/решения
- `file_path`: Главный файл для работы
- `estimate`: Оценка времени (1h, 4h, 1d)

### 22.4 Обновление статуса

**При изменении задачи ОБЯЗАТЕЛЬНО:**
1. Обновить `status` при переходе
2. Обновить `modified_by`: `"Cursor"`
3. Обновить `updated_at`: текущее время
4. **НЕ менять** `created_by`

**Триггеры смены статуса:**
| Событие | Новый статус |
|:--------|:-------------|
| Начали писать код | `in_progress` |
| Код готов, тестируем | `testing` |
| Тесты прошли, готово | `released` |
| Нашли проблему, откат | `plan` или `in_progress` |

### 22.5 Подзадачи (Subtasks)

Для крупных задач создавайте subtasks:
```json
{
    "id": "CLI-001",
    "subtasks": [
        {"title": "Шаг 1", "status": "released"},
        {"title": "Шаг 2", "status": "in_progress"},
        {"title": "Шаг 3", "status": "plan"}
    ]
}
```

### 22.6 После завершения работы

Уведомить директора (Fix_new) для запуска агрегатора:
```bash
python3 scripts/task_aggregator.py
```

### 22.7 Справка
- Полные правила: `Docs/CRM_CONSOLIDATED_RULES.md`
- Инструкция для ассистентов: `Docs/CRM_ASSISTANT_INSTRUCTIONS.md`
- Prompt директора: `Docs/ANTIGRAVITY_PROMPT.md`
