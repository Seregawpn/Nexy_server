# Nexy Client Development Rules

## 1. Документы перед началом
Перед изменениями обнови контекст по ключевым файлам:
- `Docs/PRODUCT_CONCEPT.md` — пользовательские сценарии и режимы
- `Docs/ARCHITECTURE_OVERVIEW.md` — связь модулей и интеграций
- `Docs/PACKAGING_FINAL_GUIDE.md` и `client/modules/*/MACOS_PACKAGING_GUIDE.md` — пайплайн сборки и подписи
- `Docs/CURRENT_STATUS_REPORT.md` — актуальные истории и фичи
- `Docs/GLOBAL_DELIVERY_PLAN.md` — требования к доставке и Azure VM
- `Docs/GO_TO_MARKET_BETA_PLAN_RU.md` — план выхода на рынок
- `PERMISSIONS_REPORT.md` — актуальные статусы системных разрешений

## 2. Среда и запуск
- macOS 13+, Python 3.11, работа ведётся из `client/`.
- Точка входа: `python client/main.py` (создаёт EventBus и запускает `SimpleModuleCoordinator`).
- ffmpeg для pydub должен лежать в `client/resources/ffmpeg/ffmpeg` или паковаться внутрь `.app`.
- При разработке держи `PYTHONPATH` чистым: `client/main.py` сам добавляет нужные пути.
- Сборка `.app`/PKG описана в `../Docs/PACKAGING_FINAL_GUIDE.md` (PyInstaller + pkgbuild/productbuild).

## 3. Архитектурное устройство
- **Core** (`client/integration/core/`): `EventBus`, `SimpleModuleCoordinator`, `ApplicationStateManager`, `ErrorHandler`.
- **Модули** (`client/modules/`): ответственны за низкоуровневую логику.
  - См. полный список: `client/modules/`
- **Интеграции** (`client/integration/integrations/`): тонкие обёртки над модулями.
  - См. полный список: `client/integration/integrations/`
  - **ОБНОВЛЕНО:** Модуль `permissions` теперь имеет `first_run_permissions_integration.py` для системы первого запуска.
- **Workflows** (`client/integration/workflows/`): `ListeningWorkflow`, `ProcessingWorkflow` управляют переходами между режимами.
- **Режимы** (`AppMode`): SLEEPING → LISTENING → PROCESSING, переходы только через события `mode.request`.
- **EventBus**: все коммуникации — события, приоритеты задаются через `EventPriority`.

## 4. Порядок модулей и инициализации
`SimpleModuleCoordinator` инициализирует интеграции в фиксированной последовательности: InstanceManager → HardwareId → **FirstRunPermissions** → Tray → ModeManagement → InputProcessing → VoiceRecognition → NetworkManager → InterruptManagement → ScreenshotCapture → GrpcClient → SpeechPlayback → Signals → Updater → AutostartManager → WelcomeMessage → VoiceOverDucking. Не меняй порядок без веских причин — это влияет на зависимости и режимы.

**ОБНОВЛЕНО:** FirstRunPermissionsIntegration добавлена на позицию 3 (блокирующая). Permissions модуль теперь имеет полноценную интеграцию для системы первого запуска.

**АКТУАЛЬНЫЕ СПИСКИ:**
- Модули: см. `client/modules/`
- Интеграции: см. `client/integration/integrations/`
- Порядок инициализации: см. `SimpleModuleCoordinator._create_integrations()`

**Политика расширения:** прежде чем изменять структуру или добавлять новую интеграцию, проверь существующие модули и workflows; их допускается расширять конфигом или событиями. Новый модуль/интеграция создаём только если требуемого поведения нет и его нельзя разумно добавить через текущие компоненты. В этом случае документируй причину и зависимостей в `../Docs/CURRENT_STATUS_REPORT.md` и обнови `unified_config.yaml`.

**ЗАЩИТА МОДУЛЕЙ ОТ ИЗМЕНЕНИЙ:**
- **Каждый модуль должен быть изолированным** и иметь четко определенные границы
- **Изменения в модули возможны только в случае критической необходимости** и только через ADR (Architecture Decision Record)
- **Интеграция с модулями ТОЛЬКО через отдельные интеграции** в `client/integration/integrations/`
- **Прямые изменения в модули запрещены** без обоснования в ADR и согласования с владельцем модуля
- **Новая функциональность добавляется через расширение интеграций** или создание новых интеграций
- **Модули должны иметь стабильные интерфейсы** - breaking changes требуют создания новой версии модуля

## 5. Паттерн интеграции
- Наследуй `BaseIntegration` и подключай существующий модуль.
- **ОБЯЗАТЕЛЬНО создай контракт EventBus** (см. раздел 16) перед началом разработки.
- Подписки и публикации только через `event_bus`.
- Обработка ошибок — через `error_handler.handle_error` с указанием контекста.
- Все инициирующие события включают `session_id` (строка uuid4).
- Возвращаемые события именуй `<feature>.<action>` согласно контракту.

## 6. Конфигурация
- Единственный источник правды: `client/config/unified_config.yaml` (загрузка через `UnifiedConfigLoader`).
- Раздел `integrations` управляет включением и приоритетами обёрток; не дублируй настройки в коде.
- Новые параметры добавляй в `unified_config.yaml`, обновляя документацию и пример (если нужен).
- Секреты не коммить: используем Keychain/окружение.

## 7. Взаимодействие с сервером
- gRPC настройки (`grpc.server_host`, `grpc.server_port`, TLS) берутся из unified_config.
- Сообщения/стриминг определены `../server/modules/grpc_service/streaming.proto`; при изменениях сервера обновляй клиентские stubs и проводи совместное тестирование.
- Сетевые ошибки должны транслироваться через события ошибок и обрабатываться дружелюбно (без падения режима).

## 8. Логирование и телеметрия
- **Формат**: `YYYY-MM-DD HH:MM:SS - Nexy - LEVEL - [session_id] - Message` (см. `client/main.py`).
- **Структурированные события**: `module.start|ok|fail` с session_id, duration_ms, контекстом.
- **Ошибки**: через ErrorHandler с кодами (E_INPUT_INVALID, E_STATE_INVAR, E_DEP_TIMEOUT, E_DEP_UNAVAILABLE, E_RATE_LIMITED, E_UNKNOWN).
- **Логируй**: переходы режимов, сетевые события, ошибки устройств, автообновления.
- **Избегай**: PII/секретов (микрофонные данные, токены, URL).
- **Для DIAG**: добавлять config_hash, build_id, git_sha в контекст.

## 9. Разрешения и системные интеграции
- При работе с микрофоном, screen capture или Accessibility выполняй проверки через `permissions` модуль.
- Обновляй `PERMISSIONS_REPORT.md`, если добавляешь новые запросы или меняешь UX.
- В VoiceOver режимах следи за `voiceover_control` и `voiceover_ducking_integration` — они должны уважать системные настройки.

## 10. Тестирование
- Модульные тесты (если есть) держим рядом с модулями (`modules/*/tests` или `integration/tests`).
- Обязательные ручные проверки: push-to-talk, переходы режимов, Tray меню, автообновление Sparkle, VoiceOver ducking.
- Для регрессии глянь сценарии в `../Docs/CURRENT_STATUS_REPORT.md` и адаптируй плейлист.

## 11. Чеклист изменений
**Перед началом**
- Просмотри существующие модули/интеграции, чтобы не дублировать функционал.
- **Создай контракт EventBus** (см. раздел 16) для новой интеграции.
- Проверь unified_config и активность нужных интеграций.
- Определи какие события EventBus потребуются и как они влияют на режимы.

**Во время**
- Соблюдай архитектуру: интеграция → модуль → EventBus, никаких прямых вызовов между модулями.
- Сохраняй порядок инициализации SimpleModuleCoordinator.
- Сначала ищи возможность переиспользовать существующий модуль/интеграцию; если расширяешь, делай это через конфигурацию или дополнительные события.
- Добавляй новые события в явный список и документируй формат payload.
- Не забывай о `session_id`, `source` в событиях и об обработке ошибок.

**Перед мерджем — Impact-гейт**

- [ ] Приложен `change_impact.yaml` (оси условий, инварианты, guards, тест-стратегия, метрики, роллаут)
- [ ] Обновлены `Docs/STATE_CATALOG.md` и/или `client/config/interaction_matrix.yaml` (если задето)
- [ ] Есть минимум 8–14 pairwise тестов по выбранным осям + 2 негативных
- [ ] Логи решений видны локально: `decision=<...> ctx={...} source=<domain>`
- [ ] Фича-флаг + kill-switch прописаны (см. раздел «Роллаут»)

**После**
- Если добавлена новая интеграция/модуль — зафиксируй обоснование в `../Docs/CURRENT_STATUS_REPORT.md`.
- **Проверь контракт EventBus** согласно чек-листу (раздел 16.6).
- Добавь интеграцию в `SimpleModuleCoordinator._create_integrations()` (если новая) и настрой приоритеты.
- Обнови `unified_config.yaml`, документацию и при необходимости паковочные гайты.
- Прогоняй ручные проверки и убедись, что логи чисты от ошибок.
- Если менялись gRPC контракты — синхронизируй изменения с серверной командой.

## 12. Распространённые риски
- Изменение режима без `mode.request` ломает FSM и workflows.
- Дублирование конфигурации приводят к рассинхронизации при сборке.
- Прямые вызовы модулей минуя интеграции нарушают масштабируемость.
- Отсутствие проверок разрешений вызывает краши в production.
- Непрожатые события `session_id` делают сложным трекинг цепочек в логах.

## 13. Напоминание
Клиентская часть должна оставаться совместимой с уже завершёнными интеграциями. При сомнениях синхронизируйся с владельцем сервера и UX прежде чем менять контракт или пользовательский поток.

**ОБНОВЛЕНО:** Создана `first_run_permissions_integration.py` - полноценная система первого запуска с умными паузами и блокирующей логикой. Проверка разрешений также выполняется через специализированные интеграции (VoiceRecognitionIntegration, ScreenshotCaptureIntegration и т.д.).

## 14. Принципы архитектуры "быстрой диагностики"

### 14.1 Модули и границы (адаптировано под Nexy)
- **Модуль = изолированная ответственность** + собственная "экосистема" в `client/modules/`
- **Вход только через интеграции** (`client/integration/integrations/`), выход — через EventBus события
- **Зависимости строго внутрь** (core → types), core не импортирует platform-specific код
- **После принятия модуля в "рабочий" режим изменения — только через ADR + тест-план**
- **Запрет на дублирование**: один capability — один владелец (указан в README модуля)

**Definition of Done (модуль):** README, публичные интерфейсы в types.py, конфигурация, логирование событий, тесты (если есть), диагностические эндпоинты.

### 14.2 Интеграции и контракты (адаптировано под EventBus)
- **У каждой интеграции есть четкий контракт** через EventBus события + payload схемы
- **Совместимость**: несовместимые изменения → новая мажорная версия события, совместимые — минор
- **Интеграция только по "Инструкции модуля"**: входные события валидируются на границе
 - Для доменов `audio`, `permissions`, `mode_management` решения принимаются через FSM-таблицы: `(state, event) --[guard]--> (new_state, action)`.
 - Guard-условия обязаны проверять критичные оси: permissions, device, network, firstRun.
 - Запрещены скрытые записи состояний в чужие домены — только через EventBus.

### 14.3 Конфигурация и состояние (уже реализовано)
- **Единый источник конфигурации** (`unified_config.yaml`) + схемы конфигурации
- **Минимум shared state**; глобальные состояния — только в ApplicationStateManager
- **Конфиг инициализируется один раз на старте** и логируется

### 14.4 Наблюдаемость "по умолчанию" (адаптировано под текущее логирование)
- **Структурированные логи** с session_id для трекинга цепочек
- **Таксономия ошибок** через ErrorHandler с кодами и контекстом
- **Метрики**: error-rate, latency по интеграциям, счетчики событий
- **Диагностический режим**: расширенные логи, health checks через EventBus

### 14.5 Качество кода и стандарты
- **Код-стайл и линтеры** — обязательны
- **Запрет копипаста интерфейсов** (single source of truth — types.py в модулях)
- **Guards/asserts для инвариантов** домена; Result вместо исключений внутри домена

### 14.6 Тест-стратегия (минимум для Nexy)
- **Unit тесты** для core логики модулей (<10мс, без IO)
- **Contract тесты** для интеграций (EventBus события + payload)
- **Интеграционные тесты** — локальный стенд с реальными модулями
- **Smoke тесты** — 5–10 happy-path сценариев перед релизом
- **Ручные проверки** — push-to-talk, переходы режимов, Tray меню

### 14.7 Поставка и изменения
- **ADR (Architecture Decision Record)** для значимых изменений в модули
- **Фича-флаги** через unified_config для постепенного rollout
- **Миграции двунаправленные**; форматы событий — совместимые на время перехода
- **Если SLO пробит — стоп релизы**, приоритет стабильности
 - **ADR-минимум**: один абзац «что/почему/альтернативы/дата» для любого изменения модуля или матрицы взаимодействий

### 14.8 Безопасность и приватность (адаптировано под macOS)
- **Секреты — из Keychain**; в логах маскировка PII
- **Лейблы в событиях без чувствительных данных**
- **Поведенческие лимиты**: rate-limits как часть контракта интеграций

### 14.9 Производительность и бюджет
- **Для ключевых usecase заданы latency-бюджеты** (p95) через EventBus
- **"Тяжёлые" пути** — с профилировкой и отдельными метриками

## 15. Мини-спецификации качества

### 15.1 Требования к логированию (каждый модуль)
- **Формат логов**: `YYYY-MM-DD HH:MM:SS - Nexy - LEVEL - [session_id] - Message`
- **События**: `module.start|ok|fail` с session_id, duration_ms, ключевым контекстом
- **Ошибки**: code, reason, module, retries, timeout_ms через ErrorHandler
- **Лог-уровни**: warn — ожид. аномалии; error — потеря функции. info — бизнес-события
- **Для DIAG**: добавлять config_hash, build_id, git_sha
 
 **Decision-лог (обязательно для FSM/интеграций):**
 `decision=<start|abort|retry|degrade> ctx={mic=...,screen=...,device=...,network=...,firstRun=...,appMode=...} source=<domain> duration_ms=<int>`
 
 Метрики:
 - `decision_rate{type}` — распределение решений
 - `stream_open_success_rate` — доля удачных запусков аудио
 - `tcc_prompt_duration_ms` — длительность последовательности разрешений (p95)
- **Примеры**:
  - `2024-01-15 10:30:45 - Nexy - INFO - [abc123] - voice_recognition.start - duration_ms=150`
  - `2024-01-15 10:30:46 - Nexy - ERROR - [abc123] - E_DEP_TIMEOUT - gRPC connection failed`

### 15.2 Таксономия ошибок (адаптированная под Nexy)
- **Коды ошибок**: E_INPUT_INVALID, E_STATE_INVAR, E_DEP_TIMEOUT, E_DEP_UNAVAILABLE, E_RATE_LIMITED, E_UNKNOWN
- **Категории ErrorHandler**: INITIALIZATION, RUNTIME, CONFIGURATION, NETWORK, PERMISSION, UNKNOWN
- **Политики живут в unified_config** (timeouts/retries), код их читает
- **Маппинг**: коды ошибок → категории ErrorHandler → уровни логирования

### 15.3 Инструкция модуля (README шаблон)
- **Назначение, владельцы**
- **Публичные интерфейсы** (types.py) + ссылки на EventBus события
- **Инварианты и ошибки** (маппинг кодов)
- **Метрики и ключевые логи**
- **Диаг-эндпоинты и self-checks**
- **Примеры сценариев** (fixtures + команда запуска)

### 15.4 Чек-лист "принять модуль"
- **Контракт EventBus создан** согласно разделу 16 (обязательно!)
- **Контракты и схемы** лежат в types.py
- **Валидаторы входа** включены на границе интеграции
- **Логи/метрики/трейсинг** соответствуют стандарту
- **Unit/Contract/Integration/Smoke** — зелёные
- **Diag-режим и health-пробы** работают
- **ADR на рисковые решения** добавлен

## 16. Руководство по созданию контрактов интеграции

### 16.1 Обязательность контрактов
- **Каждая интеграция ДОЛЖНА иметь четкий контракт** через EventBus события
- **Без контракта интеграция не принимается** в production
- **Контракт документируется** в README модуля и в интеграции

### 16.2 Структура контракта EventBus
```python
# Пример контракта для voice_recognition_integration
CONTRACT = {
    "module": "voice_recognition",
    "version": "1.0",
    "events": {
        "input": {
            "voice.recognition.start": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "language": "string (optional, default: en-US)",
                    "timeout_sec": "float (optional, default: 10.0)"
                },
                "required": ["session_id"]
            },
            "voice.recognition.stop": {
                "payload": {
                    "session_id": "string (uuid4)"
                },
                "required": ["session_id"]
            }
        },
        "output": {
            "voice.recognition.result": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "text": "string",
                    "confidence": "float (0.0-1.0)",
                    "language": "string",
                    "duration_ms": "int"
                },
                "required": ["session_id", "text"]
            },
            "voice.recognition.error": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "error_code": "string (E_INPUT_INVALID|E_DEP_TIMEOUT|E_UNKNOWN)",
                    "error_message": "string",
                    "retry_count": "int (optional)"
                },
                "required": ["session_id", "error_code", "error_message"]
            }
        }
    }
}
```

### 16.3 Правила именования событий
- **Формат**: `<module>.<action>` (например: `voice.recognition.start`)
- **Модуль**: название модуля в snake_case
- **Действие**: глагол в present tense (start, stop, result, error, request, response)
- **Версионирование**: мажорные изменения → новое событие `v2` (например: `voice.recognition.start.v2`)

### 16.4 Схемы payload
- **Обязательные поля**: `session_id` для всех событий
- **Типы данных**: string, int, float, bool, dict, list
- **Валидация**: на границе интеграции через pydantic или dataclasses
- **Документация**: каждый payload документируется с примерами

### 16.5 Версионирование контрактов
- **Мажорные изменения** (breaking): новая версия события (`module.action.v2`)
- **Минорные изменения** (совместимые): добавление optional полей
- **Обратная совместимость**: старые события поддерживаются 2 версии
- **Миграция**: через unified_config флаги

### 16.6 Чек-лист контракта
- ✅ **События документированы** с полными payload схемами
- ✅ **Валидация payload** на границе интеграции
- ✅ **Обработка ошибок** через ErrorHandler с кодами
- ✅ **Тесты контракта** (unit + integration)
- ✅ **Примеры использования** в README
- ✅ **Версионирование** для breaking changes
- ✅ **Обратная совместимость** соблюдена

### 16.7 Примеры контрактов
- **signals**: см. `modules/signals/INTEGRATION_GUIDE.md`
- **voice_recognition**: события start/stop/result/error
- **grpc_client**: события request/response/error с session_id
- **mode_management**: события mode.request/mode.changed

### 16.8 Инструменты для контрактов
- **Валидация**: pydantic, dataclasses с type hints
- **Тестирование**: contract tests с фикстурами
- **Документация**: OpenAPI-подобные схемы в README
- **Мониторинг**: метрики по событиям и ошибкам


## 17. Базовые архитектурные принципы

### 17.1 SOLID принципы
- **Single Responsibility**: каждый модуль отвечает за одну задачу
- **Open/Closed**: модули открыты для расширения, закрыты для модификации
- **Liskov Substitution**: интеграции взаимозаменяемы через BaseIntegration
- **Interface Segregation**: четкие интерфейсы в types.py
- **Dependency Inversion**: зависимости через EventBus, не прямые импорты

### 17.2 Dependency Injection
- **Внедрение через конструктор**: EventBus, StateManager, ErrorHandler
- **Инверсия зависимостей**: модули не знают о конкретных реализациях
- **Конфигурация извне**: unified_config.yaml, не хардкод в модулях
- **Тестируемость**: легко подменить зависимости в тестах

### 17.3 Separation of Concerns
- **Модули**: бизнес-логика и низкоуровневые операции
- **Интеграции**: координация и адаптация к EventBus
- **Core**: инфраструктура (EventBus, StateManager, ErrorHandler)
- **Workflows**: управление состояниями приложения

### 17.4 Design Patterns
- **Factory**: создание модулей через SimpleModuleCoordinator
- **Observer**: подписка на события через EventBus
- **Strategy**: разные реализации через интеграции
- **Adapter**: интеграции как адаптеры между модулями и EventBus
- **Singleton**: ApplicationStateManager, ErrorHandler (один экземпляр)

### 17.5 Принципы качества кода
- **DRY (Don't Repeat Yourself)**: переиспользование через интеграции
- **KISS (Keep It Simple)**: простые интерфейсы, сложность в модулях
- **YAGNI (You Aren't Gonna Need It)**: только необходимая функциональность
- **Composition over Inheritance**: предпочтение композиции наследованию

## 18. Каталог состояний и матрица взаимодействий

### 18.1 STATE_CATALOG (Docs/STATE_CATALOG.md)

- Оси/флаги: `permissions.mic|screen|accessibility`, `device.input`, `network`, `firstRun`, `appMode`, ...
- Для каждой оси: допустимые состояния, владелец, кто пишет/читает, источник истины, метрики.
- Ответственный: один владелец документа (по умолчанию: Tech Lead клиента).

### 18.2 INTERACTION_MATRIX (client/config/interaction_matrix.yaml)

- Фиксирует только взаимозависимые оси (без полного перебора).
- Формат правила:
  - `when: {Permission.mic: denied, appMode: listen} -> decision: abort_listen`
  - `priority: hard_stop | graceful | preference`
- Любое изменение >2 осей должно обновлять эту матрицу.
- Правила приоритетов условий:
  1. `hard_stop`: безопасность/разрешения/инварианты — всегда прерывают действие;
  2. `graceful`: деградация (сеть/квоты) — урезаем функционал, но живём;
  3. `preference`: UX-предпочтения — только если не конфликтуют с 1–2.

## 19. Политика роллаута изменяющих взаимодействия

- Любое изменение, затрагивающее >2 осей, включается через фича-флаг.
- Этапы: 1% → 25% → 100% (config-driven), с возможностью shadow-mode (считаем решение, но не применяем).
- Kill-switch: `NEXY_KS_<FEATURE>` в окружении/конфиге, выключает поведение немедленно без релиза.
- В `change_impact.yaml` обязательно указать: флаг, план раскатки, условие отката.

## 20. SLO и стоп-релизы (beta)

- `p95 start_listening ≤ 600ms`
- `stream_open_success_rate ≥ 98%`
- `permission_flow_success ≥ 99%` (микрофон+экран на first-run)
- Если SLO пробит на beta-канале — стоп всех функциональных релизов до восстановления.
