# Nexy Client Development Rules

## 1. Документы перед началом
Перед изменениями обнови контекст по ключевым файлам:
- `Docs/PRODUCT_CONCEPT.md` — пользовательские сценарии и режимы
- `Docs/ARCHITECTURE_OVERVIEW.md` — связь модулей и интеграций
- `Docs/PACKAGING_FINAL_GUIDE.md` и `client/modules/*/MACOS_PACKAGING_GUIDE.md` — пайплайн сборки и подписи
- `Docs/CURRENT_STATUS_REPORT.md` — актуальные истории и фичи
- `Docs/GLOBAL_DELIVERY_PLAN.md` — требования к доставке и Azure VM
- `Docs/GO_TO_MARKET_BETA_PLAN_RU.md` — план выхода на рынок
- `PERMISSIONS_REPORT.md` — актуальные статусы системных разрешений

### 1.1 Источник истины для TCC/First-Run/Restart

**ВАЖНО**: Единый источник истины для осей состояния и правил взаимодействия:

**Что делаем** (поведение и правила):
- `Docs/STATE_CATALOG.md` — единый источник истины для всех осей состояния (permissions.mic, device.input, network, firstRun, appMode)
  - **Таблица ownership**: см. раздел "Таблица ownership" в STATE_CATALOG.md (владельцы осей и артефактов)
- `config/interaction_matrix.yaml` — правила взаимодействия осей и приоритеты решений (hard_stop, graceful, preference)

**Как делаем** (реализация):
- `Docs/PERMISSION_RESTART_KEY_POINTS.md` — ключевые моменты и нюансы автоматического перезапуска
- `Docs/PERMISSION_RESTART_BLOCKERS.md` — все условия блокировки и отсрочки перезапуска
- `Docs/TEST_PLAN_PERMISSION_RESTART.md` — канонический чек-лист для тестирования TCC/перезапуска
- `integration/core/gateways.py` — логика принятия решений на основе осей состояния

**Machine-enforced правила**:
- Запрет прямого доступа к состоянию: `pyproject.toml` настроен на проверку паттернов (см. раздел 21.3)
- Валидация схем: `client/config/schemas/` + `tests/test_schemas.py` (см. раздел 9.1)

**Синхронизация**: Любое изменение оси или правила → обновить STATE_CATALOG.md → interaction_matrix.yaml → gateways.py → тесты (см. раздел 11 "Чеклист изменений").

## 2. Среда и запуск
- macOS 13+, Python 3.11, работа ведётся из `client/`.
- Точка входа: `python client/main.py` (создаёт EventBus и запускает `SimpleModuleCoordinator`).
- ffmpeg для pydub должен лежать в `client/resources/ffmpeg/ffmpeg` или паковаться внутрь `.app`.
- При разработке держи `PYTHONPATH` чистым: `client/main.py` сам добавляет нужные пути.
- **Сборка `.app`/PKG**: единственная инструкция по упаковке — `Docs/PACKAGING_FINAL_GUIDE.md` (PyInstaller + pkgbuild/productbuild + нотарификация). **Не используй другие источники** — это исключает дубли и рассинхронизацию.

## 3. Архитектурное устройство
- **Core** (`client/integration/core/`): `EventBus`, `SimpleModuleCoordinator`, `ApplicationStateManager`, `ErrorHandler`.
- **Модули** (`client/modules/`): ответственны за низкоуровневую логику.
  - См. полный список: `client/modules/`
- **Интеграции** (`client/integration/integrations/`): тонкие обёртки над модулями.
  - См. полный список: `client/integration/integrations/`
  - **ОБНОВЛЕНО:** Модуль `permissions` теперь имеет `first_run_permissions_integration.py` для системы первого запуска.
- **Workflows** (`client/integration/workflows/`): `ListeningWorkflow`, `ProcessingWorkflow` управляют переходами между режимами.
- **Режимы** (`AppMode`): SLEEPING → LISTENING → PROCESSING, переходы только через события `mode.request`.
- **EventBus**: все коммуникации — события, приоритеты задаются через `EventPriority`.

## 4. Порядок модулей и инициализации
`SimpleModuleCoordinator` инициализирует интеграции в фиксированной последовательности: InstanceManager → HardwareId → **FirstRunPermissions** → Tray → ModeManagement → InputProcessing → VoiceRecognition → NetworkManager → InterruptManagement → ScreenshotCapture → GrpcClient → SpeechPlayback → Signals → Updater → AutostartManager → WelcomeMessage → VoiceOverDucking. Не меняй порядок без веских причин — это влияет на зависимости и режимы.

**ОБНОВЛЕНО:** FirstRunPermissionsIntegration добавлена на позицию 3 (блокирующая). Permissions модуль теперь имеет полноценную интеграцию для системы первого запуска.

**АКТУАЛЬНЫЕ СПИСКИ:**
- Модули: см. `client/modules/`
- Интеграции: см. `client/integration/integrations/`
- Порядок инициализации: см. `SimpleModuleCoordinator._create_integrations()`

**Политика расширения:** прежде чем изменять структуру или добавлять новую интеграцию, проверь существующие модули и workflows; их допускается расширять конфигом или событиями. Новый модуль/интеграция создаём только если требуемого поведения нет и его нельзя разумно добавить через текущие компоненты. В этом случае документируй причину и зависимостей в `../Docs/CURRENT_STATUS_REPORT.md` и обнови `unified_config.yaml`.

**ЗАЩИТА МОДУЛЕЙ ОТ ИЗМЕНЕНИЙ:**
- **Каждый модуль должен быть изолированным** и иметь четко определенные границы
- **Изменения в модули возможны только в случае критической необходимости** и только через ADR (Architecture Decision Record)
- **Интеграция с модулями ТОЛЬКО через отдельные интеграции** в `client/integration/integrations/`
- **Прямые изменения в модули запрещены** без обоснования в ADR и согласования с владельцем модуля
- **Новая функциональность добавляется через расширение интеграций** или создание новых интеграций
- **Модули должны иметь стабильные интерфейсы** - breaking changes требуют создания новой версии модуля

## 5. Паттерн интеграции
- Наследуй `BaseIntegration` и подключай существующий модуль.
- **ОБЯЗАТЕЛЬНО создай контракт EventBus** (см. раздел 16) перед началом разработки.
- Подписки и публикации только через `event_bus`.
- Обработка ошибок — через `error_handler.handle_error` с указанием контекста.
- Все инициирующие события включают `session_id` (строка uuid4).
- Возвращаемые события именуй `<feature>.<action>` согласно контракту.

## 6. Конфигурация
- Единственный источник правды: `config/unified_config.yaml` (загрузка через `UnifiedConfigLoader`).
- Раздел `integrations` управляет включением и приоритетами обёрток; не дублируй настройки в коде.
- Новые параметры добавляй в `unified_config.yaml`, обновляя документацию и пример (если нужен).
- Секреты не коммить: используем Keychain/окружение.

## 7. Взаимодействие с сервером
- gRPC настройки (`grpc.server_host`, `grpc.server_port`, TLS) берутся из unified_config.
- Сообщения/стриминг определены `../server/modules/grpc_service/streaming.proto`; при изменениях сервера обновляй клиентские stubs и проводи совместное тестирование.
- Сетевые ошибки должны транслироваться через события ошибок и обрабатываться дружелюбно (без падения режима).

## 8. Логирование и телеметрия
- **Формат**: `YYYY-MM-DD HH:MM:SS - Nexy - LEVEL - [session_id] - Message` (см. `client/main.py`).
- **Структурированные события**: `module.start|ok|fail` с session_id, duration_ms, контекстом.
- **Ошибки**: через ErrorHandler с кодами (E_INPUT_INVALID, E_STATE_INVAR, E_DEP_TIMEOUT, E_DEP_UNAVAILABLE, E_RATE_LIMITED, E_UNKNOWN).
- **Логируй**: переходы режимов, сетевые события, ошибки устройств, автообновления.
- **Избегай**: PII/секретов (микрофонные данные, токены, URL).
- **Для DIAG**: добавлять config_hash, build_id, git_sha в контекст.

**Decision-лог (канонический формат, обязателен для всех gateways):**
`decision=<start|abort|retry|degrade> ctx={mic=...,screen=...,device=...,network=...,firstRun=...,appMode=...} source=<domain> duration_ms=<int>`

**ОБЯЗАТЕЛЬНОСТЬ**: Этот формат **ОБЯЗАТЕЛЕН** для всех FSM/интеграций/gateways, принимающих решения на основе множественных осей состояния. Проверяется при ревью и релизе (см. раздел 11 "Impact-гейт" и раздел 15.1 для примеров).

**Метрики (обязательные для decision-логов):**
- `decision_rate{type}` — распределение решений (start/abort/retry/degrade) по типам
- `tcc_prompt_duration_ms` — длительность последовательности разрешений (p95, цель: ≤ 5 сек)
- `permission_flow_success` — процент успешных завершений потока разрешений (цель: ≥ 99%)
- `permission_restart_success_rate` — процент успешных автоматических перезапусков (цель: ≥ 98%)
- `permission_restart_latency_ms` — задержка перезапуска (p95, цель: ≤ 15 сек)

**Gate-проверка**: Тесты gateways **ОБЯЗАНЫ** проверять наличие decision-логов в каноническом формате (1 позитив + 1 негатив минимум). См. `tests/test_gateways.py` для примеров.

## 9. Разрешения и системные интеграции
- При работе с микрофоном, screen capture или Accessibility выполняй проверки через `permissions` модуль.
- Обновляй `PERMISSIONS_REPORT.md`, если добавляешь новые запросы или меняешь UX.
- В VoiceOver режимах следи за `voiceover_control` и `voiceover_ducking_integration` — они должны уважать системные настройки.

### 9.1 Permission Monitoring Config (источник истины)

**ВАЖНО**: Все тайминги и ограничения мониторинга разрешений — единственный источник истины:

**Первичные значения** (в `config/unified_config.yaml`):
```yaml
permission_restart:
  restart_delay_sec: 5.0              # Задержка перед перезапуском (показать уведомление)
  poll_interval_sec: 3.0              # Интервал polling мониторинга разрешений (если polling_enabled: true)
  max_restart_attempts: 3             # Максимум попыток перезапуска
  # MAX_WAIT_SECONDS: 600.0          # Максимальное ожидание безопасных условий (hardcoded в restart_scheduler.py)

first_run_permissions:
  pause_between_requests_sec: 1.0    # Пауза между запросами разрешений
  activation_hold_duration_sec: 7.0  # Пауза между диалогами для комфортного UX
```

**Ссылки в других местах**: В документации (README, KEY_POINTS, BLOCKERS) указывай только ссылку на `unified_config.yaml`, не дублируй значения.

**Использование в коде**: Все интеграции читают значения из `unified_config.yaml` через соответствующие config-менеджеры. Hardcoded значения допускаются только для констант (например, `MAX_WAIT_SECONDS = 600.0` в `restart_scheduler.py`), но должны быть документированы с указанием причины.

## 10. Тестирование
- Модульные тесты (если есть) держим рядом с модулями (`modules/*/tests` или `integration/tests`).
- Обязательные ручные проверки: push-to-talk, переходы режимов, Tray меню, автообновление Sparkle, VoiceOver ducking.
- Для регрессии глянь сценарии в `../Docs/CURRENT_STATUS_REPORT.md` и адаптируй плейлист.

## 11. Чеклист изменений
**Перед началом**
- Просмотри существующие модули/интеграции, чтобы не дублировать функционал.
- **Создай контракт EventBus** (см. раздел 16) для новой интеграции.
- Проверь unified_config и активность нужных интеграций.
- Определи какие события EventBus потребуются и как они влияют на режимы.
- **Проверь источник истины**: см. раздел 1.1 для STATE_CATALOG.md и interaction_matrix.yaml.

**Во время**
- Соблюдай архитектуру: интеграция → модуль → EventBus, никаких прямых вызовов между модулями.
- Сохраняй порядок инициализации SimpleModuleCoordinator.
- Сначала ищи возможность переиспользовать существующий модуль/интеграцию; если расширяешь, делай это через конфигурацию или дополнительные события.
- Добавляй новые события в явный список и документируй формат payload.
- Не забывай о `session_id`, `source` в событиях и об обработке ошибок.

**Инвариант: изменил поведение? обнови 4 артефакта**

Если изменение затрагивает оси состояния или правила взаимодействия, **ОБЯЗАТЕЛЬНО** обновить:
1. ✅ `Docs/STATE_CATALOG.md` — добавить/изменить ось, обновить владельцев/читателей
2. ✅ `config/interaction_matrix.yaml` — добавить/изменить правило взаимодействия
3. ✅ `integration/core/gateways.py` — реализовать логику в соответствующем gateway
4. ✅ Тесты gateways — добавить/обновить тесты (≥8–14 pairwise + 2 негативных) с проверкой decision-логов

**Проверка синхронизации** (перед мерджем):
- [ ] Все оси из STATE_CATALOG.md присутствуют в interaction_matrix.yaml (если влияют на решения)
- [ ] Все правила из interaction_matrix.yaml реализованы в gateways.py
- [ ] Все gateways покрыты тестами с проверкой decision-логов в каноническом формате

**Перед мерджем — SIMPLE-гейт**

- [ ] Решение доступно в v0: ≤60 LOC, ≤1 файл, без новых фича-флагов/зависимостей/демонов
- [ ] Использованы только существующие selectors/gateways и события EventBus
- [ ] Добавлены 1 happy + 1 негативный тест на gateway

Если нарушено — приложить микро-ADR (7 строк: причина → почему v0 не хватило → откат).

**Перед мерджем — Impact-гейт**

- [ ] Приложен `change_impact.yaml` (оси условий, инварианты, guards, тест-стратегия, метрики, роллаут)
- [ ] Обновлены `Docs/STATE_CATALOG.md` и/или `config/interaction_matrix.yaml` (если задето)
- [ ] `STATE_CATALOG.md` обновлён (оси/владельцы/читатели) под текущее изменение
- [ ] Есть минимум 8–14 pairwise тестов по выбранным осям + 2 негативных
- [ ] Логи решений видны локально: `decision=<...> ctx={...} source=<domain>` (см. раздел 8.x для канонического формата)
- [ ] Фича-флаг + kill-switch прописаны (см. раздел 19 «Роллаут»)
- [ ] Выполнены тест-планы из `required_test_plans` в `change_impact.yaml`, отчёт приложен (логи/события/метрики)

**После**
- Если добавлена новая интеграция/модуль — зафиксируй обоснование в `../Docs/CURRENT_STATUS_REPORT.md`.
- **Проверь контракт EventBus** согласно чек-листу (раздел 16.6).
- Добавь интеграцию в `SimpleModuleCoordinator._create_integrations()` (если новая) и настрой приоритеты.
- Обнови `unified_config.yaml`, документацию и при необходимости паковочные гайты.
- Прогоняй ручные проверки и убедись, что логи чисты от ошибок.
- Если менялись gRPC контракты — синхронизируй изменения с серверной командой.

## 12. Распространённые риски
- Изменение режима без `mode.request` ломает FSM и workflows.
- Дублирование конфигурации приводят к рассинхронизации при сборке.
- Прямые вызовы модулей минуя интеграции нарушают масштабируемость.
- Отсутствие проверок разрешений вызывает краши в production.
- Непрожатые события `session_id` делают сложным трекинг цепочек в логах.

## 13. Напоминание
Клиентская часть должна оставаться совместимой с уже завершёнными интеграциями. При сомнениях синхронизируйся с владельцем сервера и UX прежде чем менять контракт или пользовательский поток.

**ОБНОВЛЕНО:** Создана `first_run_permissions_integration.py` - полноценная система первого запуска с умными паузами и блокирующей логикой. Проверка разрешений также выполняется через специализированные интеграции (VoiceRecognitionIntegration, ScreenshotCaptureIntegration и т.д.).

## 14. Принципы архитектуры "быстрой диагностики"

### 14.1 Модули и границы (адаптировано под Nexy)
- **Модуль = изолированная ответственность** + собственная "экосистема" в `client/modules/`
- **Вход только через интеграции** (`client/integration/integrations/`), выход — через EventBus события
- **Зависимости строго внутрь** (core → types), core не импортирует platform-specific код
- **После принятия модуля в "рабочий" режим изменения — только через ADR + тест-план**
- **Запрет на дублирование**: один capability — один владелец (указан в README модуля)

**Definition of Done (модуль):** README, публичные интерфейсы в types.py, конфигурация, логирование событий, тесты (если есть), диагностические эндпоинты.

### 14.2 Интеграции и контракты (адаптировано под EventBus)
- **У каждой интеграции есть четкий контракт** через EventBus события + payload схемы
- **Совместимость**: несовместимые изменения → новая мажорная версия события, совместимые — минор
- **Интеграция только по "Инструкции модуля"**: входные события валидируются на границе

**FSM-домены с guard-условиями (нормирование):**
Для доменов `audio`, `permissions`, `mode_management`, `first_run`, `permission_restart` решения принимаются **ТОЛЬКО через FSM-таблицы и gateways**:
- `(state, event) --[guard]--> (new_state, action)`
- Guard-условия обязаны проверять критичные оси: permissions, device, network, firstRun
- Все проверки состояния через selectors, все решения через gateways (см. раздел 21)
- Запрещены скрытые записи состояний в чужие домены — только через EventBus

**Нормирование FirstRunPermissions/PermissionRestart:**
- FirstRunPermissions: решения через gateways (`decide_start_listening` с проверкой `first_run`)
- PermissionRestart: решения через gateways (см. `modules/permission_restart/core/restart_scheduler.py`)
- Поведение фиксируется в `interaction_matrix.yaml` с приоритетами (hard_stop/graceful)
- Все блокировки и отсрочки описаны в `Docs/PERMISSION_RESTART_BLOCKERS.md` и отражены в `interaction_matrix.yaml`

### 14.3 Конфигурация и состояние (уже реализовано)
- **Единый источник конфигурации** (`unified_config.yaml`) + схемы конфигурации
- **Минимум shared state**; глобальные состояния — только в ApplicationStateManager
- **Конфиг инициализируется один раз на старте** и логируется

### 14.4 Наблюдаемость "по умолчанию" (адаптировано под текущее логирование)
- **Структурированные логи** с session_id для трекинга цепочек
- **Таксономия ошибок** через ErrorHandler с кодами и контекстом
- **Метрики**: error-rate, latency по интеграциям, счетчики событий
- **Диагностический режим**: расширенные логи, health checks через EventBus

### 14.5 Качество кода и стандарты
- **Код-стайл и линтеры** — обязательны
- **Запрет копипаста интерфейсов** (single source of truth — types.py в модулях)
- **Guards/asserts для инвариантов** домена; Result вместо исключений внутри домена

### 14.6 Тест-стратегия (минимум для Nexy)
- **Unit тесты** для core логики модулей (<10мс, без IO)
- **Contract тесты** для интеграций (EventBus события + payload)
- **Интеграционные тесты** — локальный стенд с реальными модулями
- **Smoke тесты** — 5–10 happy-path сценариев перед релизом
- **Ручные проверки** — push-to-talk, переходы режимов, Tray меню

### 14.7 Поставка и изменения
- **ADR (Architecture Decision Record)** для значимых изменений в модули
- **Фича-флаги** через unified_config для постепенного rollout
- **Миграции двунаправленные**; форматы событий — совместимые на время перехода
- **Если SLO пробит — стоп релизы**, приоритет стабильности
 - **ADR-минимум**: один абзац «что/почему/альтернативы/дата» для любого изменения модуля или матрицы взаимодействий

### 14.8 Безопасность и приватность (адаптировано под macOS)
- **Секреты — из Keychain**; в логах маскировка PII
- **Лейблы в событиях без чувствительных данных**
- **Поведенческие лимиты**: rate-limits как часть контракта интеграций

### 14.9 Производительность и бюджет
- **Для ключевых usecase заданы latency-бюджеты** (p95) через EventBus
- **"Тяжёлые" пути** — с профилировкой и отдельными метриками

## 15. Мини-спецификации качества

### 15.1 Требования к логированию (каждый модуль)
- **Формат логов**: `YYYY-MM-DD HH:MM:SS - Nexy - LEVEL - [session_id] - Message`
- **События**: `module.start|ok|fail` с session_id, duration_ms, ключевым контекстом
- **Ошибки**: code, reason, module, retries, timeout_ms через ErrorHandler
- **Лог-уровни**: warn — ожид. аномалии; error — потеря функции. info — бизнес-события
- **Для DIAG**: добавлять config_hash, build_id, git_sha

**Decision-лог**: см. раздел 8.x для канонического формата. Используется для FSM/интеграций, принимающих решения на основе множественных осей состояния.

**Метрики**:
- `decision_rate{type}` — распределение решений
- `stream_open_success_rate` — доля удачных запусков аудио
- `tcc_prompt_duration_ms` — длительность последовательности разрешений (p95)

**Примеры**:
- `2024-01-15 10:30:45 - Nexy - INFO - [abc123] - voice_recognition.start - duration_ms=150`
- `2024-01-15 10:30:46 - Nexy - ERROR - [abc123] - E_DEP_TIMEOUT - gRPC connection failed`

### 15.2 Таксономия ошибок (адаптированная под Nexy)
- **Коды ошибок**: E_INPUT_INVALID, E_STATE_INVAR, E_DEP_TIMEOUT, E_DEP_UNAVAILABLE, E_RATE_LIMITED, E_UNKNOWN
- **Категории ErrorHandler**: INITIALIZATION, RUNTIME, CONFIGURATION, NETWORK, PERMISSION, UNKNOWN
- **Политики живут в unified_config** (timeouts/retries), код их читает
- **Маппинг**: коды ошибок → категории ErrorHandler → уровни логирования

### 15.3 Инструкция модуля (README шаблон)
- **Назначение, владельцы**
- **Публичные интерфейсы** (types.py) + ссылки на EventBus события
- **Инварианты и ошибки** (маппинг кодов)
- **Метрики и ключевые логи**
- **Диаг-эндпоинты и self-checks**
- **Примеры сценариев** (fixtures + команда запуска)

### 15.4 Чек-лист "принять модуль"
- **Контракт EventBus создан** согласно разделу 16 (обязательно!)
- **Контракты и схемы** лежат в types.py
- **Валидаторы входа** включены на границе интеграции
- **Логи/метрики/трейсинг** соответствуют стандарту
- **Unit/Contract/Integration/Smoke** — зелёные
- **Diag-режим и health-пробы** работают
- **ADR на рисковые решения** добавлен

## 16. Руководство по созданию контрактов интеграции

### 16.1 Обязательность контрактов
- **Каждая интеграция ДОЛЖНА иметь четкий контракт** через EventBus события
- **Без контракта интеграция не принимается** в production
- **Контракт документируется** в README модуля и в интеграции

### 16.2 Структура контракта EventBus
```python
# Пример контракта для voice_recognition_integration
CONTRACT = {
    "module": "voice_recognition",
    "version": "1.0",
    "events": {
        "input": {
            "voice.recognition.start": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "language": "string (optional, default: en-US)",
                    "timeout_sec": "float (optional, default: 10.0)"
                },
                "required": ["session_id"]
            },
            "voice.recognition.stop": {
                "payload": {
                    "session_id": "string (uuid4)"
                },
                "required": ["session_id"]
            }
        },
        "output": {
            "voice.recognition.result": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "text": "string",
                    "confidence": "float (0.0-1.0)",
                    "language": "string",
                    "duration_ms": "int"
                },
                "required": ["session_id", "text"]
            },
            "voice.recognition.error": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "error_code": "string (E_INPUT_INVALID|E_DEP_TIMEOUT|E_UNKNOWN)",
                    "error_message": "string",
                    "retry_count": "int (optional)"
                },
                "required": ["session_id", "error_code", "error_message"]
            }
        }
    }
}
```

### 16.3 Правила именования событий
- **Формат**: `<module>.<action>` (например: `voice.recognition.start`)
- **Модуль**: название модуля в snake_case
- **Действие**: глагол в present tense (start, stop, result, error, request, response)
- **Версионирование**: мажорные изменения → новое событие `v2` (например: `voice.recognition.start.v2`)

### 16.4 Схемы payload
- **Обязательные поля**: `session_id` для всех событий
- **Типы данных**: string, int, float, bool, dict, list
- **Валидация**: на границе интеграции через pydantic или dataclasses
- **Документация**: каждый payload документируется с примерами

### 16.5 Версионирование контрактов
- **Мажорные изменения** (breaking): новая версия события (`module.action.v2`)
- **Минорные изменения** (совместимые): добавление optional полей
- **Обратная совместимость**: старые события поддерживаются 2 версии
- **Миграция**: через unified_config флаги

### 16.5.1 Migration Playbook (безопасные breaking changes)

**Цель**: Безопасный переход от `module.action.v1` к `module.action.v2` без потери функциональности.

#### Чек-лист миграции событий

**Before (подготовка)**:
1. [ ] Определить breaking changes в payload/семантике события
2. [ ] Создать новую версию события (`module.action.v2`)
3. [ ] Добавить feature flag для новой версии (`NEXY_FEATURE_<MODULE>_V2`)
4. [ ] Обновить контракт EventBus с обеими версиями
5. [ ] Уведомить всех потребителей события о планах миграции

**During (shadow-mode)**:
1. [ ] Обе версии публикуются параллельно (v1 + v2)
2. [ ] Новая версия включена только для тестовых пользователей (1% → 25% → 100%)
3. [ ] Мониторинг метрик: нет регрессий на новой версии
4. [ ] Мониторинг ошибок: нет критических ошибок в v2

**Migration timeline**:
- **Week 1-2**: Shadow-mode (1% пользователей)
- **Week 3-4**: Gradual rollout (25% → 50% → 75%)
- **Week 5**: Full rollout (100%)
- **Week 6**: Deprecation notice для v1 (логирование warning)
- **Week 8+**: Удаление v1 (после 2 версий поддержки)

**After (завершение миграции)**:
1. [ ] Все потребители переведены на v2
2. [ ] Feature flag удалён (v2 по умолчанию)
3. [ ] v1 код удалён из кодовой базы
4. [ ] Контракт обновлён (только v2)
5. [ ] Документация обновлена

#### Пример миграции

```python
# Shadow-mode: обе версии поддерживаются
def publish_event(self, event_name: str, payload: dict):
    # Старая версия (для обратной совместимости)
    self.event_bus.publish(f"{event_name}", payload)
    
    # Новая версия (если feature flag включен)
    if self._config.get("use_v2", False):
        v2_payload = migrate_to_v2(payload)
        self.event_bus.publish(f"{event_name}.v2", v2_payload)
```

#### Правила безопасности

- **НЕ удаляй v1** пока не прошло минимум 2 версии релизов после полного rollout v2
- **НЕ меняй v1** после начала миграции (только deprecation warnings)
- **ВСЕГДА используй feature flags** для контроля rollout
- **ВСЕГДА мониторь метрики** во время миграции
- **ВСЕГДА имей kill-switch** для мгновенного отката

### 16.6 Чек-лист контракта
- ✅ **События документированы** с полными payload схемами
- ✅ **Валидация payload** на границе интеграции
- ✅ **Обработка ошибок** через ErrorHandler с кодами
- ✅ **Тесты контракта** (unit + integration)
- ✅ **Примеры использования** в README
- ✅ **Версионирование** для breaking changes
- ✅ **Обратная совместимость** соблюдена

### 16.7 Примеры контрактов
- **signals**: см. `modules/signals/INTEGRATION_GUIDE.md`
- **voice_recognition**: события start/stop/result/error
- **grpc_client**: события request/response/error с session_id
- **mode_management**: события mode.request/mode.changed

### 16.8 Инструменты для контрактов
- **Валидация**: pydantic, dataclasses с type hints
- **Тестирование**: contract tests с фикстурами
- **Документация**: OpenAPI-подобные схемы в README
- **Мониторинг**: метрики по событиям и ошибкам


## 17. Базовые архитектурные принципы

### 17.1 SOLID принципы
- **Single Responsibility**: каждый модуль отвечает за одну задачу
- **Open/Closed**: модули открыты для расширения, закрыты для модификации
- **Liskov Substitution**: интеграции взаимозаменяемы через BaseIntegration
- **Interface Segregation**: четкие интерфейсы в types.py
- **Dependency Inversion**: зависимости через EventBus, не прямые импорты

### 17.2 Dependency Injection
- **Внедрение через конструктор**: EventBus, StateManager, ErrorHandler
- **Инверсия зависимостей**: модули не знают о конкретных реализациях
- **Конфигурация извне**: unified_config.yaml, не хардкод в модулях
- **Тестируемость**: легко подменить зависимости в тестах

### 17.3 Separation of Concerns
- **Модули**: бизнес-логика и низкоуровневые операции
- **Интеграции**: координация и адаптация к EventBus
- **Core**: инфраструктура (EventBus, StateManager, ErrorHandler)
- **Workflows**: управление состояниями приложения

### 17.4 Design Patterns
- **Factory**: создание модулей через SimpleModuleCoordinator
- **Observer**: подписка на события через EventBus
- **Strategy**: разные реализации через интеграции
- **Adapter**: интеграции как адаптеры между модулями и EventBus
- **Singleton**: ApplicationStateManager, ErrorHandler (один экземпляр)

### 17.5 Принципы качества кода
- **DRY (Don't Repeat Yourself)**: переиспользование через интеграции
- **KISS (Keep It Simple)**: простые интерфейсы, сложность в модулях
- **YAGNI (You Aren't Gonna Need It)**: только необходимая функциональность
- **Composition over Inheritance**: предпочтение композиции наследованию

## 18. Каталог состояний и матрица взаимодействий

### 18.1 STATE_CATALOG (Docs/STATE_CATALOG.md)

- Оси/флаги: `permissions.mic|screen|accessibility`, `device.input`, `network`, `firstRun`, `appMode`, ...
- Для каждой оси: допустимые состояния, владелец, кто пишет/читает, источник истины, метрики.
- Ответственный: один владелец документа (по умолчанию: Tech Lead клиента).

### 18.2 INTERACTION_MATRIX (config/interaction_matrix.yaml)

- Фиксирует только взаимозависимые оси (без полного перебора).
- Формат правила:
  - `when: {Permission.mic: denied, appMode: listen} -> decision: abort_listen`
  - `priority: hard_stop | graceful | preference`
- Любое изменение >2 осей должно обновлять эту матрицу.
- Правила приоритетов условий:
  1. `hard_stop`: безопасность/разрешения/инварианты — всегда прерывают действие;
  2. `graceful`: деградация (сеть/квоты) — урезаем функционал, но живём;
  3. `preference`: UX-предпочтения — только если не конфликтуют с 1–2.

## 19. Политика роллаута изменяющих взаимодействия

- Любое изменение, затрагивающее >2 осей, включается через фича-флаг.
- Этапы: 1% → 25% → 100% (config-driven), с возможностью shadow-mode (считаем решение, но не применяем).
- Kill-switch: `NEXY_KS_<FEATURE>` в окружении/конфиге, выключает поведение немедленно без релиза.
- В `change_impact.yaml` обязательно указать: флаг, план раскатки, условие отката.

## 20. SLO и стоп-релизы (beta)

- `p95 start_listening ≤ 600ms`
- `stream_open_success_rate ≥ 98%`
- `permission_flow_success ≥ 99%` (микрофон+экран на first-run)
- Если SLO пробит на beta-канале — стоп всех функциональных релизов до восстановления.

## 21. Selectors и Gateways (архитектура принятия решений)

### 21.1 Принцип разделения ответственности

**Selectors** (`integration/core/selectors.py`): чистые функции для проверки состояний из `Snapshot`.
- Только чтение: не меняют состояние, не имеют side-effects
- Один источник истины: все проверки состояния через selectors
- Примеры: `mic_ready(s)`, `device_idle(s)`, `network_online(s)`, `is_listening_mode(s)`

**Gateways** (`integration/core/gateways.py`): функции принятия решений на основе `Snapshot` и selectors.
- Бизнес-логика: реализуют правила переходов состояний и обработку ошибок
- Используют selectors: никогда не читают состояние напрямую
- Возвращают `Decision`: START, RETRY, ABORT, DEGRADE
- Примеры: `decide_start_listening(s)`, `decide_process_audio(s)`, `decide_with_backoff(s, retry_count)`

### 21.2 Snapshot — единая точка доступа

```python
@dataclass(frozen=True)
class Snapshot:
    perm_mic: PermissionStatus
    perm_screen: PermissionStatus
    perm_accessibility: PermissionStatus
    device_input: DeviceStatus
    network: NetworkStatus
    first_run: bool
    app_mode: AppMode
```

`Snapshot` — неизменяемый снимок всех осей состояния системы. Создается один раз на момент принятия решения и передается в selectors/gateways.

### 21.3 Запрет прямого доступа к состоянию

**Правило**: все проверки состояния ТОЛЬКО через selectors. Прямой доступ к `state_manager` или конфигурации для проверки осей запрещен.

**Исключения**: только файлы `**/selectors.py`, `**/gateways.py`, `**/gateways/**/*.py` могут читать состояние напрямую.

**Линтер**: `pyproject.toml` настроен на проверку паттернов доступа к состоянию (`perm_mic`, `network_online`, `first_run`, `feature_*`, `ks_*`) и фейлит, если файл не в списке исключений.

### 21.4 Использование в интеграциях

```python
from integration.core.selectors import Snapshot, PermissionStatus, DeviceStatus, NetworkStatus, AppMode
from integration.core.gateways import decide_start_listening, Decision
from integration.core.state_manager import ApplicationStateManager

# Создаем snapshot
snapshot = Snapshot(
    perm_mic=PermissionStatus.GRANTED,
    perm_screen=PermissionStatus.GRANTED,
    perm_accessibility=PermissionStatus.GRANTED,
    device_input=DeviceStatus.DEFAULT_OK,
    network=NetworkStatus.ONLINE,
    first_run=False,
    app_mode=AppMode.SLEEPING
)

# Принимаем решение через gateway
decision = decide_start_listening(snapshot)

if decision == Decision.START:
    # Начать listening
    pass
elif decision == Decision.ABORT:
    # Прервать с ошибкой
    pass
elif decision == Decision.RETRY:
    # Повторить с backoff
    pass
elif decision == Decision.DEGRADE:
    # Деградировать функционал
    pass
```

### 21.5 Логирование решений

Все решения логируются в каноническом формате (см. раздел 8.x):

```
decision=<start|abort|retry|degrade> ctx={mic=...,screen=...,device=...,network=...,firstRun=...,appMode=...} source=<domain> duration_ms=<int>
```

Gateways автоматически логируют решения с контекстом из `Snapshot`.

### 21.6 Тестирование selectors/gateways

- **Unit тесты**: selectors — чистые функции, тестируются изолированно с mock `Snapshot`
- **Unit тесты**: gateways — тестируются с различными комбинациями `Snapshot`
- **Pairwise тесты**: покрытие комбинаций осей согласно `interaction_matrix.yaml`
- **Contract тесты**: проверка соответствия логики gateways правилам из `interaction_matrix.yaml`

### 21.7 Связь с interaction_matrix.yaml

Правила из `interaction_matrix.yaml` реализованы в gateways:
- `priority: hard_stop` → `Decision.ABORT`
- `priority: graceful` → `Decision.RETRY` или `Decision.DEGRADE`
- `priority: preference` → учитывается в последнюю очередь

При изменении `interaction_matrix.yaml` обновляются соответствующие gateways и добавляются тесты.
