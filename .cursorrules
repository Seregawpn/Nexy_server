# Nexy Client Development Rules

## 1. Документы перед началом
Перед изменениями обнови контекст по ключевым файлам:
- `Docs/PROJECT_REQUIREMENTS.md` — единый snapshot требований (обязательно при изменении логики, см. раздел 11.3)
- `Docs/REQUIREMENTS_SOURCE_MAP.md` — карта всех документов требований с их статусом
- `Docs/PRODUCT_CONCEPT.md` — пользовательские сценарии и режимы
- `Docs/ARCHITECTURE_OVERVIEW.md` — связь модулей и интеграций
- `Docs/CURRENT_STATUS_REPORT.md` — актуальные истории, риски и тесты
- `Docs/GLOBAL_DELIVERY_PLAN.md` — фазы поставки, Azure/AppCast (обновлён с ссылками на новый процесс)
- `Docs/PACKAGING_FINAL_GUIDE.md` и `modules/*/MACOS_PACKAGING_GUIDE.md` — пайплайн сборки и подписи (обновлён с ссылками на новый процесс)
- `Docs/PRE_PACKAGING_VERIFICATION.md` + `Docs/PACKAGING_READINESS_CHECKLIST.md` — фактические результаты чек-листов упаковки
- `PERMISSIONS_REPORT.md` + `Docs/first_run_flow_spec.md` — статусы разрешений/TCC и логика first-run

**ВАЖНО:** Любое изменение логики начинается с обновления `Docs/PROJECT_REQUIREMENTS.md` (см. раздел 11.3). Это обязательный процесс регулярного аудита требований.

### 1.1 Источник истины для TCC/First-Run/Restart

**ВАЖНО**: Единый источник истины для осей состояния и правил взаимодействия:

**Что делаем** (поведение и правила):
- `Docs/STATE_CATALOG.md` — единый источник истины для всех осей состояния (permissions.mic, device.input, network, firstRun, appMode)
  - **Таблица ownership**: см. раздел "Таблица ownership" в STATE_CATALOG.md (владельцы осей и артефактов)
- `config/interaction_matrix.yaml` — правила взаимодействия осей и приоритеты решений (hard_stop, graceful, preference)

**Как делаем** (реализация):
- `Docs/first_run_flow_spec.md` — детальная логика запроса разрешений и перезапуска
- `PERMISSIONS_REPORT.md` — актуальные статусы TCC, открытые задачи
- `Docs/TAL_TESTING_CHECKLIST.md` — чек-лист TAL/permission restart с логами и тестами
- `integration/core/gateways.py` — логика принятия решений на основе осей состояния

**Machine-enforced правила**:
- Запрет прямого доступа к состоянию: `pyproject.toml` настроен на проверку паттернов (см. раздел 21.3)
- Валидация схем: `config/schemas/` + `tests/test_schemas.py` (см. раздел 9.1)

**Синхронизация**: Любое изменение оси или правила → обновить STATE_CATALOG.md → interaction_matrix.yaml → gateways.py → тесты (см. раздел 11 "Чеклист изменений").

### 1.1.1 Процедура синхронизации осей (явное правило)

**ОБЯЗАТЕЛЬНАЯ ПРОЦЕДУРА**: Любые правки осей → сначала правим STATE_CATALOG.md, затем interaction_matrix.yaml, затем gateways.py + тесты.

**Порядок действий:**
1. **STATE_CATALOG.md** — добавить/изменить ось, обновить владельцев/читателей, источник истины, метрики
2. **interaction_matrix.yaml** — добавить/изменить правило взаимодействия с приоритетами (hard_stop/graceful/preference)
3. **gateways.py** — реализовать логику в соответствующем gateway (decide_* функции)
4. **Тесты gateways** — добавить/обновить тесты (≥8–14 pairwise + 2 негативных) с проверкой decision-логов

**Owner оси разрешает споры**: При любом разногласии по оси/артефакту — окончательное решение принимает Owner из таблицы ownership в STATE_CATALOG.md (см. раздел "Таблица ownership").

### 1.2 Механизм обмена документами между ассистентами

Если работа требует взаимодействия нескольких ассистентов (Codex, Cursor, Antigravity), используем единый протокол:
- Документируем задачи/анализ/ревью в `Docs/assistant_exchange/` по правилам `Docs/ASSISTANT_COORDINATION_PROTOCOL.md`.
- Каждый ассистент пишет в свой подкаталог, имена фиксированы: `codex`, `cursor`, `antigravity`.
- Для перекрестной проверки создается документ типа `review` с ссылкой на проверяемый файл.
- После каждого выполненного задания создается отчетный документ (новый файл, без перезаписи) по шаблону `Docs/assistant_exchange/TEMPLATE.md`.
- Индивидуальные prompt-файлы ассистентов: `Docs/ANTIGRAVITY_PROMPT.md`, `Docs/CODEX_PROMPT.md`.

## 2. Среда и запуск
- macOS 13+, Python 3.13.7 (для разработки), работа ведётся из корня репозитория (где лежит `main.py`).
- Точка входа: `python main.py` (создаёт EventBus и запускает `SimpleModuleCoordinator`).
- ffmpeg для pydub должен лежать в `resources/ffmpeg/ffmpeg` или паковаться внутрь `.app`.
- При разработке держи `PYTHONPATH` чистым: `main.py` сам добавляет нужные пути.
- **Сборка `.app`/PKG**: единственная инструкция по упаковке — `Docs/PACKAGING_FINAL_GUIDE.md` (PyInstaller + pkgbuild/productbuild + нотарификация). **Не используй другие источники** — это исключает дубли и рассинхронизацию.
- **Примечание о версии Python**: Для разработки используется Python 3.13.7 (см. `.python-version`). Для packaging может требоваться Python 3.13.7 Universal2 (см. `Docs/PACKAGING_FINAL_GUIDE.md`).

**ВАЖНО о структуре путей**:
- Основные директории (без префикса `client/`): `integration/`, `modules/`, `config/`, `Docs/`, `scripts/`, `tests/`
- Специфические файлы в поддиректории `client/`: `client/VERSION_INFO.json`, `client/metrics/registry.md`, `client/config/schemas/` (схемы для валидации)
- Точка входа: `main.py` (в корне, не `client/main.py`)

## 3. Архитектурное устройство
- **Core** (`integration/core/`): `EventBus`, `SimpleModuleCoordinator`, `ApplicationStateManager`, `ErrorHandler`.
- **Модули** (`modules/`): ответственны за низкоуровневую логику.
  - См. полный список: `modules/`
- **Интеграции** (`integration/integrations/`): тонкие обёртки над модулями.
  - См. полный список: `integration/integrations/`
  - **ОБНОВЛЕНО:** Модуль `permissions` теперь имеет `first_run_permissions_integration.py` для системы первого запуска.
- **Workflows** (`integration/workflows/`): `ListeningWorkflow`, `ProcessingWorkflow` управляют переходами между режимами.
- **Режимы** (`AppMode`): SLEEPING → LISTENING → PROCESSING, переходы только через события `mode.request`.
- **EventBus**: все коммуникации — события, приоритеты задаются через `EventPriority`.

## 4. Порядок модулей и инициализации
`SimpleModuleCoordinator` инициализирует интеграции в фиксированной последовательности: InstanceManager → HardwareId → **FirstRunPermissions** → **PermissionRestart** → Tray → ModeManagement → InputProcessing → VoiceRecognition → NetworkManager → InterruptManagement → ScreenshotCapture → GrpcClient → SpeechPlayback → Signals → Updater → AutostartManager → WelcomeMessage → VoiceOverDucking. Не меняй порядок без веских причин — это влияет на зависимости и режимы.

**ОБНОВЛЕНО:** FirstRunPermissionsIntegration добавлена на позицию 3 (блокирующая). PermissionRestartIntegration добавлена на позицию 4 (сразу после FirstRunPermissions, как в README и Global Delivery Plan). Permissions модуль теперь имеет полноценную интеграцию для системы первого запуска.

**АКТУАЛЬНЫЕ СПИСКИ:**
- Модули: см. `modules/`
- Интеграции: см. `integration/integrations/`
- Порядок инициализации: см. `SimpleModuleCoordinator._create_integrations()`

**Политика расширения:** прежде чем изменять структуру или добавлять новую интеграцию, проверь существующие модули и workflows; их допускается расширять конфигом или событиями. Новый модуль/интеграция создаём только если требуемого поведения нет и его нельзя разумно добавить через текущие компоненты. В этом случае документируй причину и зависимостей в `Docs/CURRENT_STATUS_REPORT.md` и обнови `config/unified_config.yaml`.

**ЗАЩИТА МОДУЛЕЙ ОТ ИЗМЕНЕНИЙ:**
- **Каждый модуль должен быть изолированным** и иметь четко определенные границы
- **Изменения в модули возможны только в случае критической необходимости** и только через ADR (Architecture Decision Record)
- **Интеграция с модулями ТОЛЬКО через отдельные интеграции** в `integration/integrations/`
- **Прямые изменения в модули запрещены** без обоснования в ADR и согласования с владельцем модуля
- **Новая функциональность добавляется через расширение интеграций** или создание новых интеграций
- **Модули должны иметь стабильные интерфейсы** - breaking changes требуют создания новой версии модуля

## 5. Паттерн интеграции
- Наследуй `BaseIntegration` и подключай существующий модуль.
- **ОБЯЗАТЕЛЬНО создай контракт EventBus** (см. раздел 16) перед началом разработки.
- Подписки и публикации только через `event_bus`.
- Обработка ошибок — через `error_handler.handle_error` с указанием контекста.
- Все инициирующие события включают `session_id` (строка uuid4).
- Возвращаемые события именуй `<feature>.<action>` согласно контракту.

## 6. Конфигурация
- Единственный источник правды: `config/unified_config.yaml` (загрузка через `UnifiedConfigLoader`).
- Раздел `integrations` управляет включением и приоритетами обёрток; не дублируй настройки в коде.
- Новые параметры добавляй в `config/unified_config.yaml`, обновляя документацию и пример (если нужен).
- Секреты не коммить: используем Keychain/окружение.
- **Путь к флагам и данным**: `~/Library/Application Support/Nexy/` (не `~/.Nexy/`). См. `integration/utils/resource_path.py` для деталей.

### 6.1 Feature Flags и Kill-Switches (обязательный слой управления)

**ОБЯЗАТЕЛЬНО**: Любое поведение, затрагивающее >2 оси состояния, **ОБЯЗАНО** раскатываться через feature flag и иметь мгновенный откат (kill-switch).

**Реестр флагов**: См. `Docs/FEATURE_FLAGS.md` — карта всех feature flags/kill-switches → код.

**Конкретные флаги для first-run/permission-restart:**
- `NEXY_FEATURE_FIRST_RUN_V2` — включить систему первого запуска (v2)
- `NEXY_FEATURE_PERMISSION_RESTART_V2` — включить автоматический перезапуск после разрешений (v2)
- `NEXY_KS_PERMISSION_RESTART_V2` — kill-switch для мгновенного отключения перезапуска (env переменная или unified_config)
- `NEXY_DISABLE_AUTO_RESTART` — env-переключатель для dry-run режима (перезапуск не выполняется)

**Правила использования:**
- Feature flags: постепенный роллаут (1% → 25% → 100%) через `config/unified_config.yaml` или env переменные
- Kill-switches: мгновенный откат без релиза (env переменная или `config/unified_config.yaml`)
- Все флаги должны быть зарегистрированы в `Docs/FEATURE_FLAGS.md` перед мерджем (см. раздел 19 «Роллаут»)

## 7. Взаимодействие с сервером
- gRPC настройки (`grpc.server_host`, `grpc.server_port`, TLS) берутся из unified_config.
- Сообщения/стриминг определены `../server/modules/grpc_service/streaming.proto`; при изменениях сервера обновляй клиентские stubs и проводи совместное тестирование.
- Сетевые ошибки должны транслироваться через события ошибок и обрабатываться дружелюбно (без падения режима).

## 8. Логирование и телеметрия
- **Формат**: `YYYY-MM-DD HH:MM:SS - Nexy - LEVEL - [session_id] - Message` (см. `main.py`).
- **Структурированные события**: `module.start|ok|fail` с session_id, duration_ms, контекстом.
- **Ошибки**: через ErrorHandler с кодами (E_INPUT_INVALID, E_STATE_INVAR, E_DEP_TIMEOUT, E_DEP_UNAVAILABLE, E_RATE_LIMITED, E_UNKNOWN).
- **Логируй**: переходы режимов, сетевые события, ошибки устройств, автообновления.
- **Избегай**: PII/секретов (микрофонные данные, токены, URL).
- **Для DIAG**: добавлять config_hash, build_id, git_sha в контекст.

### 8.1 Shadow-mode и Expected Logs (Definition of Done)

**ОБЯЗАТЕЛЬНО**: Перед мерджем изменений, затрагивающих first-run/permission-restart, **ОБЯЗАНА** быть сверка со «спецификацией логов первого запуска».

**Спецификация логов**: См. `Docs/NEXY_FIRST_RUN_LOG_EXPECTED.md` — точная последовательность логов для правильной работы процесса первого запуска.

**Проверочный чек-лист** (перед мерджем):
- [ ] Логи сверены со спецификацией из `NEXY_FIRST_RUN_LOG_EXPECTED.md`
- [ ] Нет «проигрывания приветствия до рестарта» в старом процессе
- [ ] Нет публикации `permissions.first_run_completed` в старом процессе (только `restart_pending`)
- [ ] Нет логов CoreAudio о записи микрофона до перезапуска
- [ ] В новом процессе есть `Перезапуск после first_run завершён успешно`
- [ ] Приветствие играет **ТОЛЬКО** после перезапуска (в новом процессе)

**Shadow-mode**: Для постепенного роллаута изменений используй shadow-mode (параллельная публикация событий/состояний для наблюдения без применения изменений).

**Decision-лог (канонический формат, обязателен для всех gateways):**
`decision=<start|abort|retry|degrade> ctx={mic=...,screen=...,device=...,network=...,firstRun=...,appMode=...} source=<domain> duration_ms=<int>`

**ОБЯЗАТЕЛЬНОСТЬ**: Этот формат **ОБЯЗАТЕЛЕН** для всех FSM/интеграций/gateways, принимающих решения на основе множественных осей состояния. Проверяется при ревью и релизе (см. раздел 11 "Impact-гейт" и раздел 15.1 для примеров).

**Метрики (обязательные для decision-логов):**
- `decision_rate{type}` — распределение решений (start/abort/retry/degrade) по типам
- `tcc_prompt_duration_ms` — длительность последовательности разрешений (p95, цель: ≤ 5 сек)
- `permission_flow_success` — процент успешных завершений потока разрешений (цель: ≥ 99%)
- `permission_restart_success_rate` — процент успешных автоматических перезапусков (цель: ≥ 98%)
- `permission_restart_latency_ms` — задержка перезапуска (p95, цель: ≤ 15 сек)

**Gate-проверка**: Тесты gateways **ОБЯЗАНЫ** проверять наличие decision-логов в каноническом формате (1 позитив + 1 негатив минимум). См. `tests/test_gateways.py` для примеров.

## 9. Разрешения и системные интеграции
- При работе с микрофоном, screen capture или Accessibility выполняй проверки через `permissions` модуль.
- Обновляй `PERMISSIONS_REPORT.md`, если добавляешь новые запросы или меняешь UX.
- В VoiceOver режимах следи за `voiceover_control` и `voiceover_ducking_integration` — они должны уважать системные настройки.

### 9.1 Permission Monitoring Config (источник истины)

**ВАЖНО**: Все тайминги и ограничения мониторинга разрешений — единственный источник истины:

**Первичные значения** (в `config/unified_config.yaml`):
```yaml
permission_restart:
  restart_delay_sec: 5.0              # Задержка перед перезапуском (показать уведомление)
  poll_interval_sec: 3.0              # Интервал polling мониторинга разрешений (если polling_enabled: true)
  max_restart_attempts: 3             # Максимум попыток перезапуска
  # MAX_WAIT_SECONDS: 600.0          # Максимальное ожидание безопасных условий (hardcoded в restart_scheduler.py)

first_run_permissions:
  pause_between_requests_sec: 1.0    # Пауза между запросами разрешений
  activation_hold_duration_sec: 13.0  # Пауза между диалогами для комфортного UX (13 секунд)
```

**Ссылки в других местах**: В документации (README, KEY_POINTS, BLOCKERS) указывай только ссылку на `config/unified_config.yaml`, не дублируй значения. **Источник истины — `config/unified_config.yaml`** (см. раздел 6).

**Использование в коде**: Все интеграции читают значения из `config/unified_config.yaml` через соответствующие config-менеджеры. Hardcoded значения допускаются только для констант (например, `MAX_WAIT_SECONDS = 600.0` в `modules/permission_restart/core/restart_scheduler.py`), но должны быть документированы с указанием причины.

## 10. Тестирование
- Модульные тесты (если есть) держим рядом с модулями (`modules/*/tests` или `integration/tests`).
- Обязательные ручные проверки: push-to-talk, переходы режимов, Tray меню, автообновление Sparkle, VoiceOver ducking.
- Для регрессии глянь сценарии в `Docs/CURRENT_STATUS_REPORT.md` и адаптируй плейлист.

### 10.1 Ссылка на Shadow-mode и Expected Logs

**ОБЯЗАТЕЛЬНО**: Перед мерджем изменений, затрагивающих first-run/permission-restart, **ОБЯЗАНА** быть сверка со «спецификацией логов первого запуска» (см. раздел 8.1 для полной информации о Shadow-mode и Expected Logs).

**Спецификация логов**: `Docs/NEXY_FIRST_RUN_LOG_EXPECTED.md` — канонический чек-лист для проверки правильности работы процесса первого запуска.

**Проверка логов**: Используй проверочный чек-лист из `NEXY_FIRST_RUN_LOG_EXPECTED.md` для валидации последовательности логов перед мерджем.

### 10.2 Методология отладки и диагностики (обязательный подход)

**КРИТИЧЕСКИ ВАЖНО**: Ассистент **НИКОГДА** не должен догадываться или пытаться решать проблемы за счет тестирования без изоляции.

**ОБЯЗАТЕЛЬНОСТЬ**: Этот раздел **ОБЯЗАТЕЛЕН** для выполнения при работе с любыми ошибками, багами или неясным поведением системы. Без прохождения этапов изоляции и тестирования изменения кода **ЗАПРЕЩЕНЫ**.

**Принцип изоляции и тестирования**:
- **Запрет догадок**: Если есть ошибки или предположения о причине проблемы, **НЕ** пытаться исправить "наугад" или тестировать всю систему целиком. **ЗАПРЕЩЕНО** использовать подход "попробуем так" без проверки гипотезы.
- **Обязательная изоляция**: Перед любым тестированием **ОБЯЗАТЕЛЬНО** изолировать проблемную область:
  - Выделить минимальный воспроизводимый сценарий (MRE - Minimal Reproducible Example)
  - Определить конкретные компоненты/функции, которые могут быть причиной
  - Создать изолированный тест для проверки конкретной гипотезы
- **Пошаговая диагностика**: Тестировать **МЕЛКИЕ ЧАСТИ** системы последовательно, а не всю систему целиком:
  - Начать с самой простой проверки (например, проверка входных данных)
  - Постепенно усложнять тест, добавляя зависимости
  - Каждый шаг должен проверять **ОДНУ** конкретную гипотезу
  - **КРИТИЧЕСКИ ВАЖНО**: Изолировать и тестировать именно мелкие части, а не пытаться протестировать всю систему сразу
- **Документирование процесса**: Фиксировать:
  - Какие гипотезы проверялись
  - Какие тесты были созданы для изоляции проблемы
  - Результаты каждого теста (прошел/не прошел, что показал)
  - Выводы на каждом этапе

**Алгоритм работы с ошибками**:

1. **Сбор информации**:
   - Прочитать логи ошибки полностью (не только последнюю строку)
   - Определить точное место ошибки (файл, функция, строка)
   - Понять контекст: когда возникает, при каких условиях

2. **Формулирование гипотез**:
   - Составить список возможных причин (от наиболее вероятной к наименее)
   - Для каждой гипотезы определить, как её проверить изолированно

3. **Изоляция и тестирование**:
   - Создать минимальный тест для проверки первой гипотезы
   - Запустить тест и зафиксировать результат
   - Если гипотеза не подтвердилась → перейти к следующей
   - Если гипотеза подтвердилась → углубиться в изоляцию (проверить более мелкие части)

4. **Верификация решения**:
   - После исправления создать тест, который воспроизводит исходную проблему
   - Убедиться, что тест проходит после исправления
   - Проверить, что исправление не ломает другие части системы

5. **Обязательное изолированное тестирование после реализации**:
   - **КРИТИЧЕСКИ ВАЖНО**: После каждого исправления или реализации новой функциональности **ОБЯЗАТЕЛЬНО** создать изолированный тест, который проверяет, что реализация полностью работает
   - Тест должен быть изолированным: проверять только исправленную/реализованную функциональность без зависимостей от всей системы
   - Тест должен быть воспроизводимым: запускаться независимо и давать четкий результат (прошел/не прошел)
   - **ЗАПРЕЩЕНО** считать исправление завершенным без изолированного теста, подтверждающего работоспособность
   - Если тест не проходит — вернуться к этапу изоляции и диагностики (пункт 3)

**Примеры правильного подхода**:

```python
# ❌ ПЛОХО: Догадка без изоляции
# "Похоже, проблема в микрофоне. Попробую изменить код инициализации."
def initialize_microphone():
    # Изменения наугад без понимания реальной причины
    pass

# ✅ ХОРОШО: Изоляция и тестирование
# Гипотеза 1: Проблема в проверке разрешений
def test_permission_check_isolation():
    """Изолированный тест: проверяем только логику проверки разрешений"""
    # Минимальный тест без зависимостей
    result = check_microphone_permission()
    assert result == PermissionStatus.GRANTED

# Гипотеза 2: Проблема в инициализации AVF сессии
def test_avf_session_init_isolation():
    """Изолированный тест: проверяем только создание AVF сессии"""
    # Тест с минимальными зависимостями
    session = create_avf_session()
    assert session is not None
    assert session.state == "ready"

# ✅ ХОРОШО: Обязательное изолированное тестирование после исправления
# После исправления проблемы в initialize_microphone() создаем изолированный тест
def test_microphone_initialization_fixed():
    """Изолированный тест: проверяем, что исправление работает"""
    # Тест проверяет ТОЛЬКО исправленную функциональность
    result = initialize_microphone()
    assert result.success == True
    assert result.session is not None
    # Тест запускается независимо и дает четкий результат

# ❌ ПЛОХО: Исправление без изолированного теста
def fix_microphone_issue():
    # Исправление кода
    pass
    # НЕТ изолированного теста - исправление считается незавершенным!
```

**Чек-лист перед исправлением ошибки**:
- [ ] Прочитаны все логи ошибки (не только последняя строка)
- [ ] Определено точное место ошибки (файл, функция, строка)
- [ ] Составлен список гипотез о возможных причинах
- [ ] Для каждой гипотезы создан изолированный тест
- [ ] Каждый тест проверяет только одну конкретную гипотезу
- [ ] Результаты тестов зафиксированы (что прошло, что нет)
- [ ] Определена реальная причина на основе результатов тестов
- [ ] Исправление протестировано изолированно перед интеграцией

**Чек-лист после реализации/исправления (ОБЯЗАТЕЛЕН)**:
- [ ] Создан изолированный тест для проверки исправленной/реализованной функциональности
- [ ] Тест проверяет только исправленную/реализованную часть без зависимостей от всей системы
- [ ] Тест запускается независимо и дает четкий результат (прошел/не прошел)
- [ ] Тест успешно проходит, подтверждая работоспособность реализации
- [ ] Если тест не проходит — возврат к этапу изоляции и диагностики
- [ ] Исправление/реализация считается завершенной **ТОЛЬКО** после успешного прохождения изолированного теста

**Запрещенные практики**:
- ❌ Изменение кода "наугад" без понимания причины
- ❌ Тестирование всей системы целиком без изоляции
- ❌ Исправление нескольких вещей одновременно без проверки каждой отдельно
- ❌ Пропуск этапа изоляции и переход сразу к исправлению
- ❌ Использование "попробуем так" без проверки гипотезы
- ❌ **Считание исправления/реализации завершенной без изолированного теста, подтверждающего работоспособность**
- ❌ Пропуск этапа изолированного тестирования после реализации
- ❌ Завершение работы над исправлением без проверки, что изолированный тест проходит

### 10.2.1 Практическое руководство по реализации изолированных тестов

**ОБЯЗАТЕЛЬНО**: При создании изолированных тестов следовать этому руководству. Без соблюдения принципов изоляции тест считается некорректным.

**Содержание раздела**:
- Принципы правильной изоляции (зависимости, конфигурация, флаги)
- Структура изолированного теста (setup, execution, assertion, teardown)
- Примеры правильной реализации (5 практических примеров)
- Чек-лист создания изолированного теста
- Специализированные тесты для дублирования, конфликтов и race conditions

#### Принципы правильной изоляции

**1. Изоляция от зависимостей**:
- **Моки и стабы**: Использовать моки для внешних зависимостей (EventBus, StateManager, конфигурация, сеть, файловая система)
- **Минимальные зависимости**: Тест должен зависеть только от тестируемой функциональности, не от всей системы
- **Изоляция состояния**: Каждый тест должен работать с изолированным состоянием, не зависеть от других тестов

**2. Учет конфигурации и флагов**:
- **Feature flags**: Тесты должны проверять поведение с включенными/выключенными feature flags (см. раздел 6.1)
- **Kill-switches**: Тесты должны проверять поведение при включенных kill-switches
- **Конфигурация**: Использовать изолированную конфигурацию для теста, не полагаться на глобальную
- **Environment variables**: Учитывать влияние переменных окружения на поведение

**3. Тестирование дублирования**:
- **Проверка существующей функциональности**: Перед созданием новой функции проверить, не существует ли уже аналогичная
- **Изолированный тест на дублирование**: Создать тест, который проверяет отсутствие дублирования функциональности
- **Проверка переиспользования**: Тест должен подтверждать использование существующей функции вместо создания новой

**4. Тестирование конфликтов**:
- **Конфликты имен**: Тест должен проверять отсутствие конфликтов имен переменных/функций/классов
- **Конфликты состояний**: Тест должен проверять, что только один источник истины управляет состоянием
- **Конфликты конфигурации**: Тест должен проверять отсутствие дублирования конфигурации

**5. Тестирование race conditions**:
- **Thread-safety**: Тесты для многопоточного кода должны проверять отсутствие race conditions
- **Блокировки**: Тесты должны проверять правильное использование блокировок
- **Атомарность операций**: Тесты должны проверять атомарность критических операций
- **Async/await паттерны**: Тесты должны проверять правильное отслеживание и отмену async задач

#### Структура изолированного теста

**Обязательные компоненты**:

1. **Setup (подготовка)**:
   - Создание изолированного окружения (моки, стабы)
   - Настройка конфигурации и флагов для теста
   - Подготовка тестовых данных

2. **Execution (выполнение)**:
   - Вызов только тестируемой функциональности
   - Минимальные зависимости от других компонентов

3. **Assertion (проверка)**:
   - Проверка ожидаемого результата
   - Проверка отсутствия побочных эффектов
   - Проверка отсутствия дублирования/конфликтов/race conditions

4. **Teardown (очистка)**:
   - Очистка состояния после теста
   - Восстановление моков и стабов

#### Примеры правильной реализации изолированных тестов

**Пример 1: Изоляция с моками и проверка feature flags**

```python
# ✅ ХОРОШО: Правильная изоляция с учетом флагов и зависимостей
import pytest
from unittest.mock import Mock, patch
from integration.core.state_manager import ApplicationStateManager
from integration.core.event_bus import EventBus

def test_permission_restart_with_feature_flag():
    """Изолированный тест: проверяем поведение permission restart с feature flag"""
    # Setup: изолированное окружение
    mock_event_bus = Mock(spec=EventBus)
    mock_state_manager = Mock(spec=ApplicationStateManager)
    
    # Настройка feature flag для теста
    with patch('config.unified_config.get') as mock_config:
        mock_config.return_value = {
            'NEXY_FEATURE_PERMISSION_RESTART_V2': True,
            'NEXY_KS_PERMISSION_RESTART_V2': False
        }
        
        # Execution: тестируем только логику permission restart
        from modules.permission_restart.core.restart_scheduler import RestartScheduler
        scheduler = RestartScheduler(mock_event_bus, mock_state_manager)
        result = scheduler.should_restart()
        
        # Assertion: проверяем ожидаемое поведение
        assert result == True  # Должен вернуть True при включенном флаге
        mock_event_bus.publish.assert_called_once()  # Проверяем побочные эффекты
        
    # Teardown: автоматически через pytest fixtures
```

**Пример 2: Тестирование отсутствия дублирования**

```python
# ✅ ХОРОШО: Изолированный тест на отсутствие дублирования
def test_no_duplicate_bluetooth_device_check():
    """Изолированный тест: проверяем отсутствие дублирования функции проверки Bluetooth"""
    import inspect
    from modules.audio_system.utils import device_utils
    
    # Проверяем, что существует только одна функция для проверки Bluetooth
    functions = [name for name, obj in inspect.getmembers(device_utils)
                 if inspect.isfunction(obj) and 'bluetooth' in name.lower()]
    
    assert len(functions) == 1, f"Найдено дублирование функций Bluetooth: {functions}"
    assert hasattr(device_utils, 'is_bluetooth_device'), "Функция is_bluetooth_device должна существовать"
    
    # Проверяем, что функция работает корректно
    result = device_utils.is_bluetooth_device("AirPods Pro")
    assert result == True
```

**Пример 3: Тестирование отсутствия конфликтов состояний**

```python
# ✅ ХОРОШО: Изолированный тест на отсутствие конфликтов состояний
def test_single_source_of_truth_for_mic_state():
    """Изолированный тест: проверяем, что только один источник управляет состоянием микрофона"""
    from integration.core.state_manager import ApplicationStateManager
    from unittest.mock import Mock
    
    # Setup: изолированное состояние
    state_manager = ApplicationStateManager(Mock())
    
    # Execution: проверяем, что состояние микрофона управляется только через state_manager
    state_manager.set_mic_permission(PermissionStatus.GRANTED)
    mic_state = state_manager.get_mic_permission()
    
    # Assertion: проверяем единый источник истины
    assert mic_state == PermissionStatus.GRANTED
    # Проверяем, что нет других мест, управляющих этим состоянием
    # (это проверяется статическим анализом через pyproject.toml)
```

**Пример 4: Тестирование race conditions**

```python
# ✅ ХОРОШО: Изолированный тест на отсутствие race conditions
import threading
import pytest

def test_thread_safe_audio_chunks():
    """Изолированный тест: проверяем thread-safety операций с audio chunks"""
    from modules.voice_recognition.core.recognizer import AudioChunksManager
    
    # Setup: изолированный менеджер с блокировкой
    manager = AudioChunksManager()
    results = []
    
    def append_chunk(chunk_id):
        """Функция для добавления chunk из одного потока"""
        manager.append_chunk(f"chunk_{chunk_id}")
        results.append(chunk_id)
    
    # Execution: запускаем несколько потоков одновременно
    threads = []
    for i in range(10):
        thread = threading.Thread(target=append_chunk, args=(i,))
        threads.append(thread)
        thread.start()
    
    # Ждем завершения всех потоков
    for thread in threads:
        thread.join()
    
    # Assertion: проверяем отсутствие race conditions
    assert len(manager.get_chunks()) == 10, "Все chunks должны быть добавлены"
    assert len(set(results)) == 10, "Не должно быть дублирования из-за race condition"
    assert manager.get_chunks() == [f"chunk_{i}" for i in range(10)], "Порядок должен быть сохранен"
```

**Пример 5: Тестирование async/await паттернов**

```python
# ✅ ХОРОШО: Изолированный тест на правильное отслеживание async задач
import pytest
import asyncio

@pytest.mark.asyncio
async def test_async_task_tracking():
    """Изолированный тест: проверяем правильное отслеживание и отмену async задач"""
    from modules.voice_recognition.core.async_manager import AsyncTaskManager
    
    # Setup: изолированный менеджер задач
    manager = AsyncTaskManager()
    
    async def dummy_task():
        await asyncio.sleep(1)
        return "completed"
    
    # Execution: создаем задачу и проверяем отслеживание
    task1 = await manager.create_task(dummy_task())
    assert manager.has_active_task() == True, "Задача должна отслеживаться"
    
    # Создаем вторую задачу - первая должна быть отменена
    task2 = await manager.create_task(dummy_task())
    assert task1.cancelled() == True, "Предыдущая задача должна быть отменена"
    assert manager.has_active_task() == True, "Новая задача должна отслеживаться"
    
    # Assertion: проверяем правильность работы
    result = await task2
    assert result == "completed"
    assert manager.has_active_task() == False, "После завершения задача не должна отслеживаться"
```

#### Чек-лист создания изолированного теста

**Перед написанием теста**:
- [ ] Определена тестируемая функциональность (одна конкретная функция/метод/класс)
- [ ] Определены все зависимости тестируемой функциональности
- [ ] Определены feature flags и kill-switches, влияющие на поведение
- [ ] Определена конфигурация, необходимая для теста
- [ ] Определены проверки на дублирование/конфликты/race conditions (если применимо)

**При написании теста**:
- [ ] Использованы моки/стабы для всех внешних зависимостей
- [ ] Настроена изолированная конфигурация для теста
- [ ] Учтены feature flags и kill-switches в тесте
- [ ] Тест проверяет только одну конкретную функциональность
- [ ] Тест не зависит от других тестов (изолированное состояние)
- [ ] Добавлены проверки на дублирование/конфликты/race conditions (если применимо)

**После написания теста**:
- [ ] Тест запускается независимо и дает четкий результат
- [ ] Тест проходит успешно, подтверждая работоспособность
- [ ] Тест не имеет побочных эффектов (не влияет на другие тесты)
- [ ] Тест документирован (docstring с описанием проверяемой функциональности)

#### Специализированные тесты для дублирования, конфликтов и race conditions

**Тесты на дублирование**:
- Проверка существования функции/класса перед созданием новой
- Проверка отсутствия дублирования логики в разных местах
- Проверка использования централизованных утилит вместо локальных реализаций

**Тесты на конфликты**:
- Проверка единого источника истины для состояния
- Проверка отсутствия конфликтов имен
- Проверка отсутствия дублирования конфигурации

**Тесты на race conditions**:
- Проверка thread-safety операций с общими данными
- Проверка правильного использования блокировок
- Проверка атомарности критических операций
- Проверка правильного отслеживания и отмены async задач

**Связанные документы**:
- `Docs/DETECTION_GUIDE_DUPLICATES_CONFLICTS_RACES.md` — инструкция по выявлению проблем
- `Docs/CODE_CHANGE_VALIDATION_RULES.md` — правила валидации изменений кода

## 11. Чеклист изменений

**ОБЯЗАТЕЛЬНЫЙ ПРОЦЕСС ПЛАНИРОВАНИЯ**: Перед любыми изменениями кода ассистент **ОБЯЗАН** пройти через `Docs/PRE_CHANGE_PLANNING_CHECKLIST.md` и заполнить все этапы 1-6. Без заполненного чек-листа изменения не начинаются.

**Перед началом**
- ✅ **Пройден PRE_CHANGE_PLANNING_CHECKLIST.md**: Все этапы 1-6 выполнены
- ✅ **Создана Impact Map**: Заполнена таблица влияния (см. раздел 11.1)
- ✅ **Создан change_impact.yaml**: Файл `.impact/change_impact.yaml` заполнен
- Просмотри существующие модули/интеграции, чтобы не дублировать функционал.
- **Создай контракт EventBus** (см. раздел 16) для новой интеграции.
- Проверь unified_config и активность нужных интеграций.
- Определи какие события EventBus потребуются и как они влияют на режимы.
- **Проверь источник истины**: см. раздел 1.1 для STATE_CATALOG.md и interaction_matrix.yaml.

**Во время**
- **ОБЯЗАТЕЛЬНО**: Перед созданием любого кода выполнить проверки из раздела 11.2 (дублирование, конфликты, race conditions)
- **ОБЯЗАТЕЛЬНО**: При работе с ошибками/багами следовать методологии изоляции из раздела 10.2 (изоляция проблемы, тестирование мелких частей, запрет догадок)
- **ОБЯЗАТЕЛЬНО**: После каждого исправления/реализации создать изолированный тест, подтверждающий работоспособность (см. раздел 10.2, пункт 5). Исправление считается завершенным **ТОЛЬКО** после успешного прохождения изолированного теста. При создании теста следовать практическому руководству из раздела 10.2.1 (изоляция, учет флагов, тестирование дублирования/конфликтов/race conditions).
- Соблюдай архитектуру: интеграция → модуль → EventBus, никаких прямых вызовов между модулями.
- Сохраняй порядок инициализации SimpleModuleCoordinator.
- Сначала ищи возможность переиспользовать существующий модуль/интеграцию; если расширяешь, делай это через конфигурацию или дополнительные события.
- **ПЕРЕД созданием функции/метода**: Выполнить поиск существующей функциональности (grep, codebase_search)
- **ПЕРЕД созданием переменной**: Проверить конфликты имен и состояний
- **ПЕРЕД доступом к данным**: Проверить thread-safety и добавить блокировки (если нужно)
- Добавляй новые события в явный список и документируй формат payload.
- Не забывай о `session_id`, `source` в событиях и об обработке ошибок.

**Инвариант: изменил поведение? обнови 4 артефакта**

Если изменение затрагивает оси состояния или правила взаимодействия, **ОБЯЗАТЕЛЬНО** обновить:
1. ✅ `Docs/STATE_CATALOG.md` — добавить/изменить ось, обновить владельцев/читателей
2. ✅ `config/interaction_matrix.yaml` — добавить/изменить правило взаимодействия
3. ✅ `integration/core/gateways.py` — реализовать логику в соответствующем gateway
4. ✅ Тесты gateways — добавить/обновить тесты (≥8–14 pairwise + 2 негативных) с проверкой decision-логов

**Machine-enforced правила** (машинно-проверяемые условия):
- **Запрет прямого доступа к состоянию**: `pyproject.toml` + `scripts/verify_no_direct_state_access.py` проверяют паттерны доступа к состоянию
- **Валидация схем**: `tests/test_schemas.py` + `scripts/validate_schemas.py` проверяют соответствие unified_config.yaml и interaction_matrix.yaml схемам
- **CI-гейты**: `.github/workflows/ci.yml` (lint, schema-validate, contracts-test, impact-gate) обязательны перед мерджем

**Проверка синхронизации** (перед мерджем):
- [ ] Все оси из STATE_CATALOG.md присутствуют в interaction_matrix.yaml (если влияют на решения)
- [ ] Все правила из interaction_matrix.yaml реализованы в gateways.py
- [ ] Все gateways покрыты тестами (≥8–14 pairwise + 2 негативных) с проверкой decision-логов в каноническом формате
- [ ] Machine-enforced правила пройдены (lint, schema-validate, verify_no_direct_state_access)
- [ ] **Требования обновлены**: Если изменение логики затрагивает требования, обновлён `Docs/PROJECT_REQUIREMENTS.md` и запущены `scripts/update_requirements_snapshot.py --check` + `scripts/check_requirements_mapping.py`

**Перед мерджем — SIMPLE-гейт**

- [ ] Решение доступно в v0: ≤60 LOC, ≤1 файл, без новых фича-флагов/зависимостей/демонов
- [ ] Использованы только существующие selectors/gateways и события EventBus
- [ ] Добавлены 1 happy + 1 негативный тест на gateway

Если нарушено — приложить микро-ADR (7 строк: причина → почему v0 не хватило → откат).

**Перед мерджем — Impact-гейт**

- [ ] Приложен `change_impact.yaml` (оси условий, инварианты, guards, тест-стратегия, метрики, роллаут)
- [ ] Обновлены `Docs/STATE_CATALOG.md` и/или `config/interaction_matrix.yaml` (если задето)
- [ ] `STATE_CATALOG.md` обновлён (оси/владельцы/читатели) под текущее изменение
- [ ] Есть минимум 8–14 pairwise тестов по выбранным осям + 2 негативных
- [ ] Логи решений видны локально: `decision=<...> ctx={...} source=<domain>` (см. раздел 8.1 для канонического формата)
- [ ] Фича-флаг + kill-switch прописаны (см. раздел 19 «Роллаут»)
- [ ] Выполнены тест-планы из `required_test_plans` в `change_impact.yaml`, отчёт приложен (логи/события/метрики)

### 11.1 Обязательный процесс планирования изменений

**КРИТИЧЕСКИ ВАЖНО**: Перед любыми изменениями кода ассистент **ОБЯЗАН** выполнить следующие шаги в указанном порядке:

1. **Пройти ARCHITECTURE_ANALYSIS_CHECKLIST.md**: Открыть `Docs/ARCHITECTURE_ANALYSIS_CHECKLIST.md` и заполнить все этапы 0-6 для полного анализа архитектуры, структуры, взаимодействий и конфигурации
2. **Пройти PRE_CHANGE_PLANNING_CHECKLIST.md**: Открыть `Docs/PRE_CHANGE_PLANNING_CHECKLIST.md` и заполнить все этапы 1-6
3. **Определить структуру документов**: Решить, нужны ли множественные документы планирования (см. `MULTI_DOCUMENT_PLANNING_GUIDE.md`)
4. **Создать документы планирования** (если нужно):
   - Мастер-план (если >1 этапа) → использовать шаблон из `templates/PLANNING_DOCUMENT_TEMPLATE.md`
   - Планы этапов (если >1 компонента) → использовать шаблон
   - Планы реализации → использовать шаблон
   - Планы тестирования → использовать шаблон
5. **Добавить в MASTER_PLANNING_INDEX.md**: Все созданные документы должны быть добавлены в индекс
6. **Создать Impact Map**: Заполнить таблицу влияния (см. шаблон ниже)
7. **Создать change_impact.yaml**: Скопировать шаблон из `.impact/change_impact.yaml.template` и заполнить
8. **Обновить документацию**: Обновить STATE_CATALOG.md, interaction_matrix.yaml, PROJECT_REQUIREMENTS.md (если нужно)
9. **Проверить готовность**: Запустить `python scripts/verify_planning_readiness.py --strict`

**Без выполнения этих шагов изменения кода НЕ НАЧИНАЮТСЯ.**

#### Impact Map (обязательный артефакт)
- Перед любыми правками ассистент формирует Impact Map и прикладывает её к задаче до внесения кода. Без заполненной карты изменение не стартует.
- Impact Map описывает полную цепочку влияния: какие оси/инварианты задеты, какие модули/интеграции/события EventBus/конфиги/флаги/kill-switches нужно синхронизировать, какие артефакты и тесты обновить.
- Минимальный шаблон:

| Ось или инвариант | Модули/интеграции | EventBus события/контракты | Конфиги/флаги | Тест-планы/скрипты | Документация |
| --- | --- | --- | --- | --- | --- |
| permissions.mic | VoiceRecognitionIntegration, first_run_permissions_integration | voice.recognition.start/result | unified_config.yaml (`NEXY_FEATURE_PERMISSION_RESTART_V2`) | tests/test_gateways.py, scripts/verify_no_direct_state_access.py | STATE_CATALOG.md, interaction_matrix.yaml |

- Для каждой строки ассистент указывает конкретные файлы и проверки, которые нужно затронуть (STATE_CATALOG.md, interaction_matrix.yaml, gateways.py, Docs, scripts).
- После реализации Impact Map обновляется фактическими ссылками (PR diff, лог команд) и сверяется с `change_impact.yaml`.

#### Чек-лист быстрой проверки (минимум перед началом кода):
- [ ] **Пройден ARCHITECTURE_ANALYSIS_CHECKLIST.md**: Все этапы 0-6 выполнены (анализ архитектуры, структуры, взаимодействий, конфигурации)
- [ ] Прочитан `Docs/PRE_CHANGE_PLANNING_CHECKLIST.md` и пройдены этапы 1-6
- [ ] Определена структура документов (нужны ли множественные документы?)
- [ ] Созданы документы планирования (если нужно) и добавлены в `MASTER_PLANNING_INDEX.md`
- [ ] Создана Impact Map с заполненной таблицей влияния
- [ ] Создан `.impact/change_impact.yaml` с заполненными разделами
- [ ] Обновлены STATE_CATALOG.md и interaction_matrix.yaml (если затронуты оси)
- [ ] Обновлен PROJECT_REQUIREMENTS.md (если затронуты требования)
- [ ] Запущен `python scripts/verify_planning_readiness.py --strict` без ошибок

#### Правила для множественных документов планирования:
- **Все документы планирования ОБЯЗАНЫ быть добавлены в `MASTER_PLANNING_INDEX.md`**
- **Документы должны быть связаны между собой** (родитель → дети через ссылки)
- **Использовать шаблоны** из `templates/PLANNING_DOCUMENT_TEMPLATE.md` для создания новых документов
- **Следовать иерархии уровней** (2-6): Мастер-план → План этапа → План реализации → План тестирования → Отчет
- **Обновлять статусы** документов при изменении (🟡 В планировании | 🟢 В реализации | ✅ Завершен)

**После**
- **ОБЯЗАТЕЛЬНО**: Создать изолированный тест для проверки исправленной/реализованной функциональности (см. раздел 10.2, пункт 5). Исправление/реализация считается завершенной **ТОЛЬКО** после успешного прохождения изолированного теста.
- **ОБЯЗАТЕЛЬНО**: Очистить устаревшие и лишние документы после завершения тестирования и реализации (см. раздел 11.2.1). Это включает удаление временных планов, дубликатов, устаревших отчетов и документов, которые больше не актуальны.
- Если добавлена новая интеграция/модуль — зафиксируй обоснование в `Docs/CURRENT_STATUS_REPORT.md`.
- **Проверь контракт EventBus** согласно чек-листу (раздел 16.6).
- Добавь интеграцию в `SimpleModuleCoordinator._create_integrations()` (если новая) и настрой приоритеты.
- Обнови `config/unified_config.yaml`, документацию и при необходимости паковочные гайты.
- Прогоняй ручные проверки и убедись, что логи чисты от ошибок.
- Если менялись gRPC контракты — синхронизируй изменения с серверной командой.
- **Если изменение логики затрагивает требования**: обнови `Docs/PROJECT_REQUIREMENTS.md` и запусти `scripts/update_requirements_snapshot.py --update` + `scripts/check_requirements_mapping.py` (см. раздел 11.3).
- **Перед мерджем**: запусти `scripts/pre_build_gate.sh` для проверки всех обязательных проверок (см. раздел 11.4).

### 11.3 Процесс обновления требований (RELEASE_INTEGRITY_PLAN этап 1)

**ОБЯЗАТЕЛЬНО**: Любое изменение логики, затрагивающее требования, начинается с обновления `Docs/PROJECT_REQUIREMENTS.md`.

**Before (подготовка)**:
1. Проверить текущий `Docs/PROJECT_REQUIREMENTS.md`
2. Определить, какие требования (REQ-XXX) затрагиваются
3. Уведомить Owner требования о планируемых изменениях

**During (внесение изменений)**:
1. Обновить `Docs/PROJECT_REQUIREMENTS.md`:
   - Добавить/изменить требование (REQ-XXX) с полями: Домен, Критичность, Описание, Источник, Owner, Ожидаемый результат, Implementation, Verification
   - Обновить Implementation Map (таблица соответствия требований реализации и тестам)
2. Обновить исходный документ (если требуется)
3. Обновить код/тесты согласно требованию
4. Запустить `scripts/update_requirements_snapshot.py --check` для валидации структуры
5. Запустить `scripts/check_requirements_mapping.py` для проверки соответствия Implementation/Verification

**After (проверка синхронизации)**:
1. ✅ Все требования из исходных документов присутствуют в snapshot
2. ✅ Все требования имеют Implementation и Verification
3. ✅ Скрипты проверки пройдены (`update_requirements_snapshot.py --check`, `check_requirements_mapping.py`)
4. ✅ Owner требования уведомлён и одобрил изменения
5. ✅ Обновлён `client/VERSION_INFO.json` через `scripts/update_requirements_snapshot.py --update`

**Связанные документы**:
- `Docs/PROJECT_REQUIREMENTS.md` — единый snapshot требований
- `Docs/REQUIREMENTS_SOURCE_MAP.md` — карта всех документов требований
- `scripts/update_requirements_snapshot.py` — валидация и обновление snapshot
- `scripts/check_requirements_mapping.py` — проверка соответствия требований коду и тестам

### 11.4 Pre-build Gate (RELEASE_INTEGRITY_PLAN этап 2)

**ОБЯЗАТЕЛЬНО**: Перед мерджем и сборкой запускается `scripts/pre_build_gate.sh` для проверки всех обязательных проверок.

**Что проверяет pre-build gate**:
1. **Линтеры и форматтеры**: ruff lint, проверка прямого доступа к состоянию
2. **Unit-тесты**: тесты схем, gateways, порядка инициализации, permission restart, golden tests, SLO
3. **Статические проверки**: валидация схем, 4-артефактный инвариант, покрытие правил/предикатов, регистрация feature flags, валидация snapshot требований
4. **Специализированные проверки**: TAL assertion, permission monitoring, критические пути, tray termination

**Использование**:
```bash
# Полная проверка
./scripts/pre_build_gate.sh

# С опциями
./scripts/pre_build_gate.sh --skip-tests    # Пропустить тесты
./scripts/pre_build_gate.sh --skip-lint     # Пропустить линтеры
./scripts/pre_build_gate.sh --verbose       # Подробный вывод
```

**В CI**: Pre-build gate запускается автоматически в `.github/workflows/ci.yml` (job `pre-build-gate`).

**Exit codes**:
- `0` — все проверки пройдены, можно продолжать сборку
- `1` — хотя бы одна проверка провалена, сборка блокируется

**Связанные документы**:
- `scripts/pre_build_gate.sh` — скрипт pre-build gate
- `.github/workflows/ci.yml` — CI интеграция
- `Docs/PROJECT_REQUIREMENTS.md` — требования REQ-023 (Machine-enforced правила)

### 11.5 Release Suite (RELEASE_INTEGRITY_PLAN этап 3)

**ОБЯЗАТЕЛЬНО**: Перед релизом запускается `scripts/run_release_suite.py` для выполнения полного цикла интеграционных проверок.

**Что проверяет Release Suite**:
1. **Pre-build gate**: все обязательные проверки перед сборкой
2. **Сборка dev-билда**: PyInstaller сборка клиента
3. **Проверка логов**: headless запуск и проверка логов на соответствие спецификациям (AppKit fix, TAL удержание, first-run)
4. **Интеграционные тесты**: критические тесты (gateways, init order, permission restart)
5. **Проверки сервера**: gRPC health check, AppCast доступность
6. **Сверка требований**: соответствие PROJECT_REQUIREMENTS с тестами

**Использование**:
```bash
# Полный цикл проверок
python scripts/run_release_suite.py

# С опциями
python scripts/run_release_suite.py --smoke         # Smoke mode: быстрые проверки без сборки и сервера
python scripts/run_release_suite.py --skip-build    # Пропустить сборку
python scripts/run_release_suite.py --skip-server   # Пропустить проверки сервера
python scripts/run_release_suite.py --output report.json  # Сохранить отчёт
```

**JSON-отчёт**: Release Suite возвращает JSON-отчёт с результатами всех проверок (`release_suite_report.json`).

**Exit codes**:
- `0` — все проверки пройдены, можно продолжать релиз
- `1` — хотя бы одна проверка провалена, релиз блокируется

**Связанные документы**:
- `scripts/run_release_suite.py` — скрипт Release Suite
- `Docs/PROJECT_REQUIREMENTS.md` — требования для сверки
- `RELEASE_INTEGRITY_PLAN.md` — полный план целостности релиза

### 11.6 Prepare Release (RELEASE_INTEGRITY_PLAN этап 4)

**ОБЯЗАТЕЛЬНО**: Перед релизом запускается `scripts/prepare_release.sh` для выполнения полной цепочки подготовки релиза.

**Что выполняет prepare_release**:
1. **Pre-build gate**: все обязательные проверки перед сборкой
2. **Release Suite**: полный цикл интеграционных проверок
3. **PyInstaller сборка**: создание .app через rebuild_from_scratch.sh
4. **Встраивание метаданных**: копирование VERSION_INFO.json и release_suite_report.json в .app
5. **PKG создание**: pkgbuild и productbuild через build_final.sh
6. **Нотарификация**: проверка статуса нотарификации (выполняется в build_final.sh)
7. **Валидация бандла**: проверка метаданных и отчётов через validate_release_bundle.py

**Использование**:
```bash
# Полная цепочка подготовки релиза
./scripts/prepare_release.sh

# С опциями
./scripts/prepare_release.sh --skip-tests          # Пропустить тесты в pre-build gate
./scripts/prepare_release.sh --skip-notarization    # Пропустить проверку нотарификации
./scripts/prepare_release.sh --dry-run             # Режим dry-run (команды не выполняются)
```

**Exit codes**:
- `0` — все шаги пройдены, релиз готов
- `1` — хотя бы один шаг провален, релиз блокируется

**Связанные документы**:
- `scripts/prepare_release.sh` — скрипт подготовки релиза
- `scripts/validate_release_bundle.py` — валидация релизного бандла
- `packaging/build_final.sh` — финальная сборка и нотарификация
- `RELEASE_INTEGRITY_PLAN.md` — полный план целостности релиза

### 11.7 Validate Release Bundle

**ОБЯЗАТЕЛЬНО**: Перед загрузкой на сервер запускается `scripts/validate_release_bundle.py` для проверки метаданных артефакта.

**Что проверяет validate_release_bundle**:
1. **Структура .app**: наличие обязательных путей (Contents/Info.plist, Contents/MacOS/Nexy, Contents/Resources)
2. **Info.plist**: валидность и наличие обязательных ключей (CFBundleIdentifier, CFBundleVersion)
3. **VERSION_INFO.json**: наличие и валидность метаданных (version, req_version, req_checksum)
4. **release_suite_report.json**: наличие и валидность отчёта Release Suite
5. **Подпись кода**: проверка через `codesign --verify`
6. **Нотарификация**: проверка через `xcrun stapler validate`
7. **PKG (опционально)**: проверка подписи и нотарификации PKG

**Использование**:
```bash
# Валидация .app
python scripts/validate_release_bundle.py dist/Nexy.app

# Валидация .app и .pkg
python scripts/validate_release_bundle.py dist/Nexy.app dist/Nexy.pkg
```

**Exit codes**:
- `0` — все проверки пройдены
- `1` — есть ошибки валидации

**Связанные документы**:
- `scripts/validate_release_bundle.py` — скрипт валидации
- `RELEASE_INTEGRITY_PLAN.md` — полный план целостности релиза

### 11.8 Continuous Verification (RELEASE_INTEGRITY_PLAN этап 5)

**ОБЯЗАТЕЛЬНО**: CI обеспечивает непрерывную проверку качества через автоматические проверки.

**Что включает Continuous Verification**:
1. **На PR**: pre-build gate + усечённый release suite (smoke mode)
2. **Nightly**: полный release suite + отчёт о покрытии требований
3. **Автоматические отчёты**: покрытие требований (что проверено, что нет)

**CI Workflow**:
- **pre-build-gate**: запускается на всех событиях (PR, push, schedule, workflow_dispatch)
- **release-suite-smoke**: запускается только на PR (быстрые проверки без сборки и сервера)
- **release-suite-full**: запускается на schedule (nightly) и workflow_dispatch (ручной запуск)

**Отчёты**:
- `release_suite_report.json` — результаты Release Suite (загружается как артефакт)
- `requirements_coverage_report.json` — покрытие требований (только в nightly)

**Использование**:
```bash
# Генерация отчёта о покрытии требований
python scripts/generate_requirements_coverage.py --output requirements_coverage_report.json
```

**Связанные документы**:
- `.github/workflows/ci.yml` — CI workflow с nightly builds
- `scripts/generate_requirements_coverage.py` — генерация отчёта о покрытии требований
- `RELEASE_INTEGRITY_PLAN.md` — полный план целостности релиза

### 11.9 Continuous Monitoring (RELEASE_INTEGRITY_PLAN этап 8)

**ОБЯЗАТЕЛЬНО**: Непрерывный мониторинг метрик и SLO обеспечивает контроль качества в production.

**Что включает Continuous Monitoring**:
1. **Мониторинг метрик**: анализ логов и извлечение метрик из `client/metrics/registry.md`
2. **Проверка SLO**: автоматическая проверка соответствия метрик SLO порогам
3. **Отчёты**: генерация JSON-отчётов о производительности и нарушениях SLO
4. **Интеграция в CI**: проверка SLO в nightly builds и перед релизом

**Использование**:
```bash
# Анализ метрик из лог-файла
python scripts/monitor_metrics.py --log-file log.md --output metrics_report.json

# Проверка SLO с выходом при нарушениях
python scripts/monitor_metrics.py --log-file log.md --check-slo

# Автоматический поиск последнего лог-файла
python scripts/monitor_metrics.py --output metrics_report.json
```

**SLO пороги**: Определены в `client/metrics/registry.md` и проверяются автоматически.

**Exit codes**:
- `0` — все метрики соответствуют SLO порогам (или проверка не выполнялась)
- `1` — обнаружены нарушения SLO (только с флагом `--check-slo`)

**Связанные документы**:
- `scripts/monitor_metrics.py` — скрипт мониторинга метрик
- `client/metrics/registry.md` — реестр метрик и SLO порогов
- `tests/perf/test_slo.py` — тесты SLO
- `RELEASE_INTEGRITY_PLAN.md` — полный план целостности релиза

### 11.10 Packaging Regression Checklist
- Любые изменения, влияющие на рантайм, ресурсы, конфигурацию, зависимости или упаковку, сопровождаются заполненным checklist до ревью.
- Checklist ссылается на `Docs/PACKAGING_FINAL_GUIDE.md` и соответствующие `modules/*/MACOS_PACKAGING_GUIDE.md`; шаги нельзя пропускать без ADR.
- Минимальный набор проверок:
  1. PyInstaller сборка (`rebuild_from_scratch.sh` или аналог) — приложить лог выполнения.
  2. `pkgbuild` + `productbuild` + notarization dry-run — зафиксировать команды и статусы.
  3. Валидация `config/unified_config.yaml`, `Docs/PACKAGING_FINAL_GUIDE.md`, модульных MACOS_PACKAGING_GUIDE на актуальность после изменений.
  4. Smoke-тест `cold_start_diagnostics.sh` и запуск собранной `.app` из `dist/` (логи приложены).
  5. Проверка ресурсов (ffmpeg, assets) на присутствие в пакете и валидные пути.
- Итоговый статус фиксируй в `Docs/PACKAGING_READINESS_CHECKLIST.md` (ссылка на обновлённый `Docs/PRE_PACKAGING_VERIFICATION.md`).
- Результаты checklist прикладываются к PR/таске вместе с логами. Без выполненного checklist правки не мержим.

## 12. Распространённые риски
- **Догадки без изоляции**: Попытки исправить ошибки "наугад" или тестировать всю систему без изоляции проблемы приводят к нестабильным исправлениям и регрессиям. **ОБЯЗАТЕЛЬНО** следовать методологии изоляции из раздела 10.2.
- **Завершение исправления без изолированного теста**: Считание исправления/реализации завершенной без изолированного теста, подтверждающего работоспособность, приводит к нестабильному коду и скрытым багам. **ОБЯЗАТЕЛЬНО** создавать изолированный тест после каждого исправления/реализации (см. раздел 10.2, пункт 5).
- **Накопление устаревших документов**: Отсутствие очистки устаревших документов после тестирования и реализации приводит к путанице, дублированию информации и затрудняет навигацию по документации. **ОБЯЗАТЕЛЬНО** проводить очистку устаревших документов после завершения работы (см. раздел 11.2.1).
- Изменение режима без `mode.request` ломает FSM и workflows.
- Дублирование конфигурации приводят к рассинхронизации при сборке.
- Прямые вызовы модулей минуя интеграции нарушают масштабируемость.
- Отсутствие проверок разрешений вызывает краши в production.
- Непрожатые события `session_id` делают сложным трекинг цепочек в логах.

## 13. Напоминание
Клиентская часть должна оставаться совместимой с уже завершёнными интеграциями. При сомнениях синхронизируйся с владельцем сервера и UX прежде чем менять контракт или пользовательский поток.

**ОБНОВЛЕНО:** Создана `first_run_permissions_integration.py` - полноценная система первого запуска с умными паузами и блокирующей логикой. Проверка разрешений также выполняется через специализированные интеграции (VoiceRecognitionIntegration, ScreenshotCaptureIntegration и т.д.).

## 14. Принципы архитектуры "быстрой диагностики"

### 14.1 Модули и границы (адаптировано под Nexy)
- **Модуль = изолированная ответственность** + собственная "экосистема" в `modules/`
- **Вход только через интеграции** (`integration/integrations/`), выход — через EventBus события
- **Зависимости строго внутрь** (core → types), core не импортирует platform-specific код
- **После принятия модуля в "рабочий" режим изменения — только через ADR + тест-план**
- **Запрет на дублирование**: один capability — один владелец (указан в README модуля)

**Definition of Done (модуль):** README, публичные интерфейсы в types.py, конфигурация, логирование событий, тесты (если есть), диагностические эндпоинты.

### 14.2 Интеграции и контракты (адаптировано под EventBus)
- **У каждой интеграции есть четкий контракт** через EventBus события + payload схемы
- **Совместимость**: несовместимые изменения → новая мажорная версия события, совместимые — минор
- **Интеграция только по "Инструкции модуля"**: входные события валидируются на границе

**FSM-домены с guard-условиями (нормирование):**
Для доменов `audio`, `permissions`, `mode_management`, `first_run`, `permission_restart` решения принимаются **ТОЛЬКО через FSM-таблицы и gateways**:
- `(state, event) --[guard]--> (new_state, action)`
- Guard-условия обязаны проверять критичные оси: permissions, device, network, firstRun
- Все проверки состояния через selectors, все решения через gateways (см. раздел 21)
- Запрещены скрытые записи состояний в чужие домены — только через EventBus

**Нормирование FirstRunPermissions/PermissionRestart:**
- FirstRunPermissions: решения через gateways (`decide_start_listening` с проверкой `first_run`)
- PermissionRestart: решения через gateways (см. `modules/permission_restart/core/restart_scheduler.py`)
- Поведение фиксируется в `interaction_matrix.yaml` с приоритетами (hard_stop/graceful)
- Все блокировки и отсрочки описаны в `Docs/PERMISSION_RESTART_BLOCKERS.md` и отражены в `interaction_matrix.yaml`

### 14.3 Конфигурация и состояние (уже реализовано)
- **Единый источник конфигурации** (`config/unified_config.yaml`) + схемы конфигурации
- **Минимум shared state**; глобальные состояния — только в ApplicationStateManager
- **Конфиг инициализируется один раз на старте** и логируется

### 14.4 Наблюдаемость "по умолчанию" (адаптировано под текущее логирование)
- **Структурированные логи** с session_id для трекинга цепочек
- **Таксономия ошибок** через ErrorHandler с кодами и контекстом
- **Метрики**: error-rate, latency по интеграциям, счетчики событий
- **Диагностический режим**: расширенные логи, health checks через EventBus

### 14.5 Качество кода и стандарты
- **Код-стайл и линтеры** — обязательны
- **Запрет копипаста интерфейсов** (single source of truth — types.py в модулях)
- **Guards/asserts для инвариантов** домена; Result вместо исключений внутри домена

### 14.6 Тест-стратегия (минимум для Nexy)
- **Unit тесты** для core логики модулей (<10мс, без IO)
- **Contract тесты** для интеграций (EventBus события + payload)
- **Интеграционные тесты** — локальный стенд с реальными модулями
- **Smoke тесты** — 5–10 happy-path сценариев перед релизом
- **Ручные проверки** — push-to-talk, переходы режимов, Tray меню

### 14.7 Поставка и изменения
- **ADR (Architecture Decision Record)** для значимых изменений в модули
- **Фича-флаги** через unified_config для постепенного rollout
- **Миграции двунаправленные**; форматы событий — совместимые на время перехода
- **Если SLO пробит — стоп релизы**, приоритет стабильности
 - **ADR-минимум**: один абзац «что/почему/альтернативы/дата» для любого изменения модуля или матрицы взаимодействий

### 14.8 Безопасность и приватность (адаптировано под macOS)
- **Секреты — из Keychain**; в логах маскировка PII
- **Лейблы в событиях без чувствительных данных**
- **Поведенческие лимиты**: rate-limits как часть контракта интеграций

### 14.9 Производительность и бюджет
- **Для ключевых usecase заданы latency-бюджеты** (p95) через EventBus
- **"Тяжёлые" пути** — с профилировкой и отдельными метриками

## 15. Мини-спецификации качества

### 15.1 Требования к логированию (каждый модуль)
- **Формат логов**: `YYYY-MM-DD HH:MM:SS - Nexy - LEVEL - [session_id] - Message`
- **События**: `module.start|ok|fail` с session_id, duration_ms, ключевым контекстом
- **Ошибки**: code, reason, module, retries, timeout_ms через ErrorHandler
- **Лог-уровни**: warn — ожид. аномалии; error — потеря функции. info — бизнес-события
- **Для DIAG**: добавлять config_hash, build_id, git_sha

**Decision-лог**: см. раздел 8.x для канонического формата. Используется для FSM/интеграций, принимающих решения на основе множественных осей состояния.

**Метрики**:
- `decision_rate{type}` — распределение решений
- `stream_open_success_rate` — доля удачных запусков аудио
- `tcc_prompt_duration_ms` — длительность последовательности разрешений (p95)

**Примеры**:
- `2024-01-15 10:30:45 - Nexy - INFO - [abc123] - voice_recognition.start - duration_ms=150`
- `2024-01-15 10:30:46 - Nexy - ERROR - [abc123] - E_DEP_TIMEOUT - gRPC connection failed`

### 15.2 Таксономия ошибок (адаптированная под Nexy)
- **Коды ошибок**: E_INPUT_INVALID, E_STATE_INVAR, E_DEP_TIMEOUT, E_DEP_UNAVAILABLE, E_RATE_LIMITED, E_UNKNOWN
- **Категории ErrorHandler**: INITIALIZATION, RUNTIME, CONFIGURATION, NETWORK, PERMISSION, UNKNOWN
- **Политики живут в unified_config** (timeouts/retries), код их читает
- **Маппинг**: коды ошибок → категории ErrorHandler → уровни логирования

### 15.3 Инструкция модуля (README шаблон)
- **Назначение, владельцы**
- **Публичные интерфейсы** (types.py) + ссылки на EventBus события
- **Инварианты и ошибки** (маппинг кодов)
- **Метрики и ключевые логи**
- **Диаг-эндпоинты и self-checks**
- **Примеры сценариев** (fixtures + команда запуска)

### 15.4 Чек-лист "принять модуль"
- **Контракт EventBus создан** согласно разделу 16 (обязательно!)
- **Контракты и схемы** лежат в types.py
- **Валидаторы входа** включены на границе интеграции
- **Логи/метрики/трейсинг** соответствуют стандарту
- **Unit/Contract/Integration/Smoke** — зелёные
- **Diag-режим и health-пробы** работают
- **ADR на рисковые решения** добавлен

## 16. Руководство по созданию контрактов интеграции

### 16.1 Обязательность контрактов
- **Каждая интеграция ДОЛЖНА иметь четкий контракт** через EventBus события
- **Без контракта интеграция не принимается** в production
- **Контракт документируется** в README модуля и в интеграции

### 16.2 Структура контракта EventBus
```python
# Пример контракта для voice_recognition_integration
CONTRACT = {
    "module": "voice_recognition",
    "version": "1.0",
    "events": {
        "input": {
            "voice.recognition.start": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "language": "string (optional, default: en-US)",
                    "timeout_sec": "float (optional, default: 10.0)"
                },
                "required": ["session_id"]
            },
            "voice.recognition.stop": {
                "payload": {
                    "session_id": "string (uuid4)"
                },
                "required": ["session_id"]
            }
        },
        "output": {
            "voice.recognition.result": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "text": "string",
                    "confidence": "float (0.0-1.0)",
                    "language": "string",
                    "duration_ms": "int"
                },
                "required": ["session_id", "text"]
            },
            "voice.recognition.error": {
                "payload": {
                    "session_id": "string (uuid4)",
                    "error_code": "string (E_INPUT_INVALID|E_DEP_TIMEOUT|E_UNKNOWN)",
                    "error_message": "string",
                    "retry_count": "int (optional)"
                },
                "required": ["session_id", "error_code", "error_message"]
            }
        }
    }
}
```

### 16.3 Правила именования событий
- **Формат**: `<module>.<action>` (например: `voice.recognition.start`)
- **Модуль**: название модуля в snake_case
- **Действие**: глагол в present tense (start, stop, result, error, request, response)
- **Версионирование**: мажорные изменения → новое событие `v2` (например: `voice.recognition.start.v2`)

### 16.4 Схемы payload
- **Обязательные поля**: `session_id` для всех событий
- **Типы данных**: string, int, float, bool, dict, list
- **Валидация**: на границе интеграции через pydantic или dataclasses
- **Документация**: каждый payload документируется с примерами

### 16.5 Версионирование контрактов
- **Мажорные изменения** (breaking): новая версия события (`module.action.v2`)
- **Минорные изменения** (совместимые): добавление optional полей
- **Обратная совместимость**: старые события поддерживаются 2 версии
- **Миграция**: через unified_config флаги

### 16.5.1 Migration Playbook (безопасные breaking changes)

**Цель**: Безопасный переход от `module.action.v1` к `module.action.v2` без потери функциональности.

#### Чек-лист миграции событий

**Before (подготовка)**:
1. [ ] Определить breaking changes в payload/семантике события
2. [ ] Создать новую версию события (`module.action.v2`)
3. [ ] Добавить feature flag для новой версии (`NEXY_FEATURE_<MODULE>_V2`)
4. [ ] Обновить контракт EventBus с обеими версиями
5. [ ] Уведомить всех потребителей события о планах миграции

**During (shadow-mode)**:
1. [ ] Обе версии публикуются параллельно (v1 + v2)
2. [ ] Новая версия включена только для тестовых пользователей (1% → 25% → 100%)
3. [ ] Мониторинг метрик: нет регрессий на новой версии
4. [ ] Мониторинг ошибок: нет критических ошибок в v2

**Migration timeline**:
- **Week 1-2**: Shadow-mode (1% пользователей)
- **Week 3-4**: Gradual rollout (25% → 50% → 75%)
- **Week 5**: Full rollout (100%)
- **Week 6**: Deprecation notice для v1 (логирование warning)
- **Week 8+**: Удаление v1 (после 2 версий поддержки)

**After (завершение миграции)**:
1. [ ] Все потребители переведены на v2
2. [ ] Feature flag удалён (v2 по умолчанию)
3. [ ] v1 код удалён из кодовой базы
4. [ ] Контракт обновлён (только v2)
5. [ ] Документация обновлена

#### Пример миграции

```python
# Shadow-mode: обе версии поддерживаются
def publish_event(self, event_name: str, payload: dict):
    # Старая версия (для обратной совместимости)
    self.event_bus.publish(f"{event_name}", payload)
    
    # Новая версия (если feature flag включен)
    if self._config.get("use_v2", False):
        v2_payload = migrate_to_v2(payload)
        self.event_bus.publish(f"{event_name}.v2", v2_payload)
```

#### Правила безопасности

- **НЕ удаляй v1** пока не прошло минимум 2 версии релизов после полного rollout v2
- **НЕ меняй v1** после начала миграции (только deprecation warnings)
- **ВСЕГДА используй feature flags** для контроля rollout
- **ВСЕГДА мониторь метрики** во время миграции
- **ВСЕГДА имей kill-switch** для мгновенного отката

### 16.6 Чек-лист контракта
- ✅ **События документированы** с полными payload схемами
- ✅ **Валидация payload** на границе интеграции
- ✅ **Обработка ошибок** через ErrorHandler с кодами
- ✅ **Тесты контракта** (unit + integration)
- ✅ **Примеры использования** в README
- ✅ **Версионирование** для breaking changes
- ✅ **Обратная совместимость** соблюдена

### 16.7 Примеры контрактов
- **signals**: см. `modules/signals/INTEGRATION_GUIDE.md`
- **voice_recognition**: события start/stop/result/error
- **grpc_client**: события request/response/error с session_id
- **mode_management**: события mode.request/mode.changed

### 16.8 Инструменты для контрактов
- **Валидация**: pydantic, dataclasses с type hints
- **Тестирование**: contract tests с фикстурами
- **Документация**: OpenAPI-подобные схемы в README
- **Мониторинг**: метрики по событиям и ошибкам


## 17. Базовые архитектурные принципы

### 17.1 SOLID принципы
- **Single Responsibility**: каждый модуль отвечает за одну задачу
- **Open/Closed**: модули открыты для расширения, закрыты для модификации
- **Liskov Substitution**: интеграции взаимозаменяемы через BaseIntegration
- **Interface Segregation**: четкие интерфейсы в types.py
- **Dependency Inversion**: зависимости через EventBus, не прямые импорты

### 17.2 Dependency Injection
- **Внедрение через конструктор**: EventBus, StateManager, ErrorHandler
- **Инверсия зависимостей**: модули не знают о конкретных реализациях
- **Конфигурация извне**: `config/unified_config.yaml`, не хардкод в модулях
- **Тестируемость**: легко подменить зависимости в тестах

### 17.3 Separation of Concerns
- **Модули**: бизнес-логика и низкоуровневые операции
- **Интеграции**: координация и адаптация к EventBus
- **Core**: инфраструктура (EventBus, StateManager, ErrorHandler)
- **Workflows**: управление состояниями приложения

### 17.4 Design Patterns
- **Factory**: создание модулей через SimpleModuleCoordinator
- **Observer**: подписка на события через EventBus
- **Strategy**: разные реализации через интеграции
- **Adapter**: интеграции как адаптеры между модулями и EventBus
- **Singleton**: ApplicationStateManager, ErrorHandler (один экземпляр)

### 17.5 Принципы качества кода
- **DRY (Don't Repeat Yourself)**: переиспользование через интеграции
- **KISS (Keep It Simple)**: простые интерфейсы, сложность в модулях
- **YAGNI (You Aren't Gonna Need It)**: только необходимая функциональность
- **Composition over Inheritance**: предпочтение композиции наследованию

## 18. Каталог состояний и матрица взаимодействий

### 18.1 STATE_CATALOG (Docs/STATE_CATALOG.md)

- Оси/флаги: `permissions.mic|screen|accessibility`, `device.input`, `network`, `firstRun`, `appMode`, `update_in_progress`, ...
- Для каждой оси: допустимые состояния, владелец, кто пишет/читает, источник истины, метрики.
- Ответственный: один владелец документа (по умолчанию: Tech Lead клиента).

**НОВАЯ ОСЬ**: `update_in_progress` — статус обновления приложения (см. STATE_CATALOG.md раздел 10). Владелец: UpdaterIntegration owner. Используется для безопасного рестарта во время обновлений.

### 18.2 INTERACTION_MATRIX (config/interaction_matrix.yaml)

- Фиксирует только взаимозависимые оси (без полного перебора).
- Формат правила:
  - `when: {Permission.mic: denied, appMode: listen} -> decision: abort_listen`
  - `priority: hard_stop | graceful | preference`
- Любое изменение >2 осей должно обновлять эту матрицу.
- Правила приоритетов условий:
  1. `hard_stop`: безопасность/разрешения/инварианты — всегда прерывают действие;
  2. `graceful`: деградация (сеть/квоты) — урезаем функционал, но живём;
  3. `preference`: UX-предпочтения — только если не конфликтуют с 1–2.

**Правила для `update_in_progress`**:
- `graceful` при `update_in_progress=true` → блокирует permission restart (через gateway `decide_permission_restart_safety`)
- `hard_stop` при `update_in_progress=true` + `appMode=LISTENING|PROCESSING` → блокирует запуск обновления
- Селекторы и gateways должны проверять `update_in_progress` в паре с `interaction_matrix.yaml` (см. STATE_CATALOG.md раздел 10)

## 19. Политика роллаута изменяющих взаимодействия

- Любое изменение, затрагивающее >2 осей, включается через фича-флаг.
- Этапы: 1% → 25% → 100% (config-driven), с возможностью shadow-mode (считаем решение, но не применяем).
- Kill-switch: `NEXY_KS_<FEATURE>` в окружении/конфиге, выключает поведение немедленно без релиза.
- В `change_impact.yaml` обязательно указать: флаг, план раскатки, условие отката.

### 19.1 Feature Flags и Kill-Switches (ссылка на раздел 6.1)

**ОБЯЗАТЕЛЬНО**: См. раздел 6.1 для полной информации о Feature Flags и Kill-Switches.

**Специфика роллаута**:
- Любое изменение, затрагивающее >2 осей, включается через фича-флаг.
- Этапы: 1% → 25% → 100% (config-driven), с возможностью shadow-mode (считаем решение, но не применяем).
- Kill-switch: `NEXY_KS_<FEATURE>` в окружении/конфиге, выключает поведение немедленно без релиза.
- В `change_impact.yaml` обязательно указать: флаг, план раскатки, условие отката (см. раздел 11 "Перед мерджем — Impact-гейт").

## 20. SLO и стоп-релизы (beta)

- `p95 start_listening ≤ 600ms`
- `stream_open_success_rate ≥ 98%`
- `permission_flow_success ≥ 99%` (микрофон+экран на first-run)
- Если SLO пробит на beta-канале — стоп всех функциональных релизов до восстановления.

## 21. Selectors и Gateways (архитектура принятия решений)

### 21.1 Принцип разделения ответственности

**Selectors** (`integration/core/selectors.py`): чистые функции для проверки состояний из `Snapshot`.
- Только чтение: не меняют состояние, не имеют side-effects
- Один источник истины: все проверки состояния через selectors
- Примеры: `mic_ready(s)`, `device_idle(s)`, `network_online(s)`, `is_listening_mode(s)`

**Gateways** (`integration/core/gateways.py`): функции принятия решений на основе `Snapshot` и selectors.
- Бизнес-логика: реализуют правила переходов состояний и обработку ошибок
- Используют selectors: никогда не читают состояние напрямую
- Возвращают `Decision`: START, RETRY, ABORT, DEGRADE
- Примеры: `decide_start_listening(s)`, `decide_process_audio(s)`, `decide_with_backoff(s, retry_count)`

### 21.2 Snapshot — единая точка доступа

```python
@dataclass(frozen=True)
class Snapshot:
    perm_mic: PermissionStatus
    perm_screen: PermissionStatus
    perm_accessibility: PermissionStatus
    device_input: DeviceStatus
    network: NetworkStatus
    first_run: bool
    app_mode: AppMode
```

`Snapshot` — неизменяемый снимок всех осей состояния системы. Создается один раз на момент принятия решения и передается в selectors/gateways.

### 21.3 Запрет прямого доступа к состоянию

**Правило**: все проверки состояния ТОЛЬКО через selectors. Прямой доступ к `state_manager` или конфигурации для проверки осей запрещен.

**Исключения**: только файлы `**/selectors.py`, `**/gateways.py`, `**/gateways/**/*.py` могут читать состояние напрямую.

**Линтер**: `pyproject.toml` настроен на проверку паттернов доступа к состоянию (`perm_mic`, `network_online`, `first_run`, `feature_*`, `ks_*`) и фейлит, если файл не в списке исключений.

### 21.4 Использование в интеграциях

```python
from integration.core.selectors import Snapshot, PermissionStatus, DeviceStatus, NetworkStatus, AppMode
from integration.core.gateways import decide_start_listening, Decision
from integration.core.state_manager import ApplicationStateManager

# Создаем snapshot
snapshot = Snapshot(
    perm_mic=PermissionStatus.GRANTED,
    perm_screen=PermissionStatus.GRANTED,
    perm_accessibility=PermissionStatus.GRANTED,
    device_input=DeviceStatus.DEFAULT_OK,
    network=NetworkStatus.ONLINE,
    first_run=False,
    app_mode=AppMode.SLEEPING
)

# Принимаем решение через gateway
decision = decide_start_listening(snapshot)

if decision == Decision.START:
    # Начать listening
    pass
elif decision == Decision.ABORT:
    # Прервать с ошибкой
    pass
elif decision == Decision.RETRY:
    # Повторить с backoff
    pass
elif decision == Decision.DEGRADE:
    # Деградировать функционал
    pass
```

### 21.5 Логирование решений

Все решения логируются в каноническом формате (см. раздел 8.1):

```
decision=<start|abort|retry|degrade> ctx={mic=...,screen=...,device=...,network=...,firstRun=...,appMode=...} source=<domain> duration_ms=<int>
```

Gateways автоматически логируют решения с контекстом из `Snapshot`.

### 21.6 Тестирование selectors/gateways

- **Unit тесты**: selectors — чистые функции, тестируются изолированно с mock `Snapshot`
- **Unit тесты**: gateways — тестируются с различными комбинациями `Snapshot`
- **Pairwise тесты**: покрытие комбинаций осей согласно `interaction_matrix.yaml`
- **Contract тесты**: проверка соответствия логики gateways правилам из `interaction_matrix.yaml`

### 21.7 Связь с interaction_matrix.yaml

Правила из `interaction_matrix.yaml` реализованы в gateways:
- `priority: hard_stop` → `Decision.ABORT`
- `priority: graceful` → `Decision.RETRY` или `Decision.DEGRADE`
- `priority: preference` → учитывается в последнюю очередь

При изменении `interaction_matrix.yaml` обновляются соответствующие gateways и добавляются тесты.
