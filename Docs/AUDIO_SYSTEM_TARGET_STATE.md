# Целевое состояние системы аудио (Target State)

## Дата создания
2025-11-30

## Цель документа

Определить **идеальное поведение** системы аудио (INPUT/OUTPUT) в проекте Nexy. Этот документ описывает, как система должна работать без текущих проблем и ограничений.

---

## 1. ОБЩИЕ ПРИНЦИПЫ ИДЕАЛЬНОЙ СИСТЕМЫ

### 1.1 Надежность
- ✅ **100% определение устройств** - система всегда находит подключенные устройства
- ✅ **Нулевая потеря данных** - переключение устройств не прерывает запись/воспроизведение
- ✅ **Автоматическое восстановление** - система восстанавливается после ошибок без вмешательства пользователя
- ✅ **Нет race conditions** - все операции синхронизированы и безопасны

### 1.2 Производительность
- ✅ **Мгновенное переключение** - смена устройства занимает < 100ms
- ✅ **Низкая задержка** - открытие микрофона < 200ms, начало воспроизведения < 50ms
- ✅ **Минимальная нагрузка** - проверка устройств не нагружает CPU
- ✅ **Эффективное использование ресурсов** - нет избыточных проверок и операций

### 1.3 Пользовательский опыт
- ✅ **Прозрачность** - пользователь не замечает переключений устройств
- ✅ **Предсказуемость** - система всегда работает одинаково
- ✅ **Отсутствие ошибок** - нет сообщений об ошибках для пользователя
- ✅ **Автоматизация** - система сама управляет устройствами без настроек

---

## 2. ИДЕАЛЬНАЯ СИСТЕМА INPUT (Микрофон)

### 2.1 Определение устройства

#### Целевое поведение
```
[Пользователь нажимает LONG_PRESS]
  ↓
[Система определяет устройство за < 100ms]
  ├─ macOS API возвращает актуальное устройство
  ├─ PortAudio видит устройство сразу
  ├─ Кэш всегда актуален
  └─ Устройство найдено с первой попытки
  ↓
[Микрофон открывается за < 200ms]
  └─ Запись начинается без задержек
```

#### Требования к компонентам

**1. Device Detection**
- ✅ **Единый источник истины**: macOS API (SwitchAudioSource) - всегда актуален
- ✅ **Мгновенное обновление кэша**: PortAudio кэш обновляется при каждом запросе
- ✅ **Умный поиск**: система находит устройство даже при небольших различиях в именах
- ✅ **Нет fallback на устаревшие данные**: если устройство не найдено, система ждет его появления

**2. TTL Cache**
- ✅ **Динамический TTL**: для BT устройств TTL = 0 (всегда обновлять), для встроенных TTL = 60s
- ✅ **Автоматическая инвалидация**: кэш обновляется при обнаружении изменений
- ✅ **Предсказуемое поведение**: кэш не влияет на определение устройства

**3. Exponential Backoff**
- ✅ **Только для временных ошибок**: retry только при сетевых/временных проблемах
- ✅ **Быстрый отказ**: если устройство не найдено за 3 попытки, система ждет его появления
- ✅ **Умная задержка**: для BT устройств задержка = 0.5s, для других = 0.1s

### 2.2 Мониторинг изменений устройства

#### Целевое поведение
```
[Устройство подключено/отключено]
  ↓
[Система обнаруживает изменение за < 500ms]
  ├─ Мониторинг работает в реальном времени
  ├─ Изменение обнаружено до начала записи
  └─ Система готова к переключению
  ↓
[Если идет запись]
  ├─ Graceful stop (сохранение данных)
  ├─ Переключение на новое устройство
  └─ Продолжение записи без потери данных
```

#### Требования к компонентам

**1. AudioDeviceMonitor**
- ✅ **Интервал проверки**: 0.2s (для быстрого обнаружения)
- ✅ **Приоритет macOS API**: всегда использует SwitchAudioSource
- ✅ **Умное сравнение**: сравнивает по имени + ID для надежности
- ✅ **Graceful переключение**: останавливает запись без потери данных

**2. Graceful Stop**
- ✅ **Сохранение данных**: все записанные данные сохраняются
- ✅ **Быстрая остановка**: остановка занимает < 100ms
- ✅ **Автоматическое переключение**: система автоматически переключается на новое устройство
- ✅ **Продолжение записи**: запись продолжается на новом устройстве без пауз

### 2.3 Поток записи и распознавания

#### Целевое поведение
```
[LONG_PRESS]
  ↓
[Микрофон открывается за < 200ms]
  ├─ Нет polling - используется событие microphone.opened
  ├─ Нет задержек - устройство найдено сразу
  └─ Поток создается мгновенно
  ↓
[Запись идет без прерываний]
  ├─ Нет ошибок PortAudio
  ├─ Нет потери данных
  └─ Стабильная работа
  ↓
[RELEASE]
  ↓
[Микрофон закрывается за < 100ms]
  ├─ Graceful stop - все данные сохранены
  ├─ Распознавание начинается сразу
  └─ Нет задержек
```

#### Требования к компонентам

**1. InputProcessingIntegration**
- ✅ **События вместо polling**: _wait_for_mic_opened использует событие microphone.opened
- ✅ **Быстрая реакция**: нет задержек между LONG_PRESS и открытием микрофона
- ✅ **Надежная синхронизация**: все состояния синхронизированы через state_manager

**2. VoiceRecognitionIntegration**
- ✅ **Нет deadlock**: request_close не ждет события, которое он сам должен опубликовать
- ✅ **Быстрое открытие**: микрофон открывается за < 200ms
- ✅ **Надежное закрытие**: микрофон закрывается за < 100ms

**3. SpeechRecognizer**
- ✅ **Стабильный поток**: нет ошибок PortAudio (Error 89, Error 35)
- ✅ **Нет потери данных**: все чанки обрабатываются
- ✅ **Быстрое распознавание**: распознавание начинается сразу после закрытия

---

## 3. ИДЕАЛЬНАЯ СИСТЕМА OUTPUT (Динамики)

### 3.1 Определение устройства

#### Целевое поведение
```
[Первый аудио чанк получен]
  ↓
[Система определяет устройство за < 50ms]
  ├─ macOS API возвращает актуальное устройство
  ├─ PortAudio видит устройство сразу
  ├─ Устройство найдено с первой попытки
  └─ Нет проверок при каждом чанке
  ↓
[Поток создается за < 50ms]
  └─ Воспроизведение начинается без задержек
```

#### Требования к компонентам

**1. Device Detection**
- ✅ **Единый источник истины**: macOS API (SwitchAudioSource) - всегда актуален, единственный источник имени устройства
- ✅ **Нет fallback на PortAudio или sd.default.device**: SwitchAudioSource - единственный источник истины, все fallback убраны
- ✅ **Если имя пустое**: сразу return None, ничего не создаём
- ✅ **Для BT устройств**: ВСЕГДА используется device=None (не ищется ID в PortAudio), система полностью полагается на macOS
- ✅ **Умный поиск**: система находит устройство даже при небольших различиях в именах (для поиска ID в PortAudio для обычных устройств)
- ✅ **Проверка только при необходимости**: устройство проверяется только при инициализации и смене
- ✅ **Оптимизированный интервал**: 5.0с для BT устройств, 1.0с для обычных (BT устройства редко меняются)

**2. Lazy Start**
- ✅ **Предварительное создание**: поток создается заранее при инициализации
- ✅ **Быстрое переключение**: при смене устройства поток пересоздается за < 50ms
- ✅ **Нет задержек**: воспроизведение начинается сразу

### 3.2 Мониторинг изменений устройства

#### Целевое поведение
```
[Устройство подключено/отключено]
  ↓
[Система обнаруживает изменение за < 500ms]
  ├─ Мониторинг работает в реальном времени
  ├─ Изменение обнаружено до начала воспроизведения
  └─ Система готова к переключению
  ↓
[Если идет воспроизведение]
  ├─ Сохранение буфера (не очистка)
  ├─ Переключение на новое устройство
  ├─ Продолжение воспроизведения без пауз
  └─ Нет потери данных
```

#### Требования к компонентам

**1. OutputMonitorThread**
- ✅ **Интервал проверки**: 5.0s для BT устройств, 1.0s для обычных (оптимизировано)
- ✅ **Единственный источник истины**: всегда использует SwitchAudioSource (fallback на PortAudio убран)
- ✅ **Для BT устройств**: использует device=None, инициирует `_switch_output_device` с device=None
- ✅ **Умное сравнение**: сравнивает по имени устройства (из SwitchAudioSource)
- ✅ **Безопасное переключение**: переключает устройство с правильными задержками (0.3с для обычных, 2.0с для BT)

**2. Device Switching**
- ✅ **Гарантированное закрытие старого потока**: 
  - stop(), close()
  - цикл while stream_ref.active: sleep(0.02) (таймаут 3с для BT, 1с для обычных)
  - лог "active=False"
  - self._audio_stream=None
  - delay 2с (BT) / 0.3с (обычное) после закрытия
- ✅ **Правильные задержки**: 0.5с для обычных устройств, 2.0с для BT устройств (после закрытия старого потока)
- ✅ **Для BT устройств**: ВСЕГДА используется device=None, без параметров (channels/blocksize/latency) - macOS управляет параметрами
- ✅ **Обработка ошибок**: ошибки -9986/-10851 обрабатываются с повторным вызовом _stop_audio_stream(), созданием stream с device=None, увеличенным backoff (×1.5)
- ✅ **Расширенное логирование**: фиксируется имя старого/нового устройства, тип (BT/обычное), параметры, задержки, ошибки, "старый поток закрыт → создаём новый stream"
- ✅ **Синхронизация с InputProcessingIntegration**: таймаут _ensure_playback_idle() = 5.0с (достаточно для закрытия потока)
- ✅ **Сохранение буфера**: буфер не очищается при переключении (опционально)
- ✅ **Автоматическое продолжение**: воспроизведение продолжается на новом устройстве (lazy start)

### 3.3 Поток воспроизведения

#### Целевое поведение
```
[gRPC audio chunk получен]
  ↓
[Воспроизведение начинается за < 50ms]
  ├─ Поток уже создан (не lazy start)
  ├─ Устройство определено заранее
  └─ Нет проверок при каждом чанке
  ↓
[Воспроизведение идет без прерываний]
  ├─ Нет ошибок PortAudio
  ├─ Нет потери данных
  ├─ Плавное переключение устройств
  └─ Стабильная работа
```

#### Требования к компонентам

**1. SpeechPlaybackIntegration**
- ✅ **Нет проверок при каждом чанке**: устройство проверяется только при необходимости
- ✅ **Быстрое добавление**: add_audio_data работает за < 10ms
- ✅ **Надежная обработка**: все чанки обрабатываются без потерь

**2. SequentialSpeechPlayer**
- ✅ **Предварительное создание потока**: поток создается при инициализации
- ✅ **Быстрое переключение**: переключение устройства занимает < 100ms
- ✅ **Сохранение буфера**: буфер сохраняется при переключении
- ✅ **Стабильный поток**: нет ошибок PortAudio

---

## 4. ИДЕАЛЬНАЯ СИСТЕМА ОПРЕДЕЛЕНИЯ УСТРОЙСТВ

### 4.1 Единый источник истины

#### Целевое поведение
```
[Запрос определения устройства]
  ↓
[macOS API (SwitchAudioSource) - ПРИОРИТЕТ 1]
  ├─ Всегда актуальное устройство
  ├─ Работает для всех типов устройств (встроенные, USB, BT)
  ├─ Возвращает имя устройства
  └─ Время ответа < 50ms
  ↓
[PortAudio - только для получения ID]
  ├─ Используется только для поиска ID по имени
  ├─ Кэш обновляется при каждом запросе
  ├─ Устройство найдено с первой попытки
  └─ Время поиска < 50ms
  ↓
[Результат: имя + ID за < 100ms]
```

#### Требования

**1. macOS API (SwitchAudioSource)**
- ✅ **Всегда доступен**: система проверяет наличие перед использованием
- ✅ **Быстрый ответ**: время ответа < 50ms
- ✅ **Надежность**: работает для всех типов устройств
- ✅ **Единый формат**: всегда возвращает имя в одном формате

**2. PortAudio**
- ✅ **Обновление кэша**: кэш обновляется при каждом запросе (sd._terminate() + sd._initialize())
- ✅ **Быстрый поиск**: поиск ID по имени занимает < 50ms
- ✅ **Умный поиск**: находит устройство даже при небольших различиях в именах
- ✅ **Нет устаревших данных**: система не использует устаревший кэш

**3. Кэширование**
- ✅ **Динамический TTL**: для BT устройств TTL = 0, для других TTL = 60s
- ✅ **Автоматическая инвалидация**: кэш обновляется при обнаружении изменений
- ✅ **Предсказуемое поведение**: кэш не влияет на определение устройства

### 4.2 Обработка Bluetooth устройств

#### Целевое поведение
```
[BT устройство подключено]
  ↓
[Система обнаруживает устройство за < 1s]
  ├─ macOS API видит устройство сразу
  ├─ PortAudio обновляет кэш автоматически
  ├─ Устройство найдено с первой попытки
  └─ Нет задержек
  ↓
[Система готова к использованию]
  ├─ Устройство определено
  ├─ Параметры нормализованы
  └─ Поток может быть создан
```

#### Требования

**1. Обнаружение**
- ✅ **Быстрое обнаружение**: устройство обнаруживается за < 1s после подключения
- ✅ **Автоматическое обновление**: PortAudio кэш обновляется автоматически
- ✅ **Нет задержек**: система не ждет стабилизации устройства

**2. Инициализация**
- ✅ **Предварительная задержка**: для BT устройств задержка = 0.5s перед созданием потока
- ✅ **Быстрое создание**: поток создается за < 100ms после задержки
- ✅ **Стабильная работа**: нет ошибок PortAudio (Error 89, Error 35)

**3. Переключение**
- ✅ **Быстрое переключение**: переключение на BT устройство занимает < 200ms
- ✅ **Нет потери данных**: данные не теряются при переключении
- ✅ **Автоматическое продолжение**: работа продолжается на новом устройстве

---

## 5. ИДЕАЛЬНАЯ СИСТЕМА ОБРАБОТКИ ОШИБОК

### 5.1 Восстановление после ошибок

#### Целевое поведение
```
[Ошибка PortAudio (Error 89, Error 35)]
  ↓
[Система обнаруживает ошибку]
  ├─ Ошибка логируется
  ├─ Поток останавливается
  └─ Система пытается восстановиться
  ↓
[Восстановление]
  ├─ Обновление кэша PortAudio
  ├─ Повторное определение устройства
  ├─ Создание нового потока
  └─ Продолжение работы
  ↓
[Работа восстановлена за < 500ms]
  └─ Пользователь не замечает ошибки
```

#### Требования

**1. Обнаружение ошибок**
- ✅ **Все ошибки логируются**: каждая ошибка логируется с контекстом
- ✅ **Быстрое обнаружение**: ошибка обнаруживается сразу
- ✅ **Классификация**: ошибки классифицируются по типу и критичности

**2. Восстановление**
- ✅ **Автоматическое восстановление**: система восстанавливается автоматически
- ✅ **Быстрое восстановление**: восстановление занимает < 500ms
- ✅ **Нет потери данных**: данные не теряются при восстановлении
- ✅ **Прозрачность**: пользователь не замечает ошибки

**3. Fallback**
- ✅ **Умный fallback**: система использует fallback только при необходимости
- ✅ **Быстрый fallback**: fallback активируется за < 100ms
- ✅ **Надежный fallback**: fallback всегда работает

### 5.2 Обработка временных проблем

#### Целевое поведение
```
[Временная проблема (сеть, устройство)]
  ↓
[Система обнаруживает проблему]
  ├─ Проблема логируется
  ├─ Система ждет восстановления
  └─ Пользователь уведомляется (опционально)
  ↓
[Восстановление]
  ├─ Система автоматически продолжает работу
  ├─ Нет потери данных
  └─ Работа восстановлена
```

#### Требования

**1. Обнаружение**
- ✅ **Быстрое обнаружение**: проблема обнаруживается сразу
- ✅ **Классификация**: проблемы классифицируются по типу
- ✅ **Умное ожидание**: система ждет восстановления только для временных проблем

**2. Восстановление**
- ✅ **Автоматическое восстановление**: система восстанавливается автоматически
- ✅ **Нет потери данных**: данные не теряются
- ✅ **Прозрачность**: пользователь не замечает проблемы

---

## 6. ИДЕАЛЬНАЯ СИСТЕМА СИНХРОНИЗАЦИИ

### 6.1 Синхронизация состояний

#### Целевое поведение
```
[Изменение состояния]
  ↓
[Все компоненты синхронизированы]
  ├─ state_manager - единый источник истины
  ├─ Все компоненты читают из state_manager
  ├─ Нет рассинхронизации
  └─ Состояния всегда согласованы
```

#### Требования

**1. Единый источник истины**
- ✅ **state_manager**: все состояния хранятся в state_manager
- ✅ **Нет дублирования**: нет дублирования состояний в компонентах
- ✅ **Атомарные операции**: все операции с состояниями атомарны

**2. Синхронизация**
- ✅ **События**: все изменения состояния публикуются через события
- ✅ **Подписки**: все компоненты подписаны на нужные события
- ✅ **Нет race conditions**: все операции синхронизированы

### 6.2 Синхронизация устройств

#### Целевое поведение
```
[Изменение устройства]
  ↓
[Все компоненты знают о изменении]
  ├─ Мониторинг обнаруживает изменение
  ├─ Событие публикуется
  ├─ Все компоненты обновляются
  └─ Нет рассинхронизации
```

#### Требования

**1. Обнаружение**
- ✅ **Быстрое обнаружение**: изменение обнаруживается за < 500ms
- ✅ **Надежное обнаружение**: изменение всегда обнаруживается
- ✅ **Точное обнаружение**: изменение обнаруживается точно

**2. Синхронизация**
- ✅ **События**: изменение публикуется через события
- ✅ **Подписки**: все компоненты подписаны на изменения
- ✅ **Атомарность**: все обновления атомарны

---

## 7. КРИТЕРИИ УСПЕХА

### 7.1 Метрики производительности

#### INPUT
- ✅ **Время определения устройства**: < 100ms (p95)
- ✅ **Время открытия микрофона**: < 200ms (p95)
- ✅ **Время закрытия микрофона**: < 100ms (p95)
- ✅ **Время переключения устройства**: < 200ms (p95)
- ✅ **Процент успешных открытий**: > 99%
- ✅ **Процент успешных переключений**: > 99%

#### OUTPUT
- ✅ **Время определения устройства**: < 50ms (p95)
- ✅ **Время начала воспроизведения**: < 50ms (p95)
- ✅ **Время переключения устройства**: < 100ms (p95)
- ✅ **Процент успешных запусков**: > 99%
- ✅ **Процент успешных переключений**: > 99%

### 7.2 Метрики надежности

- ✅ **Процент успешных определений устройств**: 100%
- ✅ **Процент успешных восстановлений после ошибок**: > 95%
- ✅ **Количество ошибок PortAudio**: 0 (в нормальной работе)
- ✅ **Количество потерянных данных**: 0

### 7.3 Метрики пользовательского опыта

- ✅ **Прозрачность переключений**: пользователь не замечает переключений
- ✅ **Предсказуемость**: система всегда работает одинаково
- ✅ **Отсутствие ошибок**: нет сообщений об ошибках для пользователя
- ✅ **Автоматизация**: система сама управляет устройствами

---

## 8. СХЕМА ИДЕАЛЬНОЙ РАБОТЫ СИСТЕМЫ

```mermaid
graph TB
    subgraph "ИДЕАЛЬНЫЙ INPUT FLOW"
        K1[LONG_PRESS] -->|0ms| D1[Определение устройства]
        D1 -->|50ms| API1[macOS API]
        API1 -->|50ms| PA1[PortAudio ID]
        PA1 -->|50ms| O1[Открытие микрофона]
        O1 -->|100ms| R1[Запись]
        R1 -->|Без прерываний| RE1[RELEASE]
        RE1 -->|50ms| C1[Закрытие]
        C1 -->|50ms| REC1[Распознавание]
    end
    
    subgraph "ИДЕАЛЬНЫЙ OUTPUT FLOW"
        G1[gRPC chunk] -->|0ms| D2[Определение устройства]
        D2 -->|50ms| API2[macOS API]
        API2 -->|50ms| PA2[PortAudio ID]
        PA2 -->|0ms| P1[Поток уже создан]
        P1 -->|0ms| PLAY1[Воспроизведение]
        PLAY1 -->|Без прерываний| END1[Завершение]
    end
    
    subgraph "ИДЕАЛЬНЫЙ МОНИТОРИНГ"
        M1[Мониторинг] -->|0.2s INPUT, 0.5s OUTPUT| DET1[Обнаружение изменения]
        DET1 -->|100ms| SW1[Переключение]
        SW1 -->|Без потери данных| CONT1[Продолжение работы]
    end
    
    style K1 fill:#e1f5ff
    style G1 fill:#fff4e1
    style M1 fill:#f0f0f0
    style D1 fill:#ffe1f5
    style D2 fill:#ffe1f5
    style DET1 fill:#ffe1f5
```

---

## 9. ПУТЬ К ИДЕАЛЬНОМУ СОСТОЯНИЮ

### Этап 1: Исправление критических проблем (Приоритет 1)
- ✅ Исправлен deadlock в request_close
- ⚠️ Добавить задержку перед поиском BT устройств
- ⚠️ Улучшить обработку ошибок PortAudio
- ⚠️ Добавить автоматическое восстановление после ошибок

### Этап 2: Оптимизация производительности (Приоритет 2)
- ⚠️ Оптимизировать проверку устройств OUTPUT (только фоновый мониторинг)
- ⚠️ Использовать события вместо polling для _wait_for_mic_opened
- ⚠️ Предварительное создание потока OUTPUT
- ⚠️ Сохранение буфера при переключении OUTPUT

### Этап 3: Улучшение надежности (Приоритет 3)
- ⚠️ Добавить состояние SWITCHING для предотвращения новых операций
- ⚠️ Улучшить graceful stop (увеличить таймауты для BT)
- ⚠️ Добавить предварительную проверку доступности устройства
- ⚠️ Улучшить обработку временных проблем

### Этап 4: Достижение идеального состояния (Приоритет 4)
- ⚠️ Достичь всех метрик производительности
- ⚠️ Достичь всех метрик надежности
- ⚠️ Достичь всех метрик пользовательского опыта
- ⚠️ Полная автоматизация управления устройствами

---

## 10. ЗАКЛЮЧЕНИЕ

Идеальная система аудио должна:
1. **Работать прозрачно** - пользователь не замечает переключений устройств
2. **Быть надежной** - нет ошибок, нет потери данных
3. **Быть быстрой** - все операции выполняются за минимальное время
4. **Быть автоматической** - система сама управляет устройствами

Текущая система уже имеет хорошую архитектуру, но требует улучшений в:
- Определении устройств (особенно BT)
- Обработке ошибок и восстановлении
- Оптимизации производительности
- Синхронизации состояний

Достижение идеального состояния требует поэтапной реализации улучшений с приоритетом на критичные проблемы.



