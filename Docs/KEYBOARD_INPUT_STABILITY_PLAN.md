# Keyboard Input Stability Plan

## Цель
Обеспечить устойчивую работу клавиш и комбинаций (Ctrl+N) без щелчков, залипаний, потери фокуса и неотзывчивости: сбор данных → фильтрация повторов → управление состоянием → тесты.

## Проблемы
1. **Повторный щелчок** при удержании N: Quartz пропускает `return None` только в отдельных условиях и пропускает autorepeat.  
2. **"Залипание" состояния**: при пропущенном `keyUp` `_n_pressed` остаётся True, и следующие `keyDown` считаются автоповтором.

## Требования
- Всегда подавлять autorepeat `keyDown(N)` внутри комбинации (независимо от Control), но обновлять таймер.  
- При `keyUp` сбрасывать состояние `_n_pressed`, `_combo_active`, `_long_sent`.  
- Добавить watchdog: если прошло `key_state_timeout_sec` без событий, принудительно сбросить состояние.  
- При `flagsChanged` всегда обновлять `_control_pressed`/`_control_last_event_time`.  
- Возвращать `None` из callback, чтобы macOS не получала лишние щелчки и фокус не слетал.

## Компоненты
1. `QuartzKeyboardMonitor._handle_combo_event`
2. `KeyboardMonitor` (взаимодействие с event loop)
3. Вспомогательные таймауты и логирование (`_reset_combo_state`, `_event_processed`)

## Шаги реализации
1. Добавить строгую блокировку autorepeat:
   * если `_n_pressed` и event == `keyDown`, возвращать `None`, обновляя `_n_last_event_time`.
2. При любых `keyUp`/`flagsChanged` — сбрасывать `_n_pressed`/ `_combo_active`.
3. Реализовать watchdog: запускать `threading.Timer` или проверку `self.last_event_time` в `_check_and_reset_stuck_state`, если прошло > `key_state_timeout_sec` — сбрасывать флаги.
4. Добавить логгирование (`logger.debug`) при каждом сбросе состояния и подавлении события.
5. Проверить, что callback `return event`/`return None` работает для `kCGEventTapOptionListenOnly`.

## Тесты и проверка
- Держать Ctrl+N → никаких щелчков, фокус остаётся в приложении  
- Быстрые короткие нажатия → смесь short/long срабатывает  
- Имитация пропуска `keyUp`: вручную сбрасывать `_n_pressed` после таймаута  
- Проверить, что `input_processing` реагирует каждый раз без задержки

## Ожидаемый результат
- Удержание не генерирует повторных кликов, сочетание реагирует один раз  
- Потеря `keyUp` не блокирует последующие события (watchdog сбрасывает)  
- Логика input не получает лишних `keyDown`, поэтому приложения не теряют фокус

-## Дальнейшие шаги
- Если понадобится, расширить анализ громкости/датчиков  
- При возникновении новых проблем пересмотреть таймауты  
- Пройти циклы: 1) блокировка автоповтора, 2) сброс keyUp/flagsChanged, 3) watchdog, 4) интеграция с input_processing
- Добавить цикл по изменениям: реализовать и проверять каждый шаг (автоповтор, keyUp/flagsChanged, watchdog, интеграция с input)
