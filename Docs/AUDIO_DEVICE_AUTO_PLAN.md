# План внедрения автоматического переключения аудио устройств

## 1. Цель
Сделать систему такой, чтобы:
- macOS-системный default всегда считался источником правды (имя устройства, частота, каналы);
- при подключении/отключении Bluetooth-девайсов приложение автоматически подстраивалось под новый маршрут без перезапуска;
- текущие потоки (input/output) пересоздавались безопасно, не уничтожая PortAudio полностью;
- все параметры нормализовались под требования Nexy (моно для ASR, максимум стерео для воспроизведения).

## 2. Текущие лимиты
- PortAudio кэширует список устройств и редко обновляется без `sd._terminate()`, поэтому в первые секунды после подключения BT он отдаёт старые ID.
- `_safe_refresh_portaudio_cache` сейчас просто логирует необходимость перезапуска, то есть новые устройства остаются невидимыми до рестарта.
- Монитор `_monitor_loop` полагается на polling (0.5 с) и `SwitchAudioSource`, но не имеет механизма повторного опроса при промахе name→ID.
- Потоки создаются только один раз, и при смене default они могут остаться привязанными к несуществующему устройству.

## 3. Критерии идеальной системы
1. **Истина по имени:** `SwitchAudioSource` (или эквивалент) всегда основа, `sd.query_devices()` подтягивается через повторные попытки/TTL.
2. **Автоматическое определение параметров:** система должна фиксировать частоту (гигагерцы/герцы), число каналов, индекс (ID) устройства и его имя, чтобы без ручной настройки выставлять поток в соответствии с этим устройством.
3. **Надёжность потоков:** при смене default output воспроизводится новый поток, старый корректно закрывается, `sd._terminate()` не вызывается; input-поток пересоздаётся только после штатной остановки записи (или когда `RecognitionState != LISTENING`), чтобы не нарушать текущую архитектуру.
4. **Нормализация:** параметры устройства (частота, каналы) приводятся к конфигу через `DeviceParamsNormalizer`.
5. **Диагностика:** логируется состояние кэша, retries, отклонения, и пользователь получает подсказку, если PortAudio не видит устройство.
6. **Recovery:** при ошибках (Error 89/35 и др.) есть retry/backoff, а не простой crash.

## 4. Техническая стратегия
1. **Кэш имени→ID**
   - Добавить TTL и ручную инвалидацию (`_invalidate_device_cache()`) при смене системного default.
   - При промахе `SwitchAudioSource` выполнять повторные `sd.query_devices()` с экспоненциальной задержкой (0.3 с, 0.6 с, 1.2 с).
   - Хранить мета о том, когда последний раз обновлялся кэш, чтобы не полагаться на `sd._terminate()`.
2. **Мониторинг**
   - В `AudioDeviceMonitor` добавлять повторные попытки поиска ID при `SwitchAudioSource` возвращает имя, но `sd.query_devices()` не найдёт его сразу.
   - По смене имени — сразу помечать кэш невалидным и готовить пересоздание потока, при этом для input ждём, пока запись завершится (или отключаем поток вручную).
3. **Пересоздание потоков**
   - При смене default output вызывать общую функцию «invalidate + recreate stream», которая:
     * проверяет текущий UUID/имя;
     * вызывает `_stop_audio_stream`/`_current_stream.stop()` с `RLock`;
     * обновляет конфигурацию через `DeviceParamsNormalizer`;
     * и стартует новый поток с задержкой `bt_prestart_delay` для BT.
   - Для input: такую же функцию вызываем только после того, как состояние не LISTENING и поток остановлен.
4. **Retries и backoff**
   - Для BT-устройств иметь 5–7 попыток запуска потока с ростом задержки (0.8 с → 1.2 с → 1.8 с), и только после успеха сбрасывать retry-счётчик.
   - Запуск в обеих подсистемах (вход и вывод) должен логировать попытки и причину (`Error 89`, `Error 35` и т.д.).

## 5. Дорожная карта (по фазам)
### Фаза 1 — сбор текущих данных и прототип
1. Протестировать сценарии подключения/отключения Bluetooth и собрать логи retry/ошибок (Error 89/35) и cache misses.
2. Проверить, в каких случаях `SwitchAudioSource` и `sd.query_devices()` расходятся по имени/ID.
3. Создать тестовый prototype-репозиторий/директорию (готово: `test_audio_output/prototype/`) с упрощённой версией логики (кэш, retry, мониторинг), чтобы безопасно отрабатывать сценарии смены устройств и параметров (частота, каналы, ID).
4. Зафиксировать baseline (тесты, результаты `BASELINE_RESULTS.md`, мониторинг) — использовать как reference перед переносом.

### Фаза 2 — автоматическое определение параметров
3. Добавить TTL/инвалидацию `_device_name_to_id_cache` и повторные `sd.query_devices()` (0.3/0.6/1.2 с) при промахе имени.
4. Фиксировать для каждого устройства частоту, число каналов, ID и имя; использовать их без ручных настроек.

### Фаза 3 — управление потоками и сохранение архитектуры INPUT
5. При смене default output вызывать `invalidate cache → stop stream → normalize params → start new stream`, учитывая `bt_prestart_delay` и log нового устройства.
6. Для input: пересоздавать поток только если запись не идёт (`RecognitionState != LISTENING`) или после её остановки; если запись активна, сохранять текущий поток и применять новый default только после безопасной остановки.
7. Убедиться, что пересоздание потоков не вызывает `sd._terminate()` и логирует новую конфигурацию.

### Фаза 4 — retry, диагностика и тесты
7. Реализовать retry/backoff (5-7 попыток, растущая задержка) для BT-потоков и логировать каждую попытку.
8. Написать unit-тесты с моками (`sd.query_devices`, `SwitchAudioSource`) и интеграционные проверки с реальными BT-наушниками.
9. Подготовить «прямой эфир» тест-скрипт, который будет периодически отслеживать текущее подключение устройств (частота, ID, каналы) и подтверждать, что новым устройствам автоматически назначаются потоки; использовать его для продления тестов (60+ сек).

### Фаза 5 — Фоновый мониторинг output устройства (РЕАЛИЗОВАНО)
10. ✅ **Добавлен фоновый мониторинг системного default output**:
    - Периодический таймер (1 сек) для проверки смены устройства
    - Использование `_query_system_default_output()` для получения имени и PortAudio ID
    - SwitchAudioSource для получения имени (приоритет 1)
    - Fallback на PortAudio если SwitchAudioSource недоступен
    - Сравнение имени и ID устройства под замком `_output_monitor_lock`
    - Автоматическое обнаружение смены устройства
11. ✅ **Безопасное переключение output устройства** (`_switch_output_device`):
    - Установка `_stop_event` для остановки воспроизведения
    - Остановка и закрытие `_audio_stream` под `_stream_lock`
    - Ожидание завершения `_playback_thread` (timeout 1.0 сек)
    - Очистка буфера через `chunk_buffer.clear_all()`
    - Обновление параметров через `DeviceParamsNormalizer` (channels, sample_rate)
    - Обновление `chunk_buffer.set_channels()` при смене каналов
    - Обновление tracking полей (`output_device_name`, `_current_output_device_id`, `_last_device_check_time`)
    - Сброс `_stop_event` для следующего воспроизведения
    - Lazy start потока (создастся при следующем `add_audio_data()`)
12. ✅ **Логирование и диагностика**:
    - Логирование смены устройства с указанием старого/нового имени и ID: `"старое" (ID=old_id) → "новое" (ID=new_id)`
    - Логирование всех этапов переключения (остановка потока, очистка буфера, нормализация параметров)
    - Логирование ошибок при переключении устройства
    - Логирование первого устройства при инициализации

## 6. Проверка и валидация
- Запуск скриптов, пробующих подключить/отключить BT-гарнитуру и проверку логов о retry/новом `device_id`.
- Тесты: симуляция `SwitchAudioSource` → `sd.query_devices()` с задержкой и убеждение, что приложение ждёт новый ID.
- Добавить unit/интеграционные тесты для ключевых функций (`_find_device_id_by_name_input`, `_on_device_changed`, `_check_and_update_output_device`) с mocking-ом `sd.query_devices()`.
- Наблюдение за metrics (если есть) или логами, чтобы убедиться, что нет ошибок “device not found” после переключения.

## 7. Следующие шаги
1. Согласовать приоритеты: сначала cache/retry или потоки?  
2. Разработать конкретные изменённые функции и интерфейсы логирования.  
3. Начать реализацию по шагам (1 → 5 из раздела 5) и проверку на реальных BT-девайсах.

## 8. Обновление: участки кода под изменения и интеграции
1. **`modules/voice_recognition/core/speech_recognizer.py`**
   - `_device_name_to_id_cache`, `_refresh_device_cache`, `_invalidate_device_cache`: добавить TTL/мета, логировать статус и помечать устаревшими при смене default.
   - `_find_device_id_by_name_input()`: внедрить экспоненциальный retry (`sd.query_devices()` с задержками), фиксировать частоту/каналы/ID при удаче.
   - `_on_device_changed()`: после `RecognitionState != LISTENING` вызывать «invalidate → stop stream → recreate с `DeviceParamsNormalizer`», иначе просто логировать и помечать кэш устаревшим.
   - `_start_audio_stream()` и helper-методы: использовать общую retry-функцию с backoff, нормализовать параметры перед запуском, учитывать `bt_prestart_delay`.
2. **`modules/voice_recognition/core/audio_device_monitor.py`**
   - `_get_device_via_macos_api()`: добавить повторные попытки поиска ID, логировать прогресс и обновлять кэш только после успешного маппинга.
   - `_monitor_loop()`: при смене имени вызывать `_invalidate_device_cache()` и инициировать `_on_device_changed`, если запись не идёт.
3. **`modules/speech_playback/core/player.py`**
   - ✅ **РЕАЛИЗОВАНО**: Фоновый мониторинг системного default output устройства (периодический таймер 1 сек)
     - `_query_system_default_output()`: получение имени и PortAudio ID текущего системного default output (SwitchAudioSource приоритет 1, PortAudio fallback)
     - `_get_output_device_name_via_macos_api()`: получение имени устройства через SwitchAudioSource
     - `_find_device_id_by_name()`: поиск PortAudio ID устройства по имени
     - `_start_output_monitoring()`: запуск фонового потока мониторинга
     - `_stop_output_monitoring()`: остановка фонового потока
     - `_output_monitor_loop()`: основной цикл мониторинга с периодической проверкой устройства (сравнение имени и ID)
     - `_switch_output_device(new_name, new_id)`: безопасное переключение устройства:
       * Установка `_stop_event` для остановки воспроизведения
       * Остановка и закрытие `_audio_stream`
       * Ожидание завершения `_playback_thread`
       * Очистка буфера
       * Обновление параметров через `DeviceParamsNormalizer` (channels, sample_rate)
       * Обновление `chunk_buffer.set_channels()` при смене каналов
       * Обновление tracking полей (`output_device_name`, `_current_output_device_id`)
       * Сброс `_stop_event` для следующего воспроизведения
       * Логирование старого/нового имени и ID
   - `_check_and_update_output_device()`: ✅ **ОБНОВЛЕНО** - использует SwitchAudioSource (приоритет 1) с fallback на PortAudio
   - `_start_audio_stream()`: получить параметры через `DeviceParamsNormalizer`, логировать и добавлять 5–7 попыток с экспоненциальным delay.
   - `_query_default_output_device()`: логировать частоту/каналы/ID и возвращать данные для нормализатора.
4. **`modules/audio_core/device_params_normalizer.py`**
   - Убедиться, что `select_input_params`/`select_output_params` возвращают rate/channels, которые используют `SpeechRecognizer`/`SequentialSpeechPlayer`; добавить helper по преобразованию info → norm params.
5. **Тесты и интеграции**
   - Новые unit-тесты: мок `sd.query_devices()`/`SwitchAudioSource` для `_find_device_id_by_name_input`, `_on_device_changed`, `_check_and_update_output_device`.
   - Интеграционные сценарии: ручное подключение/отключение Bluetooth с проверкой логов retry/новых ID.
   - Документировать влияние на UI/иконки/режимы (меню-бар, индикаторы записи, переходы состояний), чтобы при переносе убедиться, что новые сигналы не нарушают текущий UX.
