# Поэтапный план реализации идеальной системы аудио

## Дата создания
2025-11-30

## Цель документа

Детальный поэтапный план реализации идеальной системы аудио с маленькими, тестируемыми шагами. Каждый шаг должен быть:
- ✅ **Независимым** - может быть реализован и протестирован отдельно
- ✅ **Измеримым** - есть четкие критерии готовности
- ✅ **Безопасным** - не ломает существующую функциональность
- ✅ **Тестируемым** - есть способы проверить результат

---

## ОБЩАЯ СТРАТЕГИЯ

### Принципы реализации
1. **Снизу вверх** - сначала исправляем базовые проблемы, потом оптимизируем
2. **Изоляция** - каждый шаг изолирован и не влияет на другие
3. **Тестирование** - после каждого шага запускаем тесты
4. **Откат** - каждый шаг можно откатить без последствий

### Порядок приоритетов
1. **Критичные проблемы** - то, что ломает работу (deadlock, ошибки PortAudio)
2. **Надежность** - то, что делает систему стабильной (восстановление, обработка ошибок)
3. **Производительность** - то, что делает систему быстрой (оптимизация, кэширование)
4. **UX** - то, что улучшает опыт пользователя (прозрачность, автоматизация)

---

## ЭТАП 1: ИСПРАВЛЕНИЕ КРИТИЧНЫХ ПРОБЛЕМ

### Шаг 1.1: Улучшение определения устройств INPUT (macOS API приоритет)

**Цель:** Убедиться, что система всегда использует macOS API как источник истины для INPUT устройств.

**Задачи:**
1. Проверить, что `_get_system_default_input_name()` всегда вызывается первым
2. Улучшить обработку ошибок при недоступности SwitchAudioSource
3. Добавить логирование всех доступных устройств при неудачном поиске
4. Улучшить fallback на PortAudio (добавить retry)

**Файлы для изменения:**
- `modules/voice_recognition/core/speech_recognizer.py`
  - `_get_system_default_input_index()`
  - `_get_system_default_input_name()`
  - `_find_device_id_by_name_input()`

**Критерии готовности:**
- ✅ macOS API всегда вызывается первым (логи подтверждают)
- ✅ При недоступности SwitchAudioSource используется fallback
- ✅ При неудачном поиске логируются все доступные устройства
- ✅ Система находит устройство с первой попытки в 95% случаев

**Тесты:**
- [ ] Unit-тест: мок SwitchAudioSource → проверка приоритета
- [ ] Unit-тест: мок недоступности SwitchAudioSource → проверка fallback
- [ ] Интеграционный тест: реальное устройство → проверка определения
- [ ] Ручной тест: подключение BT наушников → проверка определения

**Риски:**
- ⚠️ SwitchAudioSource может быть недоступен → нужен надежный fallback
- ⚠️ Имя устройства может отличаться → нужен умный поиск

**Время:** 2-3 часа

---

### Шаг 1.2: Улучшение определения устройств OUTPUT (macOS API приоритет) ✅ ЗАВЕРШЕН

**Цель:** Убедиться, что система всегда использует macOS API как источник истины для OUTPUT устройств.

**Задачи:**
1. ✅ Проверить, что `_get_output_device_name_via_macos_api()` всегда вызывается первым
2. ✅ Убрать fallback на PortAudio - SwitchAudioSource единственный источник истины
3. ✅ Добавить логирование всех доступных устройств при неудачном поиске
4. ✅ Улучшить частичное совпадение имени (уже реализовано, проверено)

**Файлы для изменения:**
- `modules/speech_playback/core/player.py`
  - `_check_and_update_output_device()` - убран fallback на PortAudio
  - `_output_monitor_loop()` - использует только SwitchAudioSource
  - `_get_output_device_name_via_macos_api()` - единственный источник истины
  - `_find_device_id_by_name()` - используется только для поиска ID, не для определения устройства

**Критерии готовности:**
- ✅ macOS API всегда вызывается первым (логи подтверждают)
- ✅ Fallback на PortAudio убран - SwitchAudioSource единственный источник истины
- ✅ При неудачном поиске логируются все доступные устройства
- ✅ Частичное совпадение работает корректно
- ✅ Система находит устройство с первой попытки в 95% случаев
- ✅ Для BT устройств используется device=None (не ищется ID в PortAudio)

**Реализовано:**
- ✅ `_check_and_update_output_device()` использует только SwitchAudioSource
- ✅ `_output_monitor_loop()` использует только SwitchAudioSource для определения устройства
- ✅ Для BT устройств используется device=None, ID не ищется в PortAudio
- ✅ Оптимизирован интервал проверки: 5.0с для BT, 1.0с для обычных устройств

**Тесты:**
- [x] Ручной тест: подключение BT наушников → проверка определения (успешно)
- [ ] Unit-тест: мок SwitchAudioSource → проверка приоритета
- [ ] Unit-тест: мок недоступности SwitchAudioSource → проверка обработки ошибки
- [ ] Интеграционный тест: реальное устройство → проверка определения

**Риски:**
- ⚠️ SwitchAudioSource может быть недоступен → система возвращает False, не использует fallback
- ⚠️ Имя устройства может отличаться → частичное совпадение должно работать

**Время:** 2-3 часа (завершено 2025-12-01)

---

### Шаг 1.2.1: Мониторинг дефолтного OUTPUT и безопасное переключение ✅ ЗАВЕРШЕН

**Цель:** Реализовать периодический мониторинг OUTPUT устройств с безопасным переключением потоков.

**Задачи:**
1. ✅ Убедиться, что SwitchAudioSource - единственный источник истины (убрать fallback на PortAudio)
2. ✅ Добавить периодический мониторинг OUTPUT устройств через `_output_monitor_loop`
3. ✅ Реализовать безопасное переключение потоков с правильными задержками
4. ✅ Улучшить обработку ошибок -9986/-10851 с device=None для BT устройств
5. ✅ Расширить логирование всех параметров и ошибок

**Файлы для изменения:**
- `modules/speech_playback/core/player.py`
  - `_check_and_update_output_device()` - убран fallback на PortAudio
  - `_output_monitor_loop()` - использует только SwitchAudioSource, инициирует `_switch_output_device` с device=None для BT
  - `_switch_output_device()` - безопасное переключение с задержками (0.3с для обычных, 2.0с для BT)
  - `_start_audio_stream()` - проверка закрытия старого потока, обработка -9986/-10851 с device=None

**Критерии готовности:**
- ✅ SwitchAudioSource - единственный источник истины (fallback на PortAudio убран)
- ✅ Периодический мониторинг OUTPUT устройств работает (интервал: 5.0с для BT, 1.0с для обычных)
- ✅ Безопасное переключение потоков: старый поток закрыт, задержки соблюдены
- ✅ Ошибки -9986/-10851 обрабатываются с device=None для BT устройств
- ✅ Расширенное логирование: имя старого/нового устройства, тип (BT/обычное), параметры, задержки, ошибки

**Реализовано:**
- ✅ `_check_and_update_output_device()` использует только SwitchAudioSource, без fallback
- ✅ `_output_monitor_loop()` использует только SwitchAudioSource, для BT использует device=None
- ✅ `_switch_output_device()` безопасно переключает потоки с задержками (0.3с/2.0с)
- ✅ `_start_audio_stream()` проверяет закрытие старого потока, обрабатывает -9986/-10851
- ✅ Расширенное логирование всех параметров и ошибок

**Тесты:**
- [x] Ручной тест: MacBook → AirPods (успешно)
- [x] Ручной тест: AirPods → MacBook (успешно)
- [ ] Ручной тест: быстрые переключения (требуется)
- [ ] Ручной тест: отключение AirPods во время воспроизведения (требуется)

**Риски:**
- ⚠️ Переключение может быть медленным для BT устройств (2.0с задержка) → приемлемо для надежности
- ⚠️ Ошибки -9986/-10851 могут повторяться → обрабатываются с device=None и моно

**Время:** 4-5 часов (завершено 2025-12-01)

---

### Шаг 1.3: Принудительное обновление кэша PortAudio

**Цель:** Убедиться, что PortAudio кэш всегда актуален, особенно для BT устройств.

**Задачи:**
1. Добавить функцию принудительного обновления кэша PortAudio
2. Вызывать обновление при неудачном поиске устройства
3. Вызывать обновление при обнаружении нового устройства через macOS API
4. Добавить логирование обновления кэша

**Файлы для изменения:**
- `modules/voice_recognition/core/speech_recognizer.py`
  - `_refresh_portaudio_cache_force()` (новая функция)
  - `_find_device_id_by_name_input()` - вызов обновления при неудаче
- `modules/voice_recognition/core/audio_device_monitor.py`
  - `_get_device_via_macos_api()` - вызов обновления при обнаружении нового устройства
- `modules/speech_playback/core/player.py`
  - `_find_device_id_by_name()` - вызов обновления при неудаче

**Критерии готовности:**
- ✅ Функция обновления кэша работает корректно (sd._terminate() + sd._initialize())
- ✅ Кэш обновляется при неудачном поиске устройства
- ✅ Кэш обновляется при обнаружении нового устройства
- ✅ После обновления устройство находится в PortAudio

**Тесты:**
- [ ] Unit-тест: мок sd._terminate() и sd._initialize() → проверка вызовов
- [ ] Интеграционный тест: подключение BT устройства → проверка обновления кэша
- [ ] Ручной тест: подключение BT наушников → проверка определения после обновления

**Риски:**
- ⚠️ sd._terminate() может вызвать проблемы с активными потоками → обновлять только когда нет активных потоков
- ⚠️ Обновление кэша может быть медленным → делать асинхронно или с таймаутом

**Время:** 3-4 часа

---

### Шаг 1.4: Улучшение обработки ошибок PortAudio

**Цель:** Система должна автоматически восстанавливаться после ошибок PortAudio.

**Задачи:**
1. Добавить обработку ошибок Error 89, Error 35
2. Добавить автоматическое восстановление потока после ошибки
3. Добавить логирование всех ошибок с контекстом
4. Добавить retry с exponential backoff при восстановлении

**Файлы для изменения:**
- `modules/voice_recognition/core/speech_recognizer.py`
  - `_start_audio_stream()` - обработка ошибок
  - `_handle_portaudio_error()` (новая функция)
- `modules/speech_playback/core/player.py`
  - `_start_audio_stream()` - обработка ошибок
  - `_handle_portaudio_error()` (новая функция)

**Критерии готовности:**
- ✅ Ошибки Error 89, Error 35 обрабатываются корректно
- ✅ Система автоматически восстанавливается после ошибки
- ✅ Восстановление занимает < 500ms
- ✅ Все ошибки логируются с контекстом

**Тесты:**
- [ ] Unit-тест: мок ошибки PortAudio → проверка обработки
- [ ] Unit-тест: мок восстановления → проверка retry
- [ ] Интеграционный тест: симуляция ошибки → проверка восстановления
- [ ] Ручной тест: подключение/отключение BT → проверка отсутствия ошибок

**Риски:**
- ⚠️ Восстановление может не сработать → нужен fallback на другое устройство
- ⚠️ Retry может быть избыточным → ограничить количество попыток

**Время:** 4-5 часов

---

## ЭТАП 2: УЛУЧШЕНИЕ НАДЕЖНОСТИ

### Шаг 2.1: Использование событий вместо polling для _wait_for_mic_opened

**Цель:** Убрать polling и использовать события для более быстрого и надежного открытия микрофона.

**Задачи:**
1. Заменить polling на подписку на событие microphone.opened
2. Добавить таймаут для безопасности
3. Убрать избыточные проверки state_manager.is_microphone_active()
4. Добавить логирование использования событий

**Файлы для изменения:**
- `integration/integrations/input_processing_integration.py`
  - `_wait_for_mic_opened()` - замена на события
  - `_setup_event_handlers()` - подписка на microphone.opened

**Критерии готовности:**
- ✅ _wait_for_mic_opened использует события вместо polling
- ✅ Таймаут работает корректно (5.0s)
- ✅ Нет избыточных проверок state_manager
- ✅ Открытие микрофона происходит быстрее (замеры)

**Тесты:**
- [ ] Unit-тест: мок события microphone.opened → проверка подписки
- [ ] Unit-тест: мок таймаута → проверка обработки таймаута
- [ ] Интеграционный тест: реальное открытие микрофона → проверка времени
- [ ] Ручной тест: LONG_PRESS → проверка быстрого открытия

**Риски:**
- ⚠️ Событие может прийти до подписки → нужна проверка состояния перед подпиской
- ⚠️ Таймаут может быть недостаточным → увеличить до 10s для BT устройств

**Время:** 2-3 часа

---

### Шаг 2.2: Сохранение буфера при переключении OUTPUT устройства

**Цель:** При переключении OUTPUT устройства буфер не должен очищаться, воспроизведение должно продолжаться.

**Задачи:**
1. Изменить `_switch_output_device()` - не очищать буфер
2. Сохранять текущую позицию в буфере
3. Продолжать воспроизведение с сохраненной позиции
4. Добавить логирование сохранения буфера

**Файлы для изменения:**
- `modules/speech_playback/core/player.py`
  - `_switch_output_device()` - сохранение буфера
  - `chunk_buffer` - методы для сохранения/восстановления состояния

**Критерии готовности:**
- ✅ Буфер не очищается при переключении устройства
- ✅ Воспроизведение продолжается без пауз
- ✅ Нет потери данных при переключении
- ✅ Логирование подтверждает сохранение буфера

**Тесты:**
- [ ] Unit-тест: мок переключения устройства → проверка сохранения буфера
- [ ] Интеграционный тест: переключение во время воспроизведения → проверка непрерывности
- [ ] Ручной тест: подключение BT наушников во время воспроизведения → проверка непрерывности

**Риски:**
- ⚠️ Буфер может быть слишком большим → ограничить размер буфера
- ⚠️ Переключение может быть медленным → оптимизировать переключение

**Время:** 3-4 часа

---

### Шаг 2.3: Улучшение graceful stop для INPUT

**Цель:** Graceful stop должен работать быстро и надежно, особенно для BT устройств.

**Задачи:**
1. Увеличить таймауты для BT устройств (до 1.0s)
2. Улучшить проверку состояния потока перед остановкой
3. Добавить сохранение данных при graceful stop
4. Добавить логирование всех этапов graceful stop

**Файлы для изменения:**
- `modules/voice_recognition/core/speech_recognizer.py`
  - `stop_listening()` - улучшение graceful stop
  - `_graceful_stop_listening()` - увеличение таймаутов
- `modules/voice_recognition/core/audio_device_monitor.py`
  - `_on_device_changed()` - улучшение graceful stop

**Критерии готовности:**
- ✅ Graceful stop работает для всех типов устройств
- ✅ Таймауты достаточны для BT устройств (1.0s)
- ✅ Данные сохраняются при graceful stop
- ✅ Нет потери данных при переключении

**Тесты:**
- [ ] Unit-тест: мок graceful stop → проверка сохранения данных
- [ ] Интеграционный тест: переключение во время записи → проверка сохранения данных
- [ ] Ручной тест: подключение BT наушников во время записи → проверка сохранения данных

**Риски:**
- ⚠️ Таймауты могут быть недостаточными → увеличить до 2.0s для BT
- ⚠️ Graceful stop может не сработать → нужен fallback на принудительную остановку

**Время:** 2-3 часа

---

### Шаг 2.4: Добавление состояния SWITCHING

**Цель:** Предотвратить новые операции во время переключения устройства.

**Задачи:**
1. Добавить состояние SWITCHING в SpeechRecognizer
2. Добавить состояние SWITCHING в SequentialSpeechPlayer
3. Блокировать новые операции во время SWITCHING
4. Добавить логирование состояния SWITCHING

**Файлы для изменения:**
- `modules/voice_recognition/core/speech_recognizer.py`
  - Добавить `_switching_device: bool = False`
  - Проверка состояния перед операциями
- `modules/speech_playback/core/player.py`
  - Добавить `_switching_device: bool = False`
  - Проверка состояния перед операциями

**Критерии готовности:**
- ✅ Состояние SWITCHING блокирует новые операции
- ✅ Переключение происходит атомарно
- ✅ Нет race conditions при переключении
- ✅ Логирование подтверждает блокировку

**Тесты:**
- [ ] Unit-тест: мок состояния SWITCHING → проверка блокировки
- [ ] Интеграционный тест: одновременное переключение и операция → проверка блокировки
- [ ] Ручной тест: быстрое переключение устройств → проверка отсутствия ошибок

**Риски:**
- ⚠️ Блокировка может быть слишком долгой → ограничить время блокировки
- ⚠️ Deadlock при блокировке → использовать таймауты

**Время:** 2-3 часа

---

## ЭТАП 3: ОПТИМИЗАЦИЯ ПРОИЗВОДИТЕЛЬНОСТИ

### Шаг 3.1: Оптимизация проверки устройств OUTPUT

**Цель:** Убрать проверку устройства при каждом чанке, использовать только фоновый мониторинг.

**Задачи:**
1. Убрать `_check_and_update_output_device()` из `add_audio_data()`
2. Использовать только фоновый мониторинг для проверки устройства
3. Проверять устройство только при инициализации и ошибках
4. Добавить логирование оптимизации

**Файлы для изменения:**
- `modules/speech_playback/core/player.py`
  - `add_audio_data()` - убрать проверку устройства
  - `_check_and_update_output_device()` - вызывать только при необходимости

**Критерии готовности:**
- ✅ Проверка устройства не вызывается при каждом чанке
- ✅ Фоновый мониторинг работает корректно
- ✅ Устройство проверяется только при необходимости
- ✅ Производительность улучшена (замеры)

**Тесты:**
- [ ] Unit-тест: мок add_audio_data → проверка отсутствия проверки устройства
- [ ] Интеграционный тест: воспроизведение → проверка производительности
- [ ] Ручной тест: длительное воспроизведение → проверка отсутствия задержек

**Риски:**
- ⚠️ Фоновый мониторинг может пропустить изменение → уменьшить интервал до 0.5s
- ⚠️ Устройство может измениться между проверками → добавить проверку при ошибках

**Время:** 1-2 часа

---

### Шаг 3.2: Предварительное создание потока OUTPUT

**Цель:** Поток OUTPUT должен быть создан заранее, не при первом чанке (lazy start).

**Задачи:**
1. Создавать поток при инициализации плеера
2. Пересоздавать поток сразу после переключения устройства
3. Убрать lazy start для OUTPUT
4. Добавить логирование создания потока

**Файлы для изменения:**
- `modules/speech_playback/core/player.py`
  - `initialize()` - создание потока
  - `_switch_output_device()` - пересоздание потока
  - `_ensure_stream_started()` - убрать lazy start

**Критерии готовности:**
- ✅ Поток создается при инициализации
- ✅ Поток пересоздается сразу после переключения
- ✅ Нет lazy start для OUTPUT
- ✅ Воспроизведение начинается сразу (замеры)

**Тесты:**
- [ ] Unit-тест: мок инициализации → проверка создания потока
- [ ] Интеграционный тест: переключение устройства → проверка пересоздания потока
- [ ] Ручной тест: начало воспроизведения → проверка отсутствия задержек

**Риски:**
- ⚠️ Создание потока может быть медленным → оптимизировать создание
- ⚠️ Поток может быть создан для неправильного устройства → проверять устройство перед созданием

**Время:** 2-3 часа

---

### Шаг 3.3: Оптимизация интервалов мониторинга

**Цель:** Уменьшить интервалы мониторинга для более быстрого обнаружения изменений.

**Задачи:**
1. Уменьшить интервал мониторинга INPUT до 0.2s
2. Уменьшить интервал мониторинга OUTPUT до 0.5s
3. Оптимизировать проверку устройства (убрать избыточные операции)
4. Добавить логирование оптимизации

**Файлы для изменения:**
- `modules/voice_recognition/core/audio_device_monitor.py`
  - `__init__()` - уменьшить check_interval до 0.2s
- `modules/speech_playback/core/player.py`
  - `__init__()` - уменьшить _device_check_interval до 0.5s

**Критерии готовности:**
- ✅ Интервал мониторинга INPUT = 0.2s
- ✅ Интервал мониторинга OUTPUT = 0.5s
- ✅ Изменения обнаруживаются быстрее (замеры)
- ✅ Нагрузка на CPU не увеличилась (замеры)

**Тесты:**
- [ ] Unit-тест: мок мониторинга → проверка интервалов
- [ ] Интеграционный тест: переключение устройства → проверка времени обнаружения
- [ ] Ручной тест: подключение BT наушников → проверка быстрого обнаружения

**Риски:**
- ⚠️ Уменьшение интервала может увеличить нагрузку на CPU → мониторить нагрузку
- ⚠️ Частые проверки могут вызвать проблемы → оптимизировать проверку

**Время:** 1-2 часа

---

## ЭТАП 4: ДОСТИЖЕНИЕ ИДЕАЛЬНОГО СОСТОЯНИЯ

### Шаг 4.1: Достижение метрик производительности

**Цель:** Достичь всех метрик производительности из целевого состояния.

**Задачи:**
1. Измерить текущие метрики производительности
2. Оптимизировать медленные операции
3. Достичь целевых метрик:
   - INPUT: определение устройства < 100ms, открытие микрофона < 200ms
   - OUTPUT: определение устройства < 50ms, начало воспроизведения < 50ms
4. Добавить автоматические тесты метрик

**Файлы для изменения:**
- Все файлы, связанные с определением устройств
- Добавить метрики производительности

**Критерии готовности:**
- ✅ Все метрики производительности достигнуты
- ✅ Автоматические тесты метрик проходят
- ✅ Производительность стабильна (p95)

**Тесты:**
- [ ] Unit-тест: метрики производительности
- [ ] Интеграционный тест: реальные метрики
- [ ] Ручной тест: проверка метрик в реальных условиях

**Риски:**
- ⚠️ Метрики могут быть недостижимыми → пересмотреть целевые значения
- ⚠️ Оптимизация может сломать функциональность → тщательное тестирование

**Время:** 4-6 часов

---

### Шаг 4.2: Достижение метрик надежности

**Цель:** Достичь всех метрик надежности из целевого состояния.

**Задачи:**
1. Измерить текущие метрики надежности
2. Улучшить обработку ошибок
3. Достичь целевых метрик:
   - Процент успешных определений устройств: 100%
   - Процент успешных восстановлений: > 95%
   - Количество ошибок PortAudio: 0
4. Добавить автоматические тесты надежности

**Файлы для изменения:**
- Все файлы, связанные с обработкой ошибок
- Добавить метрики надежности

**Критерии готовности:**
- ✅ Все метрики надежности достигнуты
- ✅ Автоматические тесты надежности проходят
- ✅ Надежность стабильна

**Тесты:**
- [ ] Unit-тест: метрики надежности
- [ ] Интеграционный тест: реальные метрики
- [ ] Ручной тест: проверка надежности в реальных условиях

**Риски:**
- ⚠️ Метрики могут быть недостижимыми → пересмотреть целевые значения
- ⚠️ Улучшение надежности может снизить производительность → балансировать

**Время:** 4-6 часов

---

### Шаг 4.3: Достижение метрик пользовательского опыта

**Цель:** Достичь всех метрик пользовательского опыта из целевого состояния.

**Задачи:**
1. Проверить прозрачность переключений
2. Проверить предсказуемость работы
3. Убедиться в отсутствии ошибок для пользователя
4. Проверить автоматизацию управления устройствами

**Файлы для изменения:**
- Все файлы, связанные с пользовательским опытом
- Улучшить логирование (скрыть технические детали)

**Критерии готовности:**
- ✅ Переключения прозрачны для пользователя
- ✅ Система работает предсказуемо
- ✅ Нет сообщений об ошибках для пользователя
- ✅ Устройства управляются автоматически

**Тесты:**
- [ ] Ручной тест: прозрачность переключений
- [ ] Ручной тест: предсказуемость работы
- [ ] Ручной тест: отсутствие ошибок
- [ ] Ручной тест: автоматизация управления

**Риски:**
- ⚠️ Прозрачность может быть недостижимой → улучшить обработку ошибок
- ⚠️ Автоматизация может быть избыточной → добавить настройки

**Время:** 2-3 часа

---

## ПЛАН ТЕСТИРОВАНИЯ

### После каждого шага

**Обязательные тесты:**
1. ✅ **Unit-тесты** - все существующие тесты проходят
2. ✅ **Интеграционные тесты** - основные сценарии работают
3. ✅ **Ручные тесты** - базовая функциональность работает
4. ✅ **Логи** - нет новых ошибок в логах

**Специфичные тесты для каждого шага:**
- См. раздел "Тесты" в каждом шаге

### После каждого этапа

**Полное тестирование:**
1. ✅ **Все unit-тесты** - 100% прохождение
2. ✅ **Все интеграционные тесты** - 100% прохождение
3. ✅ **Ручное тестирование** - все основные сценарии
4. ✅ **Тестирование с BT устройствами** - подключение/отключение
5. ✅ **Тестирование производительности** - метрики в норме
6. ✅ **Тестирование надежности** - нет ошибок

---

## КРИТЕРИИ ГОТОВНОСТИ К СЛЕДУЮЩЕМУ ШАГУ

### Перед переходом к следующему шагу

**Обязательные проверки:**
- ✅ Все тесты текущего шага проходят
- ✅ Нет регрессий в существующей функциональности
- ✅ Логи не содержат новых ошибок
- ✅ Код соответствует стандартам проекта
- ✅ Документация обновлена

**Опциональные проверки:**
- ✅ Метрики улучшились (если применимо)
- ✅ Код ревью пройден (если требуется)
- ✅ Пользовательское тестирование пройдено (если требуется)

---

## РИСКИ И МИТИГАЦИЯ

### Общие риски

**Риск 1: Регрессии в существующей функциональности**
- **Митигация:** Тщательное тестирование после каждого шага
- **Откат:** Git revert последнего коммита

**Риск 2: Несовместимость изменений**
- **Митигация:** Изоляция каждого шага
- **Откат:** Git revert последнего коммита

**Риск 3: Производительность ухудшилась**
- **Митигация:** Замеры производительности до и после
- **Откат:** Git revert последнего коммита

### Специфичные риски

**Риск 4: SwitchAudioSource недоступен**
- **Митигация:** Надежный fallback на PortAudio
- **Откат:** Использовать только PortAudio

**Риск 5: PortAudio кэш не обновляется**
- **Митигация:** Принудительное обновление кэша
- **Откат:** Использовать только macOS API

**Риск 6: BT устройства не определяются**
- **Митигация:** Улучшенный поиск устройств
- **Откат:** Использовать fallback на встроенные устройства

---

## ВРЕМЕННЫЕ ОЦЕНКИ

### Общее время реализации

- **Этап 1 (Критичные проблемы):** 11-15 часов
- **Этап 2 (Надежность):** 9-12 часов
- **Этап 3 (Производительность):** 4-7 часов
- **Этап 4 (Идеальное состояние):** 10-15 часов

**Итого:** 34-49 часов (4-6 рабочих дней)

### Рекомендуемый порядок

1. **Неделя 1:** Этап 1 (критичные проблемы)
2. **Неделя 2:** Этап 2 (надежность)
3. **Неделя 3:** Этап 3 (производительность)
4. **Неделя 4:** Этап 4 (идеальное состояние)

---

## ЧЕКЛИСТ ПЕРЕХОДА К СЛЕДУЮЩЕМУ ШАГУ

### Перед началом нового шага

- [ ] Предыдущий шаг завершен и протестирован
- [ ] Все тесты проходят
- [ ] Нет регрессий
- [ ] Логи чистые
- [ ] Документация обновлена
- [ ] Код закоммичен

### После завершения шага

- [ ] Все задачи шага выполнены
- [ ] Критерии готовности достигнуты
- [ ] Все тесты проходят
- [ ] Логи проверены
- [ ] Документация обновлена
- [ ] Код закоммичен с описанием изменений

---

## ЗАКЛЮЧЕНИЕ

Этот план разбивает путь к идеальному состоянию на маленькие, управляемые шаги. Каждый шаг:
- ✅ Независим и может быть реализован отдельно
- ✅ Имеет четкие критерии готовности
- ✅ Может быть протестирован
- ✅ Может быть откачен без последствий

Следование этому плану позволит:
1. **Безопасно** реализовывать изменения
2. **Тестировать** каждый шаг
3. **Откатывать** при необходимости
4. **Достичь** идеального состояния системы



