# Визуальные диаграммы: Как было → Как будет

## Дата создания
2025-01-XX

## Обзор

Этот документ содержит визуальные диаграммы, показывающие текущее состояние (с проблемами) и будущее состояние (после реализации решений).

---

## 📋 Краткая сводка изменений

### Проблема 1: Микрофон не закрывается после playback.completed
- **Было:** Зависит от локального флага `_recording_started` → микрофон остается активным
- **Будет:** Принудительное закрытие через `state_manager` + синхронизация через EventBus

### Проблема 2: AVF не деактивируется, разрешения пропущены
- **Было:** Только 2 проверки AVF, игнорируем ошибки разрешений → продолжаем работу с ошибками
- **Будет:** Цикл проверки AVF (5 попыток), обязательная проверка разрешений с исключениями

### Проблема 3: LONG_PRESS блокируется во время PROCESSING
- **Было:** Блокируем все активации во время PROCESSING → пользователь не может прервать
- **Будет:** Gateway различает источник активации → разрешаем keyboard, блокируем автоматическую

---

## 🔴 Проблема 1: Микрофон не закрывается после playback.completed

### ❌ КАК БЫЛО (текущее состояние с проблемой):

```
┌─────────────────────────────────────────────────────────────────┐
│                    PLAYBACK.COMPLETED EVENT                      │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│         _on_playback_finished() в InputProcessingIntegration     │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ mic_active =     │
                    │ state_manager.  │
                    │ is_microphone_  │
                    │ active()         │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ mic_active =     │
                    │ True?            │
                    └────────┬────────┘
                             │
                ┌─────────────┴─────────────┐
                │                           │
                ▼                           ▼
        ┌───────────────┐          ┌───────────────┐
        │ mic_active =  │          │ mic_active =  │
        │ True          │          │ False        │
        └───────┬───────┘          └───────┬───────┘
                │                          │
                ▼                          ▼
    ┌───────────────────────┐    ┌───────────────────────┐
    │ Проверка:             │    │ НЕ ЗАКРЫВАЕМ          │
    │ _recording_started?   │    │ (микрофон уже закрыт) │
    └───────┬───────────────┘    └───────────────────────┘
            │
    ┌───────┴────────┐
    │                │
    ▼                ▼
┌─────────┐    ┌─────────┐
│ True    │    │ False   │
└────┬────┘    └────┬────┘
     │              │
     ▼              ▼
┌─────────┐    ┌─────────────────────────────────────┐
│ НЕ      │    │ ❌ ПРОБЛЕМА:                        │
│ сбрасы- │    │ Микрофон активен (mic_active=True), │
│ ваем    │    │ но _recording_started=False         │
│ session │    │ → Микрофон НЕ закрывается!          │
│         │    │ → Остается активным после playback  │
└─────────┘    └─────────────────────────────────────┘
```

**Проблема:**
- Микрофон остается активным после `playback.completed`
- Проверка `_recording_started` не синхронизирована с реальным состоянием микрофона
- Нет принудительного закрытия через `state_manager`

---

### ✅ КАК БУДЕТ (после Решения 1.3):

```
┌─────────────────────────────────────────────────────────────────┐
│                    PLAYBACK.COMPLETED EVENT                      │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│         _on_playback_finished() в InputProcessingIntegration     │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ mic_active =     │
                    │ state_manager.  │
                    │ is_microphone_  │
                    │ active()        │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ mic_active =     │
                    │ True?            │
                    └────────┬────────┘
                             │
                ┌─────────────┴─────────────┐
                │                           │
                ▼                           ▼
        ┌───────────────┐          ┌───────────────┐
        │ mic_active =  │          │ mic_active =  │
        │ True          │          │ False        │
        └───────┬───────┘          └───────┬───────┘
                │                          │
                ▼                          ▼
    ┌───────────────────────┐    ┌───────────────────────┐
    │ ✅ РЕШЕНИЕ 1.3:       │    │ НЕ ЗАКРЫВАЕМ          │
    │ Комбинированный       │    │ (микрофон уже закрыт) │
    │ подход                │    └───────────────────────┘
    └───────┬───────────────┘
            │
            ▼
    ┌───────────────────────────────────────────────────────────┐
    │ ШАГ 1: Принудительное закрытие через state_manager        │
    │ state_manager.force_close_microphone(                     │
    │     reason="playback_completed"                            │
    │ )                                                          │
    │ ✅ Единый источник истины                                 │
    └───────────────────────┬───────────────────────────────────┘
                            │
                            ▼
    ┌───────────────────────────────────────────────────────────┐
    │ ШАГ 2: Публикация события для синхронизации                │
    │ await _publish_recording_stop_with_debounce({               │
    │     "source": "playback_finished",                         │
    │     "session_id": None                                     │
    │ })                                                         │
    │ ✅ Синхронизация с VoiceRecognitionIntegration            │
    └───────────────────────┬───────────────────────────────────┘
                            │
                            ▼
    ┌───────────────────────────────────────────────────────────┐
    │ ШАГ 3: Ожидание закрытия для гарантии                      │
    │ await _wait_for_mic_closed_with_timeout(                   │
    │     timeout=1.0,                                           │
    │     source="playback_finished"                             │
    │ )                                                          │
    │ ✅ Гарантия закрытия микрофона                             │
    └───────────────────────┬───────────────────────────────────┘
                            │
                            ▼
                    ┌───────────────┐
                    │ ✅ Микрофон   │
                    │ закрыт       │
                    └───────────────┘
```

**Решение:**
- ✅ Принудительное закрытие через `state_manager.force_close_microphone()`
- ✅ Публикация события для синхронизации с VoiceRecognitionIntegration
- ✅ Ожидание закрытия для гарантии
- ✅ Единый источник истины (не зависит от локальных флагов)

---

## 🔴 Проблема 2: AVF не деактивируется, разрешения пропущены

### ❌ КАК БЫЛО (текущее состояние с проблемой):

```
┌─────────────────────────────────────────────────────────────────┐
│              VOICE.RECORDING_STOP EVENT                         │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│    _on_recording_stop() в VoiceRecognitionIntegration           │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ AVF Engine:     │
                    │ stop_input()    │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ await sleep(   │
                    │     0.2)       │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ Проверка:        │
                    │ is_input_active? │
                    └────────┬────────┘
                             │
                ┌─────────────┴─────────────┐
                │                           │
                ▼                           ▼
        ┌───────────────┐          ┌───────────────┐
        │ True          │          │ False         │
        └───────┬───────┘          └───────┬───────┘
                │                          │
                ▼                          ▼
    ┌───────────────────────┐    ┌───────────────────────┐
    │ ❌ ПРОБЛЕМА:          │    │ ✅ AVF деактивирован   │
    │ AVF все еще активен!  │    │ Продолжаем...          │
    │ Ждем еще 0.5 сек      │    └───────────────────────┘
    └───────┬───────────────┘
            │
            ▼
    ┌───────────────────────┐
    │ Проверка снова:       │
    │ is_input_active?      │
    └───────┬───────────────┘
            │
    ┌───────┴────────┐
    │                │
    ▼                ▼
┌─────────┐    ┌─────────┐
│ True    │    │ False   │
└────┬────┘    └────┬────┘
     │              │
     ▼              ▼
┌─────────┐    ┌─────────────────────────────────────┐
│ ❌      │    │ ✅ AVF деактивирован                │
│ ПРОБЛЕМА│    │ Продолжаем...                       │
│ AVF     │    └─────────────────────────────────────┘
│ все еще │
│ активен │
│         │
│ ⚠️      │
│ Продол- │
│ жаем    │
│ работу  │
│ БЕЗ     │
│ деакти- │
│ вации! │
└─────────┘
```

**Проблема 2.1:**
- AVF может остаться активным после `stop_input()`
- Нет гарантированной деактивации (только 2 проверки)
- Продолжаем работу даже если AVF не деактивирован

---

```
┌─────────────────────────────────────────────────────────────────┐
│              VOICE.RECORDING_START EVENT                        │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│    _on_recording_start() в VoiceRecognitionIntegration           │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ Проверка        │
                    │ разрешений:     │
                    │ PermissionChecker│
                    │ .check_microphone_│
                    │ permission()    │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ mic_permission =│
                    │ "granted"?      │
                    └────────┬────────┘
                             │
                ┌─────────────┴─────────────┐
                │                           │
                ▼                           ▼
        ┌───────────────┐          ┌───────────────┐
        │ "granted"     │          │ "denied" или │
        │               │          │ ошибка       │
        └───────┬───────┘          └───────┬───────┘
                │                          │
                ▼                          ▼
    ┌───────────────────────┐    ┌───────────────────────┐
    │ ✅ Разрешения OK       │    │ ❌ ПРОБЛЕМА:          │
    │ Продолжаем...          │    │ Разрешения не         │
    └───────────────────────┘    │ предоставлены или     │
                                  │ ошибка проверки       │
                                  │                        │
                                  │ ⚠️ Продолжаем работу  │
                                  │ БЕЗ разрешений!       │
                                  └───────────────────────┘
```

**Проблема 2.2:**
- Разрешения могут быть не предоставлены
- Ошибка проверки разрешений игнорируется
- Продолжаем работу даже без разрешений

---

### ✅ КАК БУДЕТ (после Решения 2.1 + 2.2):

```
┌─────────────────────────────────────────────────────────────────┐
│              VOICE.RECORDING_STOP EVENT                         │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│    _on_recording_stop() в VoiceRecognitionIntegration           │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ AVF Engine:     │
                    │ stop_input()    │
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │ await sleep(0.2)│
                    └────────┬────────┘
                             │
                             ▼
    ┌───────────────────────────────────────────────────────────┐
    │ ✅ РЕШЕНИЕ 2.1: Гарантированная деактивация AVF            │
    │ max_avf_check_attempts = 5                                  │
    │ for attempt in range(5):                                    │
    │     if is_input_active:                                     │
    │         await sleep(0.2)                                    │
    │     else:                                                   │
    │         break  # ✅ AVF деактивирован                      │
    │ else:                                                       │
    │     raise RuntimeError("AVF not deactivated")               │
    │                                                              │
    │ ✅ Гарантия: AVF деактивирован или исключение               │
    └───────────────────────┬───────────────────────────────────┘
                            │
                            ▼
                    ┌───────────────┐
                    │ ✅ AVF        │
                    │ деактивирован │
                    └───────────────┘
```

**Решение 2.1:**
- ✅ Цикл проверки AVF (5 попыток)
- ✅ Гарантированная деактивация или исключение
- ✅ Не продолжаем работу если AVF не деактивирован

---

```
┌─────────────────────────────────────────────────────────────────┐
│              VOICE.RECORDING_START EVENT                        │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│    _on_recording_start() в VoiceRecognitionIntegration           │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
    ┌───────────────────────────────────────────────────────────┐
    │ ✅ РЕШЕНИЕ 2.2: Обязательная проверка разрешений            │
    │ try:                                                        │
    │     permission_checker = PermissionChecker()                │
    │     mic_permission = permission_checker.                   │
    │         check_microphone_permission()                       │
    │     if mic_permission != "granted":                         │
    │         raise RuntimeError("Permission not granted")        │
    │ except RuntimeError:                                        │
    │     raise  # ✅ Пробрасываем (не продолжаем)               │
    │ except Exception as perm_error:                             │
    │     raise RuntimeError("Permission check failed")           │
    │                                                              │
    │ ✅ Гарантия: Разрешения проверены или исключение             │
    └───────────────────────┬───────────────────────────────────┘
                            │
                            ▼
                    ┌─────────────────┐
                    │ mic_permission =│
                    │ "granted"?      │
                    └────────┬────────┘
                             │
                ┌─────────────┴─────────────┐
                │                           │
                ▼                           ▼
        ┌───────────────┐          ┌───────────────┐
        │ "granted"     │          │ "denied" или │
        │               │          │ ошибка       │
        └───────┬───────┘          └───────┬───────┘
                │                          │
                ▼                          ▼
    ┌───────────────────────┐    ┌───────────────────────┐
    │ ✅ Разрешения OK       │    │ ❌ ИСКЛЮЧЕНИЕ:       │
    │ Продолжаем активацию   │    │ RuntimeError         │
    │ Google Speech          │    │ (не продолжаем)      │
    │ Recognition            │    └───────────────────────┘
    └───────────────────────┘
```

**Решение 2.2:**
- ✅ Обязательная проверка разрешений
- ✅ Исключение при отсутствии разрешений или ошибке проверки
- ✅ Не продолжаем работу без разрешений

---

## 🔴 Проблема 3: LONG_PRESS блокируется во время PROCESSING

### ❌ КАК БЫЛО (текущее состояние с проблемой):

```
┌─────────────────────────────────────────────────────────────────┐
│              KEYBOARD LONG_PRESS EVENT (Ctrl+N)                 │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│    _handle_long_press() в InputProcessingIntegration             │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │ Проверка:       │
                    │ app_mode =      │
                    │ PROCESSING?     │
                    └────────┬────────┘
                             │
                ┌─────────────┴─────────────┐
                │                           │
                ▼                           ▼
        ┌───────────────┐          ┌───────────────┐
        │ PROCESSING    │          │ SLEEPING/     │
        │               │          │ LISTENING     │
        └───────┬───────┘          └───────┬───────┘
                │                          │
                ▼                          ▼
    ┌───────────────────────┐    ┌───────────────────────┐
    │ Проверка:             │    │ ✅ Разрешаем          │
    │ _playback_active?     │    │ активацию             │
    │ или                   │    └───────────────────────┘
    │ playback_recently_    │
    │ started?              │
    └───────┬───────────────┘
            │
    ┌───────┴────────┐
    │                │
    ▼                ▼
┌─────────┐    ┌─────────┐
│ True    │    │ False   │
└────┬────┘    └────┬────┘
     │              │
     ▼              ▼
┌─────────┐    ┌─────────────────────────────────────┐
│ ❌      │    │ ✅ Разрешаем активацию              │
│ БЛОКИ-  │    │ (воспроизведение не активно)        │
│ РУЕМ    │    └─────────────────────────────────────┘
│         │
│ 🔒      │
│ LONG_   │
│ PRESS   │
│ blocked │
│         │
│ ❌      │
│ Проблема│
│ :       │
│ Пользова│
│ тель    │
│ не может│
│ прервать│
│ воспро- │
│ изведение│
│ через   │
│ Shortcut│
└─────────┘
```

**Проблема:**
- LONG_PRESS блокируется во время PROCESSING, если `_playback_active == True`
- Пользователь не может прервать воспроизведение через Shortcut
- Нет различения источника активации (keyboard vs автоматическая)

---

### ✅ КАК БУДЕТ (после Решения 3.3):

```
┌─────────────────────────────────────────────────────────────────┐
│              KEYBOARD LONG_PRESS EVENT (Ctrl+N)                  │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│    _handle_long_press() в InputProcessingIntegration             │
└────────────────────────────┬────────────────────────────────────┘
                              │
                              ▼
    ┌───────────────────────────────────────────────────────────┐
    │ ✅ РЕШЕНИЕ 3.3: Использование gateway для принятия решения  │
    │                                                              │
    │ snapshot = create_snapshot_from_state(state_manager)        │
    │ decision = decide_allow_shortcut_during_processing(         │
    │     snapshot,                                               │
    │     source="keyboard"  # ✅ Различаем источник              │
    │ )                                                           │
    └───────────────────────┬───────────────────────────────────┘
                            │
                            ▼
    ┌───────────────────────────────────────────────────────────┐
    │ Gateway: decide_allow_shortcut_during_processing()         │
    │                                                              │
    │ if app_mode == PROCESSING:                                 │
    │     if source == "keyboard":                                │
    │         return Decision.START  # ✅ Разрешаем              │
    │     else:                                                   │
    │         return Decision.ABORT  # ❌ Блокируем             │
    │ else:                                                       │
    │     return Decision.START  # ✅ Разрешаем в других режимах│
    └───────────────────────┬───────────────────────────────────┘
                            │
                            ▼
                    ┌─────────────────┐
                    │ decision =      │
                    │ START?          │
                    └────────┬────────┘
                             │
                ┌─────────────┴─────────────┐
                │                           │
                ▼                           ▼
        ┌───────────────┐          ┌───────────────┐
        │ START         │          │ ABORT         │
        └───────┬───────┘          └───────┬───────┘
                │                          │
                ▼                          ▼
    ┌───────────────────────┐    ┌───────────────────────┐
    │ ✅ Разрешаем          │    │ ❌ Блокируем          │
    │ активацию микрофона    │    │ (автоматическая       │
    │                        │    │ активация во время    │
    │ Пользователь может    │    │ PROCESSING)           │
    │ прервать воспроизве-  │    └───────────────────────┘
    │ дение через Shortcut   │
    └───────┬───────────────┘
            │
            ▼
    ┌───────────────────────────────────────────────────────────┐
    │ Продолжаем активацию микрофона                              │
    │                                                              │
    │ 1. Принудительное закрытие активного микрофона (если есть) │
    │ 2. Публикация voice.recording_start                        │
    │ 3. Активация Google Speech Recognition                     │
    └───────────────────────────────────────────────────────────┘
```

**Решение:**
- ✅ Использование gateway для принятия решения (соответствует архитектуре)
- ✅ Различение источника активации (`source="keyboard"` vs автоматическая)
- ✅ Разрешаем активацию через Shortcut во время PROCESSING (для прерывания)
- ✅ Блокируем только автоматическую активацию во время PROCESSING

---

## 📊 Сравнительная таблица: Было → Будет

| Проблема | Как было | Как будет |
|---------|---------|-----------|
| **1: Микрофон не закрывается** | ❌ Зависит от локального флага `_recording_started`<br>❌ Микрофон остается активным | ✅ Принудительное закрытие через `state_manager`<br>✅ Синхронизация через EventBus<br>✅ Ожидание закрытия для гарантии |
| **2.1: AVF не деактивируется** | ❌ Только 2 проверки<br>❌ Продолжаем работу если AVF активен | ✅ Цикл проверки (5 попыток)<br>✅ Исключение если AVF не деактивирован |
| **2.2: Разрешения пропущены** | ❌ Игнорируем ошибки проверки<br>❌ Продолжаем работу без разрешений | ✅ Обязательная проверка<br>✅ Исключение при отсутствии разрешений |
| **3: LONG_PRESS блокируется** | ❌ Блокируем все активации во время PROCESSING<br>❌ Пользователь не может прервать | ✅ Gateway различает источник активации<br>✅ Разрешаем keyboard активацию<br>✅ Блокируем только автоматическую |

---

## 🎯 Ключевые улучшения

### 1. Единый источник истины
- **Было:** Локальные флаги (`_recording_started`, `_playback_active`)
- **Будет:** `state_manager.is_microphone_active()`, `state_manager.force_close_microphone()`

### 2. Синхронизация
- **Было:** Нет синхронизации между компонентами
- **Будет:** EventBus для синхронизации (`_publish_recording_stop_with_debounce()`)

### 3. Гарантии
- **Было:** Нет гарантий (можем продолжить работу с ошибками)
- **Будет:** Гарантии через циклы проверки и исключения

### 4. Архитектура
- **Было:** Локальная логика в интеграциях
- **Будет:** Gateway для принятия решений (централизованная логика)

---

## Связанные документы

- `Docs/FINAL_SOLUTIONS_GUIDE.md` — финальное руководство с кодом
- `Docs/SOLUTION_ARCHITECTURE_VERIFICATION.md` — верификация соответствия архитектуре
- `Docs/SYNC_PROBLEM_VISUAL_DIAGRAM.md` — визуальная диаграмма проблем синхронизации

