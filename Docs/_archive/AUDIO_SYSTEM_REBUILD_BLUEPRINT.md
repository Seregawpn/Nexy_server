# Аудио-система Nexy: Blueprint для полной пересборки

**Дата:** 2025-12-xx  
**Контекст:** текущая система накопила дубли, конфликты и распылённую логику управления устройствами. Этот документ описывает, как мы её пересобираем с нуля, ориентируясь на macOS, максимальную устойчивость и прозрачную, слоистую архитектуру.

## 1. Цели
- **Надёжность любой ценой.** Пользователь почти никогда не остаётся без работающего микрофона/динамиков. При проблемах устройство мягко заменяется, система не зависает.
- **Следуем за macOS.** Основной режим — использовать системные default'ы, не навязывать свои правила. Когда нужно фиксировать устройство, делаем это через сохранение UID.
- **Минимум «дёргания».** Потоки и устройства не пересоздаются просто так; если UID остался тем же, поток жив и не было явной ошибки — никакого вмешательства.
- **Прозрачная, слоистая архитектура.** Чётко видно, кто за что отвечает, и компоненты обращаются только вниз по слоям.
- **Nexy дополняет, а не заменяет.** Мы добавляем fallback’ы поверх системных политик, не изобретаем собственные правила из ничего.

## 2. Базовые принципы архитектуры

### 2.1 Один Источник Истины
- Устройства: CoreAudio через `CoreAudioDeviceManager`.
- Потоки: `AudioStreamManager`.
- Все остальные компоненты не хранят собственные «истины» об устройствах или потоках, а запрашивают их у этих двух слоёв.

### 2.2 Строгая слоистость (Layering)
Обязательные уровни:
1. **Layer 0 — macOS / библиотеки** (`CoreAudio`, `PortAudio`).
2. **Layer 1 — Device Layer** (`CoreAudioDeviceManager`, `DevicePolicy`, `DeviceChangePublisher`).
3. **Layer 2 — Stream Layer** (`AudioStreamManager`).
4. **Layer 3 — Domain Layer** (`InputProcessingIntegration`, `SpeechRecognizer`, `SpeechPlaybackIntegration`, `SequentialSpeechPlayer`).
5. **Layer 4 — UX / команды** (диалоги, гласный UI, сценарии ассистента).

Правило зависимостей: `Layer 4 → 3 → 2 → 1 → 0` (только вниз).  
Никаких вызовов вверх или диагональных ссылок — например, `SequentialSpeechPlayer` не обращается к `CoreAudioDeviceManager`, а `DeviceChangePublisher` не знает про распознавание/плеер.

### 2.3 Событийная модель
- Любые внешние изменения (смена default’ов, прерывания, состояние фокуса и т.п.) идут через `EventBus`.
- Кросс-подсистемные истории (device → playback, device → recognition, interrupts) решаются событиями, а не прямыми вызовами.
- Каждое событие содержит самодостаточный payload: ID устройства, направление (input/output), флаги Bluetooth, и др.

## 3. Работа с устройствами

### 3.1 Идентификаторы vs имена
- В логике опираемся на UID/CoreAudio ID.
- Имена используются только для логов и UI, но не для принятия решений (поиск по имени — архитектурный анти-паттерн).

### 3.2 Следуем default’ам macOS
- В базовом режиме слушаем системные default’ы (INPUT = микрофон, OUTPUT = динамики).
- Если пользователь зафиксировал девайс вручную — UID сохраняется и применяется поверх default’а.

### 3.3 Device pinning
Для INPUT и OUTPUT храним:
1. `current_default_device` — то, что вернула система.
2. `active_device` — где открыт поток.
3. `last_good_device` — последнее успешно работавшее устройство.

Правила:
- Потоки не пересоздаются, если UID не изменился, поток жив и не было явной ошибки или сигнала reset.
- При ошибке/timeout фиксируем `active_device` как нерабочий и пробуем `last_good_device`.

### 3.4 Приоритеты и fallback (DevicePolicy)
- INPUT-кандидаты по порядку:
  1. системный default,
  2. встроенные,
  3. USB,
  4. Bluetooth,
  5. удалённые/виртуальные.
- OUTPUT аналогично — с учётом UX (builtin → USB → BT → remote).
- При ошибке на кандидате:
  1. классифицируем ошибку (временная/фатальная),
  2. ставим устройство в short-term blacklist при временной ошибке,
  3. пробуем следующий кандидат,
  4. если ничего не завёлось — фиксируем состояние `*_UNAVAILABLE` и даём фидбек.
- DevicePolicy знает тайминги, retries, очередность fallback’ов и роутит получается события.

### 3.5 Особенности Bluetooth
- BT-устройства не считаются готовыми сразу после смены default.
- Для BT-output:
  - задержка 200–300 мс перед проверкой/созданием потока,
  - повышенный timeout при первом старте,
  - PortAudio ошибки `-9986`, `-10851` → мгновенный fallback на более устойчивое устройство (например, встроенный динамик).
- Для BT-input аналогично: дополнительное ожидание, в случае ошибки переход к следующему кандидату.

## 4. Работа со потоками (`AudioStreamManager`)

### 4.1 Единая точка PortAudio
- Только `AudioStreamManager` создаёт/закрывает/пересоздаёт PortAudio-потоки и знает структуру `StreamConfig`.
- Прямые вызовы PortAudio из других слоёв запрещены.

### 4.2 Жизненный цикл
Для INPUT и OUTPUT есть состояния:
1. `NO_STREAM`
2. `INITIALIZING`
3. `ACTIVE`
4. `STOPPING`
5. `ERROR` / `UNAVAILABLE`

Правила:
- Не создаём второй поток, пока предыдущий не закрыт (или явно признался мёртвым).
- Переходы строго по документированной диаграмме; `ERROR` может транслироваться во внешний `*_UNAVAILABLE`.

### 4.3 Поведение при ошибках
- На первой попытке создаём поток на target-устройстве (обычно default).
- Если `PortAudio` возвращает ошибку:
  1. Классифицируем её (см. раздел 5).
  2. Запрашиваем у `DevicePolicy` следующий кандидат.
  3. Пробуем его, максимум один retry на устройство.
  4. Существует глобальный лимит попыток на операцию, чтобы избежать вечного цикла.
- При успешном открытии обновляем `active_device`/`last_good_device`, публикуем события `device.stream_active`.

## 5. Обработка ошибок

### 5.1 Классификация
- **Временные (device temporarily unavailable)**: `-9986`, `-10851`, занятость девайса, несовпадение параметров.
- **Фатальные/конфигурационные**: неверные параметры, критическая ошибка PortAudio/CoreAudio.

### 5.2 Реакция
- **Временные ошибки**:
  - Не считаем смертью системы,
  - Устройство в short-term blacklist,
  - Пробуем fallback, система работает дальше на другом устройстве.
- **Фатальные ошибки**:
  - Фиксируем состояние `*_UNAVAILABLE`,
  - Логируем на уровне `error/critical`,
  - Можно давать фидбек пользователю (голосом/логом).

### 5.3 UX-принцип
- Никогда не зависаем молча. Если звук/микрофон недоступны, ассистент проговаривает это или логирует и прекращает транслировать неверную работу.

## 6. Структура модулей и интеграций

1. **CoreAudioDeviceManager** — только macOS/CoreAudio, возвращает `DeviceInfo` и UID и служит источником истины по устройствам.
2. **DevicePolicy** — хранит приоритеты, тайминги, retry/fallback-стратегии, BT-отдельности.
3. **DeviceChangePublisher** — следит за default’ами, делает pinning, публикует `device.default_*_changed` через `EventBus`.
4. **AudioStreamManager** — входит в слой потоков, управляет PortAudio-стримами, применяет `DevicePolicy`.
5. **InputProcessingIntegration** — реагирует на клавиши, создаёт события `voice.recording_*`, хранит state-machine (`IDLE → PENDING → LISTENING → PROCESSING`).
6. **SpeechRecognizer** — работает с `AudioStreamManager`, обрабатывает `voice.recording_start/stop`, не делает прямых вызовов на CoreAudio.
7. **SpeechPlaybackIntegration** — координирует воспроизведение, подписывается на `EventBus`, реагирует на `device.default_output_changed`, службы прерывания/сессий.
8. **SequentialSpeechPlayer** — запрашивает output-потоки у `AudioStreamManager`, хранит буфер, выполняет play/pause/resume, не знает про CoreAudio напрямую.
9. **EventBus** — главная шина: все кросс-подсистемные события проходят через неё, payload — самодостаточный.

## 7. Как пользоваться blueprint’ом

Перед каждым изменением (выбор устройства, обработка ошибок, переключение):
1. Проверить слои: не тянем ли мы `CoreAudio`/`PortAudio` в домен.
2. Использовать `DevicePolicy` для принятия решений — не добавляем ad-hoc `if`.
3. Следовать pinning: если UID unchanged и поток жив, ничего не пересоздаём.
4. Обеспечить fallback и понятную реакцию на ошибки (логи, `*_UNAVAILABLE`, голосовой фидбек).
5. Для cross-подсистемных историй использовать `EventBus`.
6. Никаких логик по имени устройства — только UID/CoreAudio ID.

Если на всё «да» — новая логика вписывается в это идеальное состояние.
