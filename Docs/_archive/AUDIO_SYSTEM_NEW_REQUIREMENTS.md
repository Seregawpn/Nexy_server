# Требования к новой аудиосистеме Nexy

**Дата создания:** 2025-01-XX  
**Статус:** Планирование  
**Owner:** Tech Lead клиента

---

## Назначение документа

Этот документ определяет требования к новой аудиосистеме управления устройствами для Nexy. Предполагается, что текущие модули и интеграции по управлению аудиосистемой отсутствуют, и система создается с нуля.

**Цель:** Создать простую, надежную и эффективную аудиосистему, которая:
- Мгновенно адаптируется к устройствам
- Соответствует текущим библиотекам проекта
- Учитывает уровень шума
- Позволяет переключать разные устройства
- Правильно интегрируется с остальным кодом без дублей

---

## 1. ОБЩИЕ ПРИНЦИПЫ И АРХИТЕКТУРА

### 1.1 Архитектурные принципы

**REQ-AUDIO-001: Событийная архитектура (EventBus)**
- **Критичность:** MUST
- **Описание:** Вся коммуникация между компонентами аудиосистемы происходит через EventBus. Никаких прямых вызовов между модулями.
- **Источник:** `.cursorrules` раздел 1.2, `Docs/ARCHITECTURE_OVERVIEW.md`
- **Ожидаемый результат:** Все события аудиосистемы публикуются/подписываются через EventBus
- **Implementation:** `integration/integrations/audio_system_integration.py`
- **Verification:** Логи событий, проверка отсутствия прямых вызовов

**REQ-AUDIO-002: Разделение ответственности**
- **Критичность:** MUST
- **Описание:** 
  - **Модули** (`modules/audio_system/`) - низкоуровневая логика (работа с PortAudio, Core Audio, sounddevice)
  - **Интеграция** (`integration/integrations/audio_system_integration.py`) - адаптер между модулем и EventBus
  - **Core** (`integration/core/`) - инфраструктура (EventBus, StateManager, ErrorHandler)
- **Источник:** `.cursorrules` раздел 3, 14.1
- **Ожидаемый результат:** Четкое разделение слоев без смешивания ответственности
- **Implementation:** Структура модулей и интеграций
- **Verification:** Ревью кода, проверка отсутствия прямых зависимостей

**REQ-AUDIO-003: Единый источник истины для устройств**
- **Критичность:** MUST
- **Описание:** Единый компонент `DeviceManager` является источником истины для всех устройств (INPUT и OUTPUT). Все остальные компоненты получают информацию об устройствах только через этот компонент.
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 4.1
- **Ожидаемый результат:** Нет дублирования логики определения устройств
- **Implementation:** `modules/audio_system/core/device_manager.py`
- **Verification:** Проверка отсутствия дублирования кода определения устройств

**REQ-AUDIO-004: Запрет дублирования кода**
- **Критичность:** MUST
- **Описание:** Вся логика работы с устройствами (определение Bluetooth, поиск device_id, получение системного default) должна быть в одном месте. Запрещено дублирование функций `is_bluetooth_device()`, `find_device_id()`, `get_system_default()` в разных модулях.
- **Источник:** `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md` раздел 6
- **Ожидаемый результат:** Все утилиты работы с устройствами в `modules/audio_system/utils/device_utils.py`
- **Implementation:** `modules/audio_system/utils/device_utils.py`
- **Verification:** `scripts/check_code_duplication.py`, ревью кода

### 1.2 Централизация и предотвращение конфликтов

**REQ-AUDIO-004A: Централизованное управление устройствами**
- **Критичность:** MUST
- **Описание:** Все операции с устройствами (определение, переключение, мониторинг) должны выполняться через единый компонент `DeviceManager`. Запрещено прямое обращение к системным API (SwitchAudioSource, PortAudio, Core Audio) из других модулей, кроме `DeviceManager` и `DeviceUtils`.
- **Источник:** `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md`, `Docs/CODE_ANALYSIS_DUPLICATES_CONFLICTS.md`
- **Ожидаемый результат:** Все модули используют `DeviceManager` для работы с устройствами, нет прямых вызовов системных API
- **Implementation:** 
  - `modules/audio_system/core/device_manager.py` - единый менеджер устройств
  - `modules/audio_system/utils/device_utils.py` - утилиты работы с устройствами
  - Запрет прямых импортов `SwitchAudioSource`, `sd.query_devices()` в других модулях
- **Verification:** 
  - `scripts/check_code_duplication.py` - проверка отсутствия дублирования
  - `scripts/verify_no_direct_state_access.py` - проверка отсутствия прямых вызовов
  - Ревью кода на наличие прямых вызовов системных API

**REQ-AUDIO-004B: Единый источник истины для состояний устройств**
- **Критичность:** MUST
- **Описание:** Состояния устройств (текущее INPUT/OUTPUT устройство, параметры, статус) хранятся только в `DeviceStateCache`. Запрещено дублирование состояния устройств в других модулях (локальные переменные `_current_device`, `_device_name`, `_device_id` и т.д.).
- **Источник:** `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 2.1.3, `Docs/CODE_ANALYSIS_DUPLICATES_CONFLICTS.md`
- **Ожидаемый результат:** Все модули читают состояние устройств из `DeviceStateCache`, нет локальных копий состояния
- **Implementation:** 
  - `modules/audio_system/core/device_state_cache.py` - единый кэш состояний
  - Все модули получают `DeviceStateCache` через конструктор или через `DeviceManager`
- **Verification:** 
  - Поиск паттернов: `_current_device`, `_device_name`, `_device_id` в коде
  - Проверка, что все модули используют `DeviceStateCache` вместо локальных переменных

**REQ-AUDIO-004C: Запрет дублирования логики определения устройств**
- **Критичность:** MUST
- **Описание:** Запрещено дублирование следующих функций в разных модулях:
  - `is_bluetooth_device(name)` - определение Bluetooth устройств
  - `is_remote_device(name)` - определение remote устройств
  - `is_builtin_device(name)` - определение встроенных устройств
  - `find_device_id_by_name(name, direction)` - поиск device_id по имени
  - `get_system_default_device(direction)` - получение системного default устройства
  - `classify_device(name, direction)` - классификация устройства
  - `build_stream_config(...)` - построение конфигурации потока
- **Источник:** `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md` раздел 6, `Docs/AUDIO_DUPLICATION_ANALYSIS.md`
- **Ожидаемый результат:** Все функции находятся только в `modules/audio_system/utils/device_utils.py`
- **Implementation:** 
  - `modules/audio_system/utils/device_utils.py` - единый модуль утилит
  - Все модули импортируют функции из `device_utils`, не дублируют их
- **Verification:** 
  - `scripts/check_code_duplication.py` - поиск дублирования функций
  - Grep по именам функций в коде (должны быть только в `device_utils.py`)

**REQ-AUDIO-004D: Запрет конфликтов при мониторинге устройств**
- **Критичность:** MUST
- **Описание:** Мониторинг изменений устройств должен выполняться только через `DeviceMonitor`. Запрещено:
  - Параллельный polling устройств в разных модулях
  - Дублирование подписок на Core Audio нотификации
  - Синхронные вызовы `SwitchAudioSource` в callback'ах или критических путях
  - Проверка устройств при каждом чанке аудио (только при инициализации и смене)
- **Источник:** `Docs/AUDIO_DUPLICATION_ANALYSIS.md`, `Docs/AUDIO_DEVICE_CHECK_AUDIT_FIXES.md`
- **Ожидаемый результат:** 
  - Только `DeviceMonitor` опрашивает устройства
  - Все модули подписываются на события `audio.device.input_changed` / `audio.device.output_changed`
  - Нет синхронных вызовов `SwitchAudioSource` в callback'ах
- **Implementation:** 
  - `modules/audio_system/core/device_monitor.py` - единый мониторинг
  - Все модули подписываются на события, не опрашивают устройства напрямую
  - Асинхронные вызовы `SwitchAudioSource` через `asyncio.create_task()`
- **Verification:** 
  - Поиск паттернов: `subprocess.run.*SwitchAudioSource`, `sd.query_devices()` в callback'ах
  - Проверка, что только `DeviceMonitor` опрашивает устройства
  - Проверка отсутствия проверок устройств в `add_audio_data()`, `_audio_callback()`

**REQ-AUDIO-004E: Запрет дублирования управления потоками**
- **Критичность:** MUST
- **Описание:** Управление PortAudio потоками должно выполняться только через `StreamManager` (или `InputStreamManager`/`OutputStreamManager`). Запрещено:
  - Прямое создание/закрытие потоков через `sd.InputStream`/`sd.OutputStream` в других модулях
  - Дублирование логики создания потоков (retry, обработка ошибок, нормализация параметров)
  - Локальные менеджеры потоков в модулях (например, `AudioStreamManager` в `SpeechRecognizer`)
- **Источник:** `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 11.2, `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md`
- **Ожидаемый результат:** 
  - Все модули используют `StreamManager` для создания/закрытия потоков
  - Нет прямых вызовов `sd.InputStream()`/`sd.OutputStream()` в других модулях
  - Вся логика retry и обработки ошибок в `StreamManager`
- **Implementation:** 
  - `modules/audio_system/core/stream_manager.py` - единый менеджер потоков
  - `modules/audio_system/core/input_stream_manager.py` - менеджер INPUT потоков
  - `modules/audio_system/core/output_stream_manager.py` - менеджер OUTPUT потоков
- **Verification:** 
  - Поиск паттернов: `sd.InputStream(`, `sd.OutputStream(` в коде (должны быть только в StreamManager)
  - Проверка, что все модули используют StreamManager

**REQ-AUDIO-004F: Запрет дублирования обработки аудио**
- **Критичность:** MUST
- **Описание:** Обработка аудио данных (нормализация, ресемплинг, конвертация каналов, расчет RMS) должна быть централизована. Запрещено дублирование функций:
  - `normalize_audio()` - нормализация аудио данных
  - `resample_audio()` - ресемплинг аудио
  - `convert_channels()` - конвертация каналов
  - `calculate_rms()` - расчет RMS уровня шума
  - `detect_silence()` - обнаружение тишины
- **Источник:** `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md`, анализ кода
- **Ожидаемый результат:** Все функции обработки аудио в `modules/audio_system/utils/audio_utils.py`
- **Implementation:** 
  - `modules/audio_system/utils/audio_utils.py` - единый модуль утилит обработки аудио
  - Все модули импортируют функции из `audio_utils`, не дублируют их
- **Verification:** 
  - `scripts/check_code_duplication.py` - поиск дублирования функций
  - Grep по именам функций в коде (должны быть только в `audio_utils.py`)

**REQ-AUDIO-004G: Запрет конфликтов при публикации событий**
- **Критичность:** MUST
- **Описание:** События смены устройств должны публиковаться только один раз при каждом изменении. Запрещено:
  - Дублирование публикации событий `audio.device.input_changed` / `audio.device.output_changed`
  - Публикация событий из разных мест (DeviceMonitor и локальные проверки)
  - Публикация событий без debounce при быстрой смене устройств
- **Источник:** `Docs/AUDIO_DUPLICATION_ANALYSIS.md`, `Docs/AUDIO_DEVICE_CHECK_AUDIT_FIXES.md`
- **Ожидаемый результат:** 
  - События публикуются только из `DeviceMonitor`
  - Debounce механизм предотвращает множественные публикации при быстрой смене
  - Нет дублирования событий в логах
- **Implementation:** 
  - `modules/audio_system/core/device_monitor.py` - единственное место публикации событий
  - Debounce механизм (300ms) для rapid device switch
- **Verification:** 
  - Логи событий - проверка отсутствия дублирования
  - Тесты - проверка, что событие публикуется только один раз

**REQ-AUDIO-004H: Централизованная конфигурация**
- **Критичность:** MUST
- **Описание:** Все параметры конфигурации аудиосистемы должны быть в `config/unified_config.yaml` в разделе `audio_system`. Запрещено:
  - Hardcoded значения параметров в коде
  - Дублирование конфигурации в разных модулях
  - Локальные конфигурационные файлы для аудиосистемы
- **Источник:** `.cursorrules` раздел 6, `config/unified_config.yaml`
- **Ожидаемый результат:** 
  - Все параметры в `unified_config.yaml`
  - Нет hardcoded значений в коде
  - Все модули читают конфигурацию через `UnifiedConfigLoader`
- **Implementation:** 
  - `config/unified_config.yaml` раздел `audio_system`
  - Все модули используют `UnifiedConfigLoader` для чтения конфигурации
- **Verification:** 
  - Поиск hardcoded значений: `sample_rate=`, `channels=`, `blocksize=` в коде
  - Проверка, что все модули используют `UnifiedConfigLoader`

**Acceptance Criteria для централизации:**
- ✅ **Проверка дублирования:** Скрипт `scripts/check_code_duplication.py` не находит дублирования функций работы с устройствами
- ✅ **Проверка прямых вызовов:** Скрипт `scripts/verify_no_direct_state_access.py` не находит прямых вызовов системных API
- ✅ **Единый источник истины:** Все модули используют `DeviceManager` и `DeviceStateCache` для работы с устройствами
- ✅ **Единые утилиты:** Все функции работы с устройствами и обработки аудио в `device_utils.py` и `audio_utils.py`
- ✅ **Единый мониторинг:** Только `DeviceMonitor` опрашивает устройства и публикует события
- ✅ **Единое управление потоками:** Все модули используют `StreamManager` для создания/закрытия потоков
- ✅ **Нет конфликтов:** Логи не показывают дублирование событий или конфликты при работе с устройствами

---

## 2. ТРЕБОВАНИЯ К БИБЛИОТЕКАМ И ЗАВИСИМОСТЯМ

### 2.1 Используемые библиотеки

**REQ-AUDIO-005: Совместимость с текущими библиотеками**
- **Критичность:** MUST
- **Описание:** Аудиосистема должна использовать только библиотеки, уже присутствующие в проекте:
  - `sounddevice` (0.5.2) - для воспроизведения аудио
  - `PyAudio` (0.2.14) - для захвата аудио с микрофона
  - `pydub` (0.25.1) - для обработки аудио
  - `numpy` (2.3.3) - для численных операций
  - `PyObjC-framework-CoreAudio` (11.1) - для работы с Core Audio API
  - `PyObjC-framework-AVFoundation` (11.1) - для работы с AVFoundation
- **Источник:** `requirements.txt`, `MACOS_PACKAGING_REQUIREMENTS.md`
- **Ожидаемый результат:** Нет новых зависимостей в requirements.txt
- **Implementation:** Все модули используют только существующие библиотеки
- **Verification:** `scripts/check_dependencies.py`, проверка requirements.txt

**REQ-AUDIO-006: Использование SwitchAudioSource**
- **Критичность:** MUST
- **Описание:** Для получения системного default устройства используется бинарный файл `SwitchAudioSource` из `resources/audio/SwitchAudioSource`. Это единственный источник истины для имени устройства.
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 4.1
- **Ожидаемый результат:** Все запросы default устройства идут через SwitchAudioSource
- **Implementation:** `modules/audio_system/utils/device_utils.py::get_system_default_device()`
- **Verification:** Логи использования SwitchAudioSource

**REQ-AUDIO-007: Использование PortAudio для device_id**
- **Критичность:** MUST
- **Описание:** PortAudio используется только для получения `device_id` по имени устройства. Не используется как источник истины для default устройства.
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 4.1
- **Ожидаемый результат:** PortAudio используется только для поиска ID по имени
- **Implementation:** `modules/audio_system/utils/device_utils.py::find_device_id_by_name()`
- **Verification:** Логи использования PortAudio

**REQ-AUDIO-007A: Обязательное использование CoreAudio UID**
- **Критичность:** MUST
- **Описание:** 
  - **DeviceDescriptor всегда содержит CoreAudio UID** - это единственный стабильный идентификатор устройства, который не меняется при переподключении
  - Все маппинги `SwitchAudioSource name → PortAudio device_id → CoreAudio UID` делает исключительно `DeviceManager`
  - Все маппинги кэшируются для быстрого доступа
  - UID используется для сравнения устройств (не имя, не device_id)
  - Если UID недоступен (старые системы) - используется fallback на имя устройства
- **Источник:** `Docs/AUDIO_SYSTEM_REBUILD_BLUEPRINT.md` раздел 3.1, `modules/audio_core/types.py`
- **Ожидаемый результат:** 
  - Все `DeviceDescriptor` содержат валидный `uid`
  - Все сравнения устройств используют `uid`, а не `name` или `device_id`
  - Маппинги кэшируются и обновляются при изменении устройств
- **Implementation:** 
  - `DeviceManager.get_device_by_uid()` - получение устройства по UID
  - `DeviceManager._build_device_mapping()` - построение маппинга name → device_id → UID
  - `DeviceManager._cache_device_mapping()` - кэширование маппингов
  - `DeviceStateCache` использует UID для хранения текущего устройства
- **Verification:** 
  - Тесты проверяют наличие UID во всех DeviceDescriptor
  - Тесты проверяют, что сравнения устройств используют UID
  - Логи показывают использование UID для сравнения устройств

**REQ-AUDIO-007B: Режим "следовать системе" vs "прибитое устройство"**
- **Критичность:** SHOULD
- **Описание:** 
  - Система поддерживает два режима работы с устройствами:
    1. **`follow_system_default: true`** (по умолчанию) - автоматически следует за системным default устройством
    2. **`follow_system_default: false`** - использует прибитое устройство (pinned device), игнорирует системные изменения
  - При `follow_system_default: false` можно указать `pinned_input_device_uid` и `pinned_output_device_uid`
  - Приоритет устройства: `pinned_device_uid` > `system_default` > `fallback_device`
  - Режим можно менять динамически через конфиг или EventBus событие
- **Источник:** `Docs/AUDIO_SYSTEM_REBUILD_BLUEPRINT.md` раздел 3.3
- **Ожидаемый результат:** 
  - Система корректно работает в обоих режимах
  - При смене режима происходит корректное переключение устройства
  - Логи показывают текущий режим и выбранное устройство
- **Implementation:** 
  - `config/unified_config.yaml.audio_system.follow_system_default: bool`
  - `config/unified_config.yaml.audio_system.pinned_input_device_uid: Optional[str]`
  - `config/unified_config.yaml.audio_system.pinned_output_device_uid: Optional[str]`
  - `DeviceManager.get_active_device(direction)` - возвращает pinned или system default
  - `DeviceMonitor` учитывает режим при публикации событий
- **Verification:** 
  - Тесты проверяют работу в обоих режимах
  - Тесты проверяют приоритет устройств (pinned > system > fallback)
  - Логи показывают режим и выбранное устройство

---

## 3. ТРЕБОВАНИЯ К МГНОВЕННОЙ АДАПТАЦИИ К УСТРОЙСТВАМ

### 3.1 Обнаружение изменений устройств

**REQ-AUDIO-008: Мгновенное обнаружение смены default устройства**
- **Критичность:** MUST
- **Описание:** Система должна обнаруживать смену default INPUT/OUTPUT устройства за < 500ms через Core Audio нотификации. При недоступности Core Audio используется polling fallback с интервалом 2.0 сек.
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 1.4, `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 2.1.5
- **Ожидаемый результат:** Смена устройства обнаруживается за < 500ms (p95)
- **Implementation:** `modules/audio_system/core/device_monitor.py`
- **Verification:** Тесты производительности, логи времени обнаружения

**REQ-AUDIO-008A: Постоянный мониторинг подключения новых устройств**
- **Критичность:** MUST
- **Описание:** Система должна **постоянно** мониторить подключение новых устройств и смену default устройства в течение всего времени работы приложения. Мониторинг не останавливается после инициализации и работает непрерывно.
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 1.4
- **Ожидаемый результат:** 
  - Мониторинг работает непрерывно с момента старта до завершения приложения
  - Новые устройства обнаруживаются сразу после подключения
  - Смена default устройства обнаруживается мгновенно
- **Implementation:** 
  - `modules/audio_system/core/device_monitor.py::start_monitoring()` - запускается при инициализации и работает постоянно
  - Core Audio нотификации работают в фоновом режиме
  - Polling fallback работает в отдельном потоке (daemon thread)
- **Verification:** 
  - Логи показывают непрерывную работу мониторинга
  - Тесты проверяют обнаружение устройств через длительное время работы
  - Проверка, что мониторинг не останавливается после инициализации

**REQ-AUDIO-008B: Обнаружение новых подключенных устройств**
- **Критичность:** MUST
- **Описание:** Система должна обнаруживать не только смену default устройства, но и **подключение новых устройств** (например, пользователь надевает AirPods, подключает USB-микрофон). При обнаружении нового устройства система должна автоматически переключиться на него, если он становится default устройством.
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 1.4, `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 2.1.5
- **Ожидаемый результат:** 
  - Новые устройства обнаруживаются сразу после подключения
  - Если новое устройство становится default, система автоматически переключается на него
  - Переключение происходит мгновенно (< 500ms для обнаружения + < 200ms для переключения)
- **Implementation:** 
  - `DeviceMonitor` отслеживает изменения UID default устройства через Core Audio
  - При обнаружении нового UID система определяет, что это новое устройство
  - Автоматическое переключение через `StreamManager.switch_device()`
- **Verification:** 
  - Тесты: подключение нового устройства → обнаружение → переключение
  - Логи показывают обнаружение новых устройств и автоматическое переключение
  - Проверка времени от подключения до переключения (< 700ms total)

**REQ-AUDIO-008C: Мгновенное переключение при обнаружении нового устройства**
- **Критичность:** MUST
- **Описание:** При обнаружении нового устройства, которое становится default, система должна **мгновенно** переключиться на него без ожидания пользовательского действия. Переключение должно происходить автоматически и прозрачно для пользователя.
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 1.4, `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 3.1.3, 4.1.2
- **Ожидаемый результат:** 
  - Переключение происходит автоматически при обнаружении нового default устройства
  - Переключение не требует действий пользователя
  - Переключение происходит мгновенно (< 200ms для INPUT, < 100ms для OUTPUT)
  - Переключение не прерывает активные операции (запись/воспроизведение продолжаются)
- **Implementation:** 
  - `DeviceMonitor` публикует событие `audio.device.input_changed` / `audio.device.output_changed`
  - Подписчики (`VoiceRecognitionIntegration`, `SpeechPlaybackIntegration`) автоматически переключаются
  - `StreamManager.switch_device()` обеспечивает плавное переключение без потери данных
- **Verification:** 
  - Тесты: обнаружение нового устройства → автоматическое переключение
  - Логи показывают автоматическое переключение без пользовательских действий
  - Проверка, что активные операции не прерываются при переключении

**REQ-AUDIO-009: Подписка на Core Audio нотификации**
- **Критичность:** MUST
- **Описание:** При старте приложения система подписывается на Core Audio нотификации:
  - `kAudioHardwarePropertyDefaultInputDevice` - для INPUT устройств
  - `kAudioHardwarePropertyDefaultOutputDevice` - для OUTPUT устройств
- **Источник:** `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 2.1.4
- **Ожидаемый результат:** Подписка на нотификации работает, события обрабатываются < 50ms
- **Implementation:** `modules/audio_system/core/device_monitor.py::start_monitoring()`
- **Verification:** Логи подписки, тесты нотификаций

**REQ-AUDIO-010: Polling fallback**
- **Критичность:** MUST
- **Описание:** Если Core Audio нотификации недоступны, используется polling fallback с интервалом 2.0 сек. Polling запускается всегда (даже если Core Audio работает) для гарантированного обнаружения изменений.
- **Источник:** `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 2.1.5
- **Ожидаемый результат:** Polling работает как fallback и гарантирует обнаружение изменений
- **Implementation:** `modules/audio_system/core/device_monitor.py::_polling_fallback()`
- **Verification:** Тесты fallback, логи polling

### 3.2 Адаптация к устройству

**REQ-AUDIO-011: Автоматическое определение параметров устройства**
- **Критичность:** MUST
- **Описание:** При обнаружении нового устройства система автоматически определяет его параметры:
  - `sample_rate` - частота дискретизации
  - `channels` - количество каналов
  - `blocksize` - размер блока
  - `latency` - задержка
  - `is_bluetooth` - флаг Bluetooth устройства
- **Источник:** `config/unified_config.yaml` раздел `default_audio.normalization`
- **Ожидаемый результат:** Параметры устройства определяются автоматически при первом использовании
- **Implementation:** `modules/audio_system/core/device_manager.py::get_device_params()`
- **Verification:** Тесты определения параметров, логи параметров

**REQ-AUDIO-011A: Получение всех необходимых данных для настройки устройства**
- **Критичность:** MUST
- **Описание:** Перед переключением на новое устройство система должна получить **все необходимые данные** для правильной настройки INPUT/OUTPUT:
  - **Обязательные данные:**
    - `device_name` - имя устройства (из SwitchAudioSource)
    - `device_id` - PortAudio ID (или None для BT устройств)
    - `uid` - уникальный идентификатор устройства (Core Audio UID)
    - `is_bluetooth` - флаг Bluetooth устройства
  - **Параметры для INPUT:**
    - `sample_rate` - частота дискретизации (определяется из устройства или fallback)
    - `channels` - количество каналов (всегда 1 для INPUT/ASR)
    - `blocksize` - размер блока (опционально, для BT не задается)
    - `latency` - задержка (опционально, для BT не задается)
  - **Параметры для OUTPUT:**
    - `sample_rate` - частота дискретизации (определяется из устройства или fallback)
    - `channels` - количество каналов (1-2, определяется из устройства)
    - `blocksize` - размер блока (опционально, для BT не задается)
    - `latency` - задержка (опционально, для BT не задается)
- **Источник:** `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 6.5, `config/unified_config.yaml`
- **Ожидаемый результат:** Все необходимые данные получены и валидированы перед переключением
- **Implementation:** 
  - `DeviceManager.get_device_by_uid()` - получение всех данных устройства
  - `DeviceManager.get_device_params()` - получение параметров устройства
  - `DeviceManager.normalize_device_params()` - нормализация параметров
  - Валидация данных перед использованием
- **Verification:** 
  - Тесты проверяют получение всех необходимых данных
  - Логи показывают все полученные параметры перед переключением
  - Проверка, что переключение не происходит без полных данных

**REQ-AUDIO-011B: Валидация данных устройства перед переключением**
- **Критичность:** MUST
- **Описание:** Перед переключением на новое устройство система должна **валидировать** все полученные данные:
  - Проверка наличия обязательных данных (device_name, uid, is_bluetooth)
  - Проверка корректности параметров (sample_rate в допустимом диапазоне, channels > 0)
  - Проверка доступности устройства (устройство существует в PortAudio или является BT)
  - Проверка совместимости параметров (для INPUT: channels=1, для OUTPUT: channels ≤ 2)
- **Источник:** `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md` раздел 1 (ошибки -9986, -10851)
- **Ожидаемый результат:** 
  - Переключение происходит только при валидных данных
  - При невалидных данных публикуется ошибка и переключение не происходит
  - Логи показывают причину отказа в переключении
- **Implementation:** 
  - `DeviceManager.validate_device_data()` - валидация данных устройства
  - `DeviceManager.validate_device_params()` - валидация параметров устройства
  - Проверка перед вызовом `StreamManager.switch_device()`
- **Verification:** 
  - Тесты с невалидными данными (отсутствие device_name, некорректные параметры)
  - Логи показывают валидацию и причины отказа
  - Проверка, что переключение не происходит при невалидных данных

**REQ-AUDIO-011C: Обработка ошибок при получении данных устройства**
- **Критичность:** MUST
- **Описание:** При ошибках получения данных устройства система должна:
  - Обрабатывать ошибки SwitchAudioSource (таймаут, отсутствие бинарного файла)
  - Обрабатывать ошибки PortAudio (устройство не найдено, недоступно)
  - Обрабатывать ошибки Core Audio (нотификации недоступны)
  - Использовать fallback стратегии (системный дефолт, кэшированные данные)
  - Публиковать события ошибок с контекстом
- **Источник:** `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md`, `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 10
- **Ожидаемый результат:** 
  - Ошибки получения данных обрабатываются gracefully
  - Система использует fallback вместо отказа
  - Пользователь не видит ошибок, система продолжает работать
- **Implementation:** 
  - `DeviceManager.get_device_by_uid()` - обработка ошибок SwitchAudioSource/PortAudio
  - `DeviceManager.get_device_params()` - обработка ошибок получения параметров
  - Fallback на системный дефолт при ошибках
  - Публикация событий `audio.device.error` с контекстом
- **Verification:** 
  - Тесты с ошибками получения данных (SwitchAudioSource недоступен, PortAudio ошибки)
  - Проверка fallback стратегий
  - Логи показывают обработку ошибок и использование fallback

**REQ-AUDIO-012: Нормализация параметров устройства**
- **Критичность:** MUST
- **Описание:** Параметры устройства нормализуются согласно конфигурации:
  - INPUT: `sample_rate` нормализуется до диапазона 16000-48000 Hz, `channels=1` (моно)
  - OUTPUT: `sample_rate` нормализуется до диапазона 16000-48000 Hz, `channels` до максимум 2 (стерео)
- **Источник:** `config/unified_config.yaml` раздел `default_audio.normalization`
- **Ожидаемый результат:** Параметры устройств нормализуются согласно конфигурации
- **Implementation:** `modules/audio_system/core/device_manager.py::normalize_device_params()`
- **Verification:** Тесты нормализации, логи параметров

**REQ-AUDIO-012A: Совместимость параметров с библиотеками записи**
- **Критичность:** MUST
- **Описание:** Параметры INPUT потока должны быть совместимы с библиотеками, которые принимают речь:
  - **SpeechRecognition библиотека** требует:
    - `sample_rate`: 16000 Hz (стандарт для ASR)
    - `channels`: 1 (моно)
    - `dtype`: int16
    - Формат данных: `sr.AudioData(audio_bytes, sample_rate=16000, sample_width=2)`
  - **PyAudio/sounddevice** для записи:
    - Получает данные в формате float32 из PortAudio
    - Конвертирует в int16 для SpeechRecognition: `(audio_float * 32767.0).astype(np.int16).tobytes()`
  - **Ресемплинг:** Если устройство работает на другом sample_rate (например, 48000 Hz), данные ресемплятся до 16000 Hz перед передачей в SpeechRecognition
- **Источник:** `modules/voice_recognition/core/speech_recognizer.py`, `modules/voice_recognition/core/types.py`
- **Ожидаемый результат:** 
  - Все данные для SpeechRecognition в формате int16, 16000 Hz, моно
  - Ресемплинг выполняется автоматически при необходимости
  - Конвертация форматов происходит без потери качества
- **Implementation:** 
  - `InputStreamManager` создает потоки с параметрами устройства
  - `AudioUtils.resample_audio()` - ресемплинг до 16000 Hz
  - `AudioUtils.normalize_audio()` - нормализация и конвертация в int16
  - `SpeechRecognizer._recognize_audio()` - конвертация в формат для SpeechRecognition
- **Verification:** 
  - Тесты проверяют формат данных перед передачей в SpeechRecognition
  - Логи показывают ресемплинг и конвертацию форматов
  - Проверка, что SpeechRecognition получает данные в правильном формате

**REQ-AUDIO-012B: Совместимость параметров с библиотеками воспроизведения**
- **Критичность:** MUST
- **Описание:** Параметры OUTPUT потока должны быть совместимы с библиотеками воспроизведения:
  - **sounddevice** для воспроизведения:
    - Принимает данные в формате int16 или float32
    - `sample_rate`: 48000 Hz (стандарт для воспроизведения)
    - `channels`: 1 (моно) или 2 (стерео)
    - Формат данных: `np.ndarray` с dtype=int16 или float32
  - **pydub** для обработки аудио:
    - Работает с различными форматами (MP3, WAV, FLAC)
    - Конвертирует в нужный формат для воспроизведения
  - **Конвертация каналов:** Если данные моно, а устройство стерео - конвертация через `convert_channels()`
  - **Ресемплинг:** Если данные на другом sample_rate, ресемплинг до 48000 Hz
- **Источник:** `modules/speech_playback/core/player.py`, `modules/speech_playback/utils/audio_utils.py`
- **Ожидаемый результат:** 
  - Все данные для воспроизведения в формате int16 или float32, 48000 Hz, 1-2 канала
  - Конвертация каналов выполняется автоматически при необходимости
  - Ресемплинг выполняется автоматически при необходимости
- **Implementation:** 
  - `OutputStreamManager` создает потоки с параметрами устройства
  - `AudioUtils.resample_audio()` - ресемплинг до 48000 Hz
  - `AudioUtils.convert_channels()` - конвертация каналов (моно → стерео)
  - `SequentialSpeechPlayer._audio_callback()` - конвертация данных для sounddevice
- **Verification:** 
  - Тесты проверяют формат данных перед передачей в sounddevice
  - Логи показывают ресемплинг и конвертацию каналов
  - Проверка, что sounddevice получает данные в правильном формате

**REQ-AUDIO-012C: Правильная конвертация форматов данных**
- **Критичность:** MUST
- **Описание:** Система должна правильно конвертировать форматы данных между компонентами:
  - **INPUT поток → SpeechRecognition:**
    1. PortAudio возвращает данные в float32
    2. Конвертация в int16: `(audio_float * 32767.0).astype(np.int16)`
    3. Ресемплинг до 16000 Hz (если нужно)
    4. Конвертация каналов в моно (если нужно)
    5. Конвертация в bytes: `audio_int16.tobytes()`
    6. Создание `sr.AudioData(audio_bytes, sample_rate=16000, sample_width=2)`
  - **gRPC → OUTPUT поток:**
    1. gRPC возвращает данные в bytes (int16 PCM)
    2. Конвертация в numpy: `np.frombuffer(audio_bytes, dtype=np.int16)`
    3. Ресемплинг до 48000 Hz (если нужно)
    4. Конвертация каналов (моно → стерео, если нужно)
    5. Передача в sounddevice для воспроизведения
- **Источник:** `modules/voice_recognition/core/speech_recognizer.py`, `modules/speech_playback/core/player.py`
- **Ожидаемый результат:** 
  - Все конвертации выполняются без потери качества
  - Формат данных соответствует требованиям библиотек
  - Нет ошибок формата при передаче данных
- **Implementation:** 
  - `AudioUtils.normalize_audio()` - нормализация и конвертация типов
  - `AudioUtils.resample_audio()` - ресемплинг
  - `AudioUtils.convert_channels()` - конвертация каналов
  - Все конвертации в `modules/audio_system/utils/audio_utils.py`
- **Verification:** 
  - Тесты проверяют все конвертации форматов
  - Логи показывают каждую конвертацию с параметрами
  - Проверка отсутствия ошибок формата в логах

**REQ-AUDIO-013: Кэширование параметров устройства**
- **Критичность:** SHOULD
- **Описание:** Параметры устройства кэшируются для избежания повторных запросов. Кэш инвалидируется при смене устройства.
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 2.1.2
- **Ожидаемый результат:** Параметры устройства кэшируются и используются при повторных запросах
- **Implementation:** `modules/audio_system/core/device_manager.py::_device_cache`
- **Verification:** Тесты кэширования, логи использования кэша

---

## 4. ТРЕБОВАНИЯ К ПЕРЕКЛЮЧЕНИЮ УСТРОЙСТВ

### 4.1 Переключение INPUT устройств

**REQ-AUDIO-014: Переключение INPUT во время записи**
- **Критичность:** MUST
- **Описание:** При смене INPUT устройства во время записи система должна:
  1. Получение и валидация всех данных нового устройства
  2. Graceful stop старого потока (сохранение данных)
  3. Создание нового потока на новом устройстве с правильными параметрами
  4. Продолжение записи на новом устройстве без потери данных
- **Источник:** `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 3.1.3
- **Ожидаемый результат:** Переключение устройства во время записи не останавливает запись, данные не теряются
- **Implementation:** `modules/audio_system/core/input_stream_manager.py::switch_device()`
- **Verification:** Тесты переключения во время записи, логи переключения

**REQ-AUDIO-014A: Правильное переключение INPUT без ошибок**
- **Критичность:** MUST
- **Описание:** Переключение INPUT устройства должно происходить **без ошибок** и с правильной настройкой всех параметров:
  - **Перед переключением:**
    1. Получение всех данных нового устройства (device_name, device_id, uid, is_bluetooth)
    2. Получение параметров устройства (sample_rate, channels, blocksize, latency)
    3. Нормализация параметров согласно конфигурации
    4. Валидация данных и параметров
    5. Проверка доступности устройства
  - **Во время переключения:**
    1. Сохранение текущего буфера записи (не теряет данные)
    2. Graceful stop старого потока (ожидание active=False, задержка close_delay)
    3. Создание нового потока с правильными параметрами:
       - Для обычных устройств: device_id, sample_rate, channels=1, blocksize, latency
       - Для BT устройств: device=None, channels=1, без blocksize/latency
    4. Retry логика при ошибках создания потока
  - **После переключения:**
    1. Проверка успешности создания потока
    2. Восстановление буфера записи
    3. Продолжение записи на новом устройстве
- **Источник:** `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md` раздел 1 (ошибки -9986, -10851)
- **Ожидаемый результат:** 
  - Переключение происходит без ошибок PortAudio
  - Все параметры настроены правильно
  - Запись продолжается без потери данных
  - Нет ошибок -9986, -10851
- **Implementation:** 
  - `InputStreamManager.switch_device()` - полный процесс переключения
  - `DeviceManager.get_device_by_uid()` - получение данных
  - `DeviceManager.validate_device_data()` - валидация
  - `DeviceManager.normalize_device_params()` - нормализация параметров
- **Verification:** 
  - Тесты переключения с различными типами устройств (обычные, BT, USB)
  - Проверка отсутствия ошибок PortAudio при переключении
  - Логи показывают все этапы переключения и параметры
  - Проверка, что данные не теряются при переключении

**REQ-AUDIO-015: Время переключения INPUT устройства**
- **Критичность:** SHOULD
- **Описание:** Переключение INPUT устройства должно занимать < 200ms (p95) для обычных устройств и < 500ms для Bluetooth устройств.
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 7.1
- **Ожидаемый результат:** Переключение устройства занимает < 200ms (p95)
- **Implementation:** `modules/audio_system/core/input_stream_manager.py::switch_device()`
- **Verification:** Тесты производительности, метрики времени переключения

### 4.2 Переключение OUTPUT устройств

**REQ-AUDIO-016: Переключение OUTPUT во время воспроизведения**
- **Критичность:** MUST
- **Описание:** При смене OUTPUT устройства во время воспроизведения система должна:
  1. Получение и валидация всех данных нового устройства
  2. Сохранение буфера воспроизведения (не очистка)
  3. Graceful stop старого потока
  4. Создание нового потока на новом устройстве с правильными параметрами
  5. Продолжение воспроизведения без пауз
- **Источник:** `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 4.1.2
- **Ожидаемый результат:** Переключение устройства во время воспроизведения не прерывает воспроизведение, буфер сохраняется
- **Implementation:** `modules/audio_system/core/output_stream_manager.py::switch_device()`
- **Verification:** Тесты переключения во время воспроизведения, логи переключения

**REQ-AUDIO-016A: Правильное переключение OUTPUT без ошибок**
- **Критичность:** MUST
- **Описание:** Переключение OUTPUT устройства должно происходить **без ошибок** и с правильной настройкой всех параметров:
  - **Перед переключением:**
    1. Получение всех данных нового устройства (device_name, device_id, uid, is_bluetooth)
    2. Получение параметров устройства (sample_rate, channels, blocksize, latency)
    3. Нормализация параметров согласно конфигурации
    4. Валидация данных и параметров
    5. Проверка доступности устройства
  - **Во время переключения:**
    1. Сохранение буфера воспроизведения (ChunkBuffer не очищается)
    2. Graceful stop старого потока (ожидание active=False, задержка close_delay)
    3. Создание нового потока с правильными параметрами:
       - Для обычных устройств: device_id, sample_rate, channels (1-2), blocksize, latency
       - Для BT устройств: device=None, channels=1, без blocksize/latency
    4. Retry логика при ошибках создания потока
  - **После переключения:**
    1. Проверка успешности создания потока
    2. Восстановление буфера воспроизведения
    3. Продолжение воспроизведения на новом устройстве
- **Источник:** `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md` раздел 1 (ошибки -9986, -10851)
- **Ожидаемый результат:** 
  - Переключение происходит без ошибок PortAudio
  - Все параметры настроены правильно
  - Воспроизведение продолжается без пауз
  - Нет ошибок -9986, -10851
- **Implementation:** 
  - `OutputStreamManager.switch_device()` - полный процесс переключения
  - `DeviceManager.get_device_by_uid()` - получение данных
  - `DeviceManager.validate_device_data()` - валидация
  - `DeviceManager.normalize_device_params()` - нормализация параметров
- **Verification:** 
  - Тесты переключения с различными типами устройств (обычные, BT, USB)
  - Проверка отсутствия ошибок PortAudio при переключении
  - Логи показывают все этапы переключения и параметры
  - Проверка, что буфер сохраняется и воспроизведение продолжается

**REQ-AUDIO-017: Время переключения OUTPUT устройства**
- **Критичность:** SHOULD
- **Описание:** Переключение OUTPUT устройства должно занимать < 100ms (p95) для обычных устройств и < 300ms для Bluetooth устройств.
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 7.1
- **Ожидаемый результат:** Переключение устройства занимает < 100ms (p95)
- **Implementation:** `modules/audio_system/core/output_stream_manager.py::switch_device()`
- **Verification:** Тесты производительности, метрики времени переключения

### 4.3 Специальная обработка Bluetooth устройств

**REQ-AUDIO-018: Обработка Bluetooth устройств**
- **Критичность:** MUST
- **Описание:** Bluetooth устройства требуют специальной обработки:
  - Для INPUT: увеличенные задержки (bt_prestart_delay = 0.5s), увеличенные retry (max_stream_start_retries = 7)
  - Для OUTPUT: использование `device=None` (macOS управляет параметрами), увеличенные задержки (bt_prestart_delay = 2.5s, close_delay = 2.5s)
  - Не задаются `blocksize` и `latency` (macOS выбирает сам)
- **Источник:** `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 6.5, `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md` раздел 1
- **Ожидаемый результат:** Bluetooth устройства работают без ошибок PortAudio (-9986, -10851)
- **Implementation:** `modules/audio_system/core/device_manager.py::_handle_bluetooth_device()`
- **Verification:** Тесты Bluetooth устройств, логи работы с BT

**REQ-AUDIO-019: Определение Bluetooth устройств**
- **Критичность:** MUST
- **Описание:** Определение Bluetooth устройств должно быть централизовано в одной функции `is_bluetooth_device(name: str) -> bool`. Запрещено дублирование этой логики.
- **Источник:** `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md` раздел 6
- **Ожидаемый результат:** Все проверки Bluetooth устройств используют единую функцию
- **Implementation:** `modules/audio_system/utils/device_utils.py::is_bluetooth_device()`
- **Verification:** Проверка отсутствия дублирования, тесты определения BT

---

## 5. ТРЕБОВАНИЯ К УЧЕТУ УРОВНЯ ШУМА

### 5.1 Определение уровня шума

**REQ-AUDIO-020: Мониторинг уровня шума**
- **Критичность:** SHOULD
- **Описание:** Система должна мониторить уровень шума (RMS) входного аудио потока для:
  - Обнаружения тишины (окончание записи)
  - Обнаружения проблем с устройством (слишком тихий/громкий сигнал)
  - Адаптивной обработки аудио
- **Источник:** `config/unified_config.yaml` раздел `default_audio.health_check_interval_sec`
- **Ожидаемый результат:** Уровень шума мониторится и логируется
- **Implementation:** `modules/audio_system/core/input_stream_manager.py::_monitor_noise_level()`
- **Verification:** Тесты мониторинга шума, логи уровня шума

**Acceptance Criteria для REQ-AUDIO-020:**
- ✅ **Расчет RMS:** RMS вычисляется по формуле: `rms = sqrt(mean(audio_data.astype(float32) ** 2))`
  - Аудио данные конвертируются в `float32` для точности вычислений
  - RMS вычисляется для каждого чанка аудио данных
  - Результат нормализуется в диапазон [0.0, 1.0] для int16 данных (деление на 32767.0)
- ✅ **Интервал мониторинга:** Мониторинг выполняется с интервалом `health_check_interval_sec` (по умолчанию 1.0 сек)
  - RMS вычисляется для каждого чанка, но агрегируется (среднее/максимум) за интервал
  - Логирование происходит только при включенном флаге `log_health_checks: true`
- ✅ **Метрики:** Система логирует метрики:
  - `noise_level_rms` - текущий RMS уровень (float, диапазон 0.0-1.0)
  - `noise_level_peak` - пиковый уровень за интервал (float, диапазон 0.0-1.0)
  - `noise_level_avg` - средний RMS за интервал (float, диапазон 0.0-1.0)
- ✅ **Формат лога:** `[NOISE] RMS={rms:.6f}, peak={peak:.6f}, avg={avg:.6f}, device={device_name}`

**REQ-AUDIO-021: Адаптивная обработка по уровню шума**
- **Критичность:** SHOULD
- **Описание:** Система должна адаптировать обработку аудио в зависимости от уровня шума:
  - Нормализация громкости при слишком тихом/громком сигнале
  - Пропуск тихих чанков для экономии ресурсов
  - Предупреждение о проблемах с устройством
- **Источник:** `config/unified_config.yaml` раздел `default_audio.silent_window_seconds`
- **Ожидаемый результат:** Обработка аудио адаптируется к уровню шума
- **Implementation:** `modules/audio_system/core/input_stream_manager.py::_adapt_to_noise_level()`
- **Verification:** Тесты адаптивной обработки, логи адаптации

**Acceptance Criteria для REQ-AUDIO-021:**
- ✅ **Пороги адаптации:**
  - **Слишком тихий сигнал:** RMS < `noise_threshold_min` (по умолчанию 0.001) → предупреждение о проблеме с устройством
  - **Слишком громкий сигнал:** RMS > `noise_threshold_max` (по умолчанию 0.9) → нормализация громкости (деление на коэффициент)
  - **Нормальный сигнал:** `noise_threshold_min` ≤ RMS ≤ `noise_threshold_max` → обработка без изменений
- ✅ **Нормализация громкости:**
  - При RMS > 0.9: аудио данные умножаются на коэффициент `0.9 / rms` для предотвращения клиппинга
  - Нормализация применяется только к текущему чанку, не влияет на последующие
- ✅ **Пропуск тихих чанков:**
  - При RMS < `noise_threshold_min` (0.001) в течение `silent_window_seconds` (0.3 сек): чанк помечается как тихий
  - Тихие чанки не отправляются на обработку (экономия ресурсов), но учитываются в статистике
- ✅ **Предупреждения:**
  - При RMS < 0.001 в течение 3+ интервалов: публикуется событие `audio.device.low_signal{device_name, rms, duration_sec}`
  - При RMS > 0.9 в течение 3+ интервалов: публикуется событие `audio.device.high_signal{device_name, rms, duration_sec}`

**REQ-AUDIO-022: Обнаружение тишины**
- **Критичность:** SHOULD
- **Описание:** Система должна обнаруживать тишину для автоматического завершения записи. Параметры:
  - `silent_window_seconds` - окно оценки тишины (0.3 сек)
  - `silent_windows_threshold` - количество подряд окон тишины до перезапуска (2)
- **Источник:** `config/unified_config.yaml` раздел `default_audio.silent_window_seconds`
- **Ожидаемый результат:** Тишина обнаруживается и обрабатывается корректно
- **Implementation:** `modules/audio_system/core/input_stream_manager.py::_detect_silence()`
- **Verification:** Тесты обнаружения тишины, логи обнаружения

**Acceptance Criteria для REQ-AUDIO-022:**
- ✅ **Порог тишины:** Тишина определяется как RMS < `silence_threshold` (по умолчанию 0.01 для обнаружения, 0.001 для recovery)
  - Порог 0.01 используется для обнаружения тишины в конце записи (более чувствительный)
  - Порог 0.001 используется для recovery manager (более строгий, для обнаружения проблем с устройством)
- ✅ **Окно оценки:** Система анализирует тишину в окнах длительностью `silent_window_seconds` (0.3 сек)
  - В каждом окне вычисляется средний RMS
  - Если средний RMS < `silence_threshold`, окно считается "тихим"
- ✅ **Порог обнаружения:** Тишина считается обнаруженной после `silent_windows_threshold` (2) подряд тихих окон
  - Это означает тишину в течение минимум `silent_window_seconds * silent_windows_threshold` = 0.6 сек
  - После обнаружения публикуется событие `audio.silence.detected{duration_sec, rms_avg}`
- ✅ **Обработка обнаруженной тишины:**
  - Если запись активна: публикуется событие `voice.recording_stop` для завершения записи
  - Если устройство в recovery: запускается процесс восстановления (переключение устройства, пересоздание потока)
- ✅ **Сброс счетчика:** При обнаружении сигнала (RMS ≥ `silence_threshold`) счетчик тихих окон сбрасывается
- ✅ **Формат лога:** `[SILENCE] Detected: duration={duration_sec:.2f}s, rms_avg={rms_avg:.6f}, windows={windows_count}`

---

## 6. ТРЕБОВАНИЯ К ИНТЕГРАЦИИ С ОСТАЛЬНЫМ КОДОМ

### 6.1 Интеграция с EventBus

**REQ-AUDIO-023: Контракт EventBus для аудиосистемы**
- **Критичность:** MUST
- **Описание:** Аудиосистема должна иметь четкий контракт EventBus с документацией входных/выходных событий и payload схем. Формат событий: `audio.<action>` (например: `audio.device_changed`, `audio.stream_started`).
- **Источник:** `.cursorrules` раздел 16, `Docs/ARCHITECTURE_OVERVIEW.md`
- **Ожидаемый результат:** Контракт EventBus документирован в README модуля
- **Implementation:** `modules/audio_system/README.md`, комментарии CONTRACT в интеграции
- **Verification:** Ревью кода, проверка наличия контракта

**REQ-AUDIO-024: События смены устройств**
- **Критичность:** MUST
- **Описание:** При смене устройства система публикует события:
  - `audio.device.input_changed{device_name, device_id, is_bluetooth, old_device_name, old_device_id}`
  - `audio.device.output_changed{device_name, device_id, is_bluetooth, old_device_name, old_device_id}`
- **Источник:** `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 8.2
- **Ожидаемый результат:** События публикуются при каждой смене устройства
- **Implementation:** `integration/integrations/audio_system_integration.py::_publish_device_change()`
- **Verification:** Логи событий, тесты публикации событий

**REQ-AUDIO-025: Подписка на события режимов**
- **Критичность:** MUST
- **Описание:** Аудиосистема должна подписываться на события режимов (`app.mode_changed`) для адаптации работы в зависимости от режима (SLEEPING, LISTENING, PROCESSING).
- **Источник:** `Docs/ARCHITECTURE_OVERVIEW.md` раздел 1
- **Ожидаемый результат:** Аудиосистема адаптирует работу в зависимости от режима
- **Implementation:** `integration/integrations/audio_system_integration.py::_on_mode_changed()`
- **Verification:** Логи адаптации режимов, тесты режимов

### 6.2 Интеграция с существующими модулями

**REQ-AUDIO-026: Интеграция с VoiceRecognitionIntegration**
- **Критичность:** MUST
- **Описание:** Аудиосистема должна предоставлять `InputStreamManager` для использования `VoiceRecognitionIntegration`. `VoiceRecognitionIntegration` подписывается на `audio.device.input_changed` и использует `InputStreamManager` для создания потоков.
- **Источник:** `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 3.1.2
- **Ожидаемый результат:** VoiceRecognitionIntegration использует InputStreamManager без прямых вызовов
- **Implementation:** `integration/integrations/voice_recognition_integration.py`, использование InputStreamManager
- **Verification:** Тесты интеграции, логи использования InputStreamManager

**REQ-AUDIO-027: Интеграция с SpeechPlaybackIntegration**
- **Критичность:** MUST
- **Описание:** Аудиосистема должна предоставлять `OutputStreamManager` для использования `SpeechPlaybackIntegration`. `SpeechPlaybackIntegration` подписывается на `audio.device.output_changed` и использует `OutputStreamManager` для создания потоков.
- **Источник:** `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 4.1.1
- **Ожидаемый результат:** SpeechPlaybackIntegration использует OutputStreamManager без прямых вызовов
- **Implementation:** `integration/integrations/speech_playback_integration.py`, использование OutputStreamManager
- **Verification:** Тесты интеграции, логи использования OutputStreamManager

**REQ-AUDIO-028: Отсутствие дублирования с существующими модулями**
- **Критичность:** MUST
- **Описание:** Аудиосистема не должна дублировать функциональность существующих модулей:
  - Не дублирует логику `MicrophoneStateManager` (управление состоянием микрофона)
  - Не дублирует логику `SpeechRecognizer` (обработка аудио чанков, VAD, нормализация)
  - Не дублирует логику `SequentialSpeechPlayer` (воспроизведение аудио, управление буфером)
  - Не дублирует логику `AudioRecoveryManager` (восстановление после ошибок)
- **Источник:** `.cursorrules` раздел 4, `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md` раздел 6, `Docs/CODE_ANALYSIS_DUPLICATES_CONFLICTS.md`
- **Ожидаемый результат:** Нет дублирования функциональности с существующими модулями
- **Implementation:** Архитектура модулей, разделение ответственности
- **Verification:** Ревью кода, проверка отсутствия дублирования

**Acceptance Criteria для REQ-AUDIO-028:**
- ✅ **Разделение ответственности:**
  - `MicrophoneStateManager` - управление состоянием микрофона (IDLE, OPENING, OPEN, CLOSING)
  - `SpeechRecognizer` - обработка аудио чанков, VAD, нормализация (использует `InputStreamManager` из аудиосистемы)
  - `SequentialSpeechPlayer` - воспроизведение аудио, управление буфером (использует `OutputStreamManager` из аудиосистемы)
  - `AudioRecoveryManager` - восстановление после ошибок (использует `StreamManager` из аудиосистемы)
  - Аудиосистема - только управление устройствами и потоками (не дублирует бизнес-логику)
- ✅ **Использование компонентов:** Все существующие модули используют компоненты аудиосистемы (`InputStreamManager`, `OutputStreamManager`, `DeviceManager`), но не дублируют их функциональность
- ✅ **Проверка дублирования:** `scripts/check_code_duplication.py` не находит дублирования логики между аудиосистемой и существующими модулями

### 6.3 Порядок инициализации

**REQ-AUDIO-029: Порядок инициализации в SimpleModuleCoordinator**
- **Критичность:** MUST
- **Описание:** Аудиосистема должна инициализироваться в правильном порядке:
  1. `audio_system` - создание компонентов аудиосистемы (позиция 9)
  2. `voice_recognition` - использует InputStreamManager (позиция 11)
  3. `speech_playback` - использует OutputStreamManager (позиция 16)
- **Источник:** `.cursorrules` раздел 4, `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 11.6
- **Ожидаемый результат:** Аудиосистема инициализируется до модулей, которые её используют
- **Implementation:** `integration/core/simple_module_coordinator.py::_create_integrations()`
- **Verification:** Логи инициализации, тесты порядка инициализации

---

## 7. ТРЕБОВАНИЯ К ОБРАБОТКЕ ОШИБОК И ВОССТАНОВЛЕНИЮ

### 7.1 Обработка ошибок

**REQ-AUDIO-030: Обработка ошибок через ErrorHandler**
- **Критичность:** MUST
- **Описание:** Все ошибки аудиосистемы обрабатываются через `error_handler.handle_error` с указанием контекста и кодов ошибок:
  - `E_DEP_TIMEOUT` - таймаут открытия/создания потока
  - `E_DEP_UNAVAILABLE` - устройство недоступно
  - `E_INPUT_INVALID` - невалидные входные данные
- **Источник:** `.cursorrules` раздел 8, `integration/core/error_handler.py`
- **Ожидаемый результат:** Все ошибки логируются через ErrorHandler с кодами
- **Implementation:** Все модули используют `error_handler.handle_error`
- **Verification:** Логи ошибок, проверка кодов ошибок

**REQ-AUDIO-031: Обработка ошибок PortAudio**
- **Критичность:** MUST
- **Описание:** Система должна обрабатывать ошибки PortAudio:
  - `-9986` (Internal PortAudio error) - устройство занято
  - `-10851` (Audio Unit: Invalid Property Value) - несовместимые параметры
  - Стратегия: принудительное закрытие старого потока, задержка, повторная попытка
- **Источник:** `Docs/AUDIO_SYSTEM_RECURRING_PROBLEMS.md` раздел 1
- **Ожидаемый результат:** Ошибки PortAudio обрабатываются и система восстанавливается
- **Implementation:** `modules/audio_system/core/stream_manager.py::_handle_pa_error()`
- **Verification:** Тесты обработки ошибок, логи восстановления

### 7.2 Восстановление после ошибок

**REQ-AUDIO-032: Автоматическое восстановление**
- **Критичность:** MUST
- **Описание:** Система должна автоматически восстанавливаться после ошибок:
  - Обновление кэша PortAudio
  - Повторное определение устройства
  - Создание нового потока
  - Продолжение работы
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 5.1
- **Ожидаемый результат:** Система восстанавливается после ошибок за < 500ms
- **Implementation:** `modules/audio_system/core/stream_manager.py::_recover_from_error()`
- **Verification:** Тесты восстановления, логи восстановления

**REQ-AUDIO-033: Retry логика**
- **Критичность:** SHOULD
- **Описание:** Система должна использовать retry логику с экспоненциальным backoff:
  - Максимум попыток: 3 (из конфига `max_retry_attempts`)
  - Задержка между попытками: 0.5 сек (из конфига `retry_delay`)
  - Для BT устройств: увеличенные задержки и retry
- **Источник:** `config/unified_config.yaml` раздел `default_audio.max_retry_attempts`
- **Ожидаемый результат:** Retry логика работает корректно для всех типов устройств
- **Implementation:** `modules/audio_system/core/stream_manager.py::_retry_with_backoff()`
- **Verification:** Тесты retry логики, логи retry

---

## 8. ТРЕБОВАНИЯ К ПРОИЗВОДИТЕЛЬНОСТИ

### 8.1 Метрики производительности

**REQ-AUDIO-034: Время определения устройства**
- **Критичность:** SHOULD
- **Описание:** 
  - INPUT: < 100ms (p95)
  - OUTPUT: < 50ms (p95)
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 7.1
- **Ожидаемый результат:** Устройство определяется за указанное время
- **Implementation:** Все пути определения устройства
- **Verification:** Тесты производительности, метрики времени

**REQ-AUDIO-035: Время открытия/создания потока**
- **Критичность:** SHOULD
- **Описание:**
  - INPUT: < 200ms (p95)
  - OUTPUT: < 50ms (p95)
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 7.1
- **Ожидаемый результат:** Поток открывается/создается за указанное время
- **Implementation:** `modules/audio_system/core/stream_manager.py::create_stream()`
- **Verification:** Тесты производительности, метрики времени

**REQ-AUDIO-036: Процент успешных операций**
- **Критичность:** SHOULD
- **Описание:**
  - Процент успешных открытий: > 99%
  - Процент успешных переключений: > 99%
- **Источник:** `Docs/AUDIO_SYSTEM_TARGET_STATE.md` раздел 7.2
- **Ожидаемый результат:** Метрики соответствуют требованиям
- **Implementation:** Все операции с потоками
- **Verification:** Метрики успешности, логи ошибок

---

## 9. ТРЕБОВАНИЯ К КОНФИГУРАЦИИ

### 9.1 Единый источник конфигурации

**REQ-AUDIO-037: Конфигурация в unified_config.yaml**
- **Критичность:** MUST
- **Описание:** Все параметры аудиосистемы находятся в `config/unified_config.yaml` в разделе `audio_system`. Не допускается дублирование конфигурации в коде.
- **Источник:** `.cursorrules` раздел 6, `config/unified_config.yaml`
- **Ожидаемый результат:** Все параметры в unified_config.yaml, нет hardcoded значений
- **Implementation:** `config/unified_config.yaml`, загрузка через `UnifiedConfigLoader`
- **Verification:** Проверка отсутствия hardcoded значений, валидация конфига

**REQ-AUDIO-038: Параметры конфигурации**
- **Критичность:** MUST
- **Описание:** Конфигурация должна включать:
  - `polling_interval` - интервал polling fallback (2.0 сек)
  - `bt_prestart_delay` - задержка перед созданием потока для BT (INPUT: 0.5s, OUTPUT: 2.5s)
  - `close_delay` - задержка после закрытия потока (BT: 2.5s, обычные: 0.3s)
  - `max_retry_attempts` - максимум попыток (3)
  - `retry_delay` - задержка между попытками (0.5s)
- **Источник:** `config/unified_config.yaml`, `Docs/AUDIO_SYSTEM_ARCHITECTURE.md` раздел 9.2
- **Ожидаемый результат:** Все параметры настраиваются через конфиг
- **Implementation:** `config/unified_config.yaml` раздел `audio_system`
- **Verification:** Валидация конфига, тесты использования конфига

### 9.2 Описание полей конфигурации

**REQ-AUDIO-039: Документация полей конфигурации**
- **Критичность:** MUST
- **Описание:** Все поля конфигурации аудиосистемы должны быть документированы с указанием:
  - Назначения поля
  - Типа данных и допустимых значений
  - Значения по умолчанию
  - Влияния на поведение системы
- **Источник:** `config/unified_config.yaml`, раздел 9.2 этого документа
- **Ожидаемый результат:** Разработчики понимают назначение каждого поля конфигурации
- **Implementation:** Раздел 9.2 этого документа, комментарии в unified_config.yaml
- **Verification:** Ревью документации, проверка понимания разработчиками

**Структура конфигурации в `config/unified_config.yaml`:**

```yaml
audio_system:
  # ============================================
  # МОНИТОРИНГ УСТРОЙСТВ
  # ============================================
  
  # Интервал polling fallback для обнаружения изменений устройств (секунды)
  # Используется когда Core Audio нотификации недоступны
  # Тип: float, диапазон: 0.1-10.0, по умолчанию: 2.0
  # Влияние: Меньше значение = быстрее обнаружение, но больше нагрузка на CPU
  polling_interval: 2.0
  
  # ============================================
  # ПАРАМЕТРЫ УСТРОЙСТВ
  # ============================================
  
  # Целевые параметры для STT (что ожидает движок распознавания)
  target_sample_rate: 16000    # Тип: int, стандарт для ASR, по умолчанию: 16000
  target_channels: 1            # Тип: int, всегда mono для ASR, по умолчанию: 1
  target_dtype: "int16"         # Тип: string, формат для ASR, по умолчанию: "int16"
  
  # Автоматические параметры (не настраиваются пользователем)
  auto_detect_device: true      # Тип: bool, автоматическое определение устройства, по умолчанию: true
  auto_detect_sample_rate: true # Тип: bool, автоматическое определение sample rate, по умолчанию: true
  auto_detect_channels: true    # Тип: bool, автоматическое определение каналов, по умолчанию: true
  auto_detect_dtype: true       # Тип: bool, автоматическое определение типа данных, по умолчанию: true
  
  # Нормализация параметров устройств
  normalization:
    # OUTPUT параметры
    output_min_rate: 16000      # Тип: int, минимальный sample rate для OUTPUT (Hz), по умолчанию: 16000
    output_max_rate: 48000      # Тип: int, максимальный sample rate для OUTPUT (Hz), по умолчанию: 48000
    output_default_rate: 48000  # Тип: int, fallback если устройство не определяет rate (Hz), по умолчанию: 48000
    output_max_channels: 2       # Тип: int, максимум каналов для OUTPUT (стерео), по умолчанию: 2
    
    # INPUT параметры
    input_min_rate: 16000       # Тип: int, минимальный sample rate для INPUT (Hz), по умолчанию: 16000
    input_max_rate: 48000       # Тип: int, максимальный sample rate для INPUT (Hz), по умолчанию: 48000
    input_default_rate: 48000   # Тип: int, fallback если устройство не определяет rate (Hz), по умолчанию: 48000
    asr_target_rate: 16000      # Тип: int, целевой rate для ASR (всегда 16 kHz), по умолчанию: 16000
    input_channels: 1           # Тип: int, всегда mono для INPUT (ASR), по умолчанию: 1
  
  # ============================================
  # МОНИТОРИНГ ШУМА И ТИШИНЫ
  # ============================================
  
  # Окно оценки тишины (секунды)
  # Длительность окна для анализа тишины
  # Тип: float, диапазон: 0.1-5.0, по умолчанию: 0.3
  # Влияние: Меньше значение = быстрее обнаружение тишины, но больше ложных срабатываний
  silent_window_seconds: 0.3
  
  # Количество подряд окон тишины до перезапуска
  # Тишина считается обнаруженной после N подряд тихих окон
  # Тип: int, диапазон: 1-10, по умолчанию: 2
  # Влияние: Больше значение = меньше ложных срабатываний, но медленнее обнаружение
  silent_windows_threshold: 2
  
  # Порог тишины для обнаружения (RMS)
  # RMS < threshold считается тишиной
  # Тип: float, диапазон: 0.0001-0.1, по умолчанию: 0.01
  # Влияние: Меньше значение = более чувствительное обнаружение тишины
  silence_threshold: 0.01
  
  # Порог тишины для recovery (RMS)
  # Более строгий порог для обнаружения проблем с устройством
  # Тип: float, диапазон: 0.0001-0.01, по умолчанию: 0.001
  # Влияние: Используется для recovery manager (более строгий, чем silence_threshold)
  silence_threshold_recovery: 0.001
  
  # Порог минимального уровня шума (RMS)
  # RMS < threshold считается слишком тихим сигналом
  # Тип: float, диапазон: 0.0001-0.01, по умолчанию: 0.001
  # Влияние: При RMS < threshold публикуется предупреждение о проблеме с устройством
  noise_threshold_min: 0.001
  
  # Порог максимального уровня шума (RMS)
  # RMS > threshold считается слишком громким сигналом
  # Тип: float, диапазон: 0.5-1.0, по умолчанию: 0.9
  # Влияние: При RMS > threshold применяется нормализация громкости
  noise_threshold_max: 0.9
  
  # Период мониторинга "здоровья"/RMS (секунды)
  # Интервал между проверками уровня шума
  # Тип: float, диапазон: 0.1-10.0, по умолчанию: 1.0
  # Влияние: Меньше значение = более частый мониторинг, но больше нагрузка на CPU
  health_check_interval_sec: 1.0
  
  # ============================================
  # АВТОВОССТАНОВЛЕНИЕ И УСТОЙЧИВОСТЬ
  # ============================================
  
  # Пауза перед reopen (миллисекунды)
  # Задержка перед переоткрытием потока после ошибки
  # Тип: int, диапазон: 100-5000, по умолчанию: 600
  # Влияние: Дает время CoreAudio/BT стабилизироваться после ошибки
  reopen_debounce_ms: 600
  
  # Время "карантина" устройства (секунды)
  # Если устройство флапает (часто переключается), оно помещается в карантин
  # Тип: int, диапазон: 5-60, по умолчанию: 20
  # Влияние: Предотвращает бесконечные переключения на проблемное устройство
  device_quarantine_sec: 20
  
  # ============================================
  # БУФЕРИЗАЦИЯ И ПРОИЗВОДИТЕЛЬНОСТЬ
  # ============================================
  
  # Размер чанка для чтения (секунды)
  # Длительность аудио чанка для обработки
  # Тип: float, диапазон: 0.05-1.0, по умолчанию: 0.2
  # Влияние: Меньше значение = меньше задержка, но больше нагрузка на CPU
  read_chunk_sec: 0.2
  
  # Размер блока для sounddevice (сэмплы)
  # Размер блока для PortAudio/sounddevice
  # Тип: int, диапазон: 64-4096, по умолчанию: 1024
  # Влияние: Влияет на задержку и нагрузку на CPU
  chunk_size: 1024
  
  # Максимум попыток retry
  # Количество попыток при ошибке перед отказом
  # Тип: int, диапазон: 1-10, по умолчанию: 3
  # Влияние: Больше значение = больше попыток, но больше задержка при ошибках
  max_retry_attempts: 3
  
  # Задержка между попытками retry (секунды)
  # Базовая задержка между попытками (экспоненциальный backoff)
  # Тип: float, диапазон: 0.1-5.0, по умолчанию: 0.5
  # Влияние: Больше значение = больше задержка, но меньше нагрузка на систему
  retry_delay: 0.5
  
  # Задержка после ошибки перед следующей попыткой (секунды)
  # Время "остывания" после ошибки
  # Тип: float, диапазон: 0.5-10.0, по умолчанию: 2.0
  # Влияние: Дает время системе восстановиться после ошибки
  error_cooldown: 2.0
  
  # ============================================
  # BLUETOOTH УСТРОЙСТВА
  # ============================================
  
  # Задержка перед созданием потока для BT INPUT (секунды)
  # Дает время BT устройству инициализироваться
  # Тип: float, диапазон: 0.1-2.0, по умолчанию: 0.5
  # Влияние: Предотвращает ошибки PortAudio на BT устройствах
  bt_prestart_delay_input: 0.5
  
  # Задержка перед созданием потока для BT OUTPUT (секунды)
  # Дает время BT устройству инициализироваться
  # Тип: float, диапазон: 1.0-5.0, по умолчанию: 2.5
  # Влияние: Предотвращает ошибки PortAudio на BT устройствах
  bt_prestart_delay_output: 2.5
  
  # Задержка после закрытия потока для BT (секунды)
  # Дает время BT устройству освободить ресурсы
  # Тип: float, диапазон: 1.0-5.0, по умолчанию: 2.5
  # Влияние: Предотвращает ошибки "устройство занято" на BT устройствах
  bt_close_delay: 2.5
  
  # Задержка после закрытия потока для обычных устройств (секунды)
  # Дает время устройству освободить ресурсы
  # Тип: float, диапазон: 0.1-1.0, по умолчанию: 0.3
  # Влияние: Предотвращает ошибки "устройство занято" на обычных устройствах
  close_delay: 0.3
  
  # Максимум попыток запуска потока для BT устройств
  # BT устройствам нужно больше попыток из-за задержек инициализации
  # Тип: int, диапазон: 3-15, по умолчанию: 7
  # Влияние: Больше значение = больше попыток, но больше шансов на успех для BT
  max_stream_start_retries_bt: 7
  
  # Максимум попыток запуска потока для обычных устройств
  # Обычным устройствам нужно меньше попыток
  # Тип: int, диапазон: 1-5, по умолчанию: 3
  # Влияние: Меньше значение = быстрее отказ при проблемах
  max_stream_start_retries: 3
  
  # ============================================
  # ЛОГИРОВАНИЕ И ОТЛАДКА
  # ============================================
  
  # Включить отладочное логирование
  # Тип: bool, по умолчанию: true
  # Влияние: Включает подробные логи для отладки
  enable_debug_logging: true
  
  # Логировать проверки здоровья (RMS, уровень шума)
  # Тип: bool, по умолчанию: true
  # Влияние: Логирует метрики уровня шума каждые health_check_interval_sec
  log_health_checks: true
  
  # Логировать события потоков (создание, закрытие, переключение)
  # Тип: bool, по умолчанию: true
  # Влияние: Логирует все операции с потоками
  log_stream_events: true
  
  # Логировать смену устройств
  # Тип: bool, по умолчанию: true
  # Влияние: Логирует обнаружение смены устройств
  log_device_changes: true
  
  # Логировать метрики производительности
  # Тип: bool, по умолчанию: true
  # Влияние: Логирует время операций (определение устройства, открытие потока, переключение)
  log_performance_metrics: true
```

**Примечания к конфигурации:**
- Все значения по умолчанию должны быть разумными для большинства случаев использования
- Изменение параметров должно быть безопасным (валидация диапазонов)
- Критичные параметры (пороги тишины, задержки BT) должны быть тщательно протестированы
- Документация в unified_config.yaml должна содержать комментарии с описанием каждого поля

---

## 10. ТРЕБОВАНИЯ К ЛОГИРОВАНИЮ И НАБЛЮДАЕМОСТИ

### 10.1 Формат логов

**REQ-AUDIO-040: Формат логов**
- **Критичность:** MUST
- **Описание:** Логи аудиосистемы должны соответствовать формату: `YYYY-MM-DD HH:MM:SS - Nexy - LEVEL - [session_id] - Message`
- **Источник:** `.cursorrules` раздел 8, `client/main.py`
- **Ожидаемый результат:** Все логи в правильном формате
- **Implementation:** Все модули используют стандартный формат логирования
- **Verification:** Проверка формата логов, тесты логирования

**REQ-AUDIO-041: Структурированные события**
- **Критичность:** SHOULD
- **Описание:** Система должна логировать структурированные события:
  - `audio.device.detected{device_name, device_id, is_bluetooth}`
  - `audio.stream.started{device_name, device_id, direction}`
  - `audio.stream.stopped{device_name, device_id, direction}`
  - `audio.device.switched{old_device, new_device, direction}`
- **Источник:** `.cursorrules` раздел 8.1
- **Ожидаемый результат:** Структурированные события логируются
- **Implementation:** Все модули логируют структурированные события
- **Verification:** Логи событий, тесты логирования

### 10.2 Метрики

**REQ-AUDIO-042: Метрики производительности**
- **Критичность:** SHOULD
- **Описание:** Система должна логировать метрики:
  - `device_detection_time_ms` - время определения устройства
  - `stream_open_time_ms` - время открытия потока
  - `device_switch_time_ms` - время переключения устройства
  - `noise_level_rms` - уровень шума (RMS)
- **Источник:** `config/unified_config.yaml` раздел `default_audio.log_performance_metrics`
- **Ожидаемый результат:** Метрики логируются при включенном флаге
- **Implementation:** Все модули логируют метрики
- **Verification:** Логи метрик, тесты метрик

---

## 11. ТРЕБОВАНИЯ К ТЕСТИРОВАНИЮ

### 11.1 Unit тесты

**REQ-AUDIO-043: Unit тесты для модулей**
- **Критичность:** SHOULD
- **Описание:** Все модули аудиосистемы должны иметь unit тесты:
  - `DeviceManager` - тесты определения устройств, нормализации параметров
  - `DeviceMonitor` - тесты обнаружения изменений, polling fallback
  - `InputStreamManager` - тесты создания потоков, переключения устройств
  - `OutputStreamManager` - тесты создания потоков, переключения устройств
  - `DeviceUtils` - тесты утилит работы с устройствами
- **Источник:** `.cursorrules` раздел 10, 14.6
- **Ожидаемый результат:** Все модули покрыты unit тестами
- **Implementation:** `modules/audio_system/tests/`
- **Verification:** Покрытие тестами, запуск тестов

### 11.2 Интеграционные тесты

**REQ-AUDIO-044: Интеграционные тесты**
- **Критичность:** SHOULD
- **Описание:** Интеграционные тесты должны проверять:
  - Интеграцию с EventBus (публикация/подписка событий)
  - Интеграцию с VoiceRecognitionIntegration
  - Интеграцию с SpeechPlaybackIntegration
  - Переключение устройств во время записи/воспроизведения
- **Источник:** `.cursorrules` раздел 10, 14.6
- **Ожидаемый результат:** Интеграционные тесты проходят
- **Implementation:** `integration/tests/test_audio_system_integration.py`
- **Verification:** Запуск интеграционных тестов

---

## 12. ТРЕБОВАНИЯ К ДОКУМЕНТАЦИИ

### 12.1 Документация модуля

**REQ-AUDIO-045: README модуля**
- **Критичность:** MUST
- **Описание:** Модуль `audio_system` должен иметь README с:
  - Назначением модуля
  - Публичными интерфейсами (types.py)
  - Ссылками на EventBus события
  - Инвариантами и ошибками
  - Метриками и ключевыми логами
  - Примерами использования
- **Источник:** `.cursorrules` раздел 15.3
- **Ожидаемый результат:** README модуля содержит всю необходимую информацию
- **Implementation:** `modules/audio_system/README.md`
- **Verification:** Ревью документации

**REQ-AUDIO-046: INTEGRATION_GUIDE**
- **Критичность:** SHOULD
- **Описание:** Модуль должен иметь INTEGRATION_GUIDE с:
  - Контрактом EventBus
  - Примерами интеграции с другими модулями
  - Правилами использования
  - Чек-листом интеграции
- **Источник:** `.cursorrules` раздел 16, примеры в других модулях
- **Ожидаемый результат:** INTEGRATION_GUIDE содержит всю необходимую информацию
- **Implementation:** `modules/audio_system/INTEGRATION_GUIDE.md`
- **Verification:** Ревью документации

---

## 13. КРИТЕРИИ УСПЕХА

### 13.1 Функциональные критерии

- ✅ **Постоянный мониторинг:** Система непрерывно отслеживает подключение новых устройств с момента старта до завершения
- ✅ **Мгновенное обнаружение:** Новые устройства обнаруживаются за < 500ms после подключения
- ✅ **Автоматическое переключение:** Система мгновенно переключается на новые устройства без действий пользователя
- ✅ **Правильное получение данных:** Все необходимые данные для настройки INPUT/OUTPUT получаются и валидируются перед переключением
- ✅ **Правильное переключение без ошибок:** Переключение происходит с правильными параметрами, без ошибок PortAudio (-9986, -10851)
- ✅ **Совместимость с библиотеками записи:** Данные для SpeechRecognition в правильном формате (int16, 16000 Hz, моно)
- ✅ **Совместимость с библиотеками воспроизведения:** Данные для sounddevice в правильном формате (int16/float32, 48000 Hz, 1-2 канала)
- ✅ **Правильная конвертация форматов:** Все конвертации выполняются без потери качества
- ✅ **Использование CoreAudio UID:** Все устройства идентифицируются по UID, маппинги кэшируются
- ✅ **Защита от race conditions:** Нет параллельных переключений устройств, все переключения последовательны
- ✅ **Метрики производительности:** Все метрики логируются и соответствуют целевым значениям
- ✅ **Конфигурируемость:** Все BT-специфичные параметры и режимы работы в конфиге
- ✅ **Мгновенная адаптация:** Смена устройства обнаруживается за < 500ms, переключение за < 200ms
- ✅ **Переключение устройств:** Переключение работает во время записи/воспроизведения без потери данных
- ✅ **Bluetooth поддержка:** Bluetooth устройства работают без ошибок PortAudio
- ✅ **Учет уровня шума:** Система мониторит и адаптируется к уровню шума
- ✅ **Отсутствие дублей:** Нет дублирования кода и логики

### 13.2 Производительность

- ✅ **Время определения устройства:** INPUT < 100ms, OUTPUT < 50ms (p95)
- ✅ **Время открытия потока:** INPUT < 200ms, OUTPUT < 50ms (p95)
- ✅ **Время переключения:** INPUT < 200ms, OUTPUT < 100ms (p95)
- ✅ **Процент успешных операций:** > 99%

### 13.3 Качество кода

- ✅ **Отсутствие дублирования:** Все утилиты в одном месте
- ✅ **Централизация:** Единый источник истины для всех операций с устройствами
- ✅ **Правильная интеграция:** Интеграция через EventBus без прямых вызовов
- ✅ **Документация:** README и INTEGRATION_GUIDE на месте
- ✅ **Тесты:** Unit и интеграционные тесты покрывают основную функциональность

### 13.4 Централизация и отсутствие конфликтов

- ✅ **Единый источник истины:** Все модули используют `DeviceManager` и `DeviceStateCache`
- ✅ **Нет дублирования кода:** `scripts/check_code_duplication.py` не находит дублирования
- ✅ **Нет прямых вызовов:** `scripts/verify_no_direct_state_access.py` не находит прямых вызовов системных API
- ✅ **Единый мониторинг:** Только `DeviceMonitor` опрашивает устройства
- ✅ **Единое управление потоками:** Все модули используют `StreamManager`
- ✅ **Нет конфликтов:** Логи не показывают дублирование событий или конфликты

---

## 14. ПРИОРИТЕТЫ РЕАЛИЗАЦИИ

### Приоритет 1 (критично - блокирует работу):
1. REQ-AUDIO-001: Событийная архитектура (EventBus)
2. REQ-AUDIO-003: Единый источник истины для устройств
3. REQ-AUDIO-004A-004H: Централизация и предотвращение конфликтов (все требования)
4. REQ-AUDIO-008: Мгновенное обнаружение смены default устройства
5. **REQ-AUDIO-008A: Постоянный мониторинг подключения новых устройств** ⭐ КРИТИЧНО
6. **REQ-AUDIO-008B: Обнаружение новых подключенных устройств** ⭐ КРИТИЧНО
7. **REQ-AUDIO-008C: Мгновенное переключение при обнаружении нового устройства** ⭐ КРИТИЧНО
8. REQ-AUDIO-009: Подписка на Core Audio нотификации
9. REQ-AUDIO-010: Polling fallback (работает постоянно)
10. **REQ-AUDIO-011A: Получение всех необходимых данных для настройки устройства** ⭐ КРИТИЧНО
11. **REQ-AUDIO-011B: Валидация данных устройства перед переключением** ⭐ КРИТИЧНО
12. **REQ-AUDIO-011C: Обработка ошибок при получении данных устройства** ⭐ КРИТИЧНО
13. REQ-AUDIO-012: Нормализация параметров устройства
14. **REQ-AUDIO-014A: Правильное переключение INPUT без ошибок** ⭐ КРИТИЧНО
15. **REQ-AUDIO-016A: Правильное переключение OUTPUT без ошибок** ⭐ КРИТИЧНО
16. REQ-AUDIO-018: Обработка Bluetooth устройств

### Приоритет 2 (важно - влияет на стабильность):
8. **REQ-AUDIO-007A: Обязательное использование CoreAudio UID** ⭐ КРИТИЧНО
9. **REQ-AUDIO-015A: Защита от параллельных переключений устройств** ⭐ КРИТИЧНО
10. REQ-AUDIO-011: Автоматическое определение параметров устройства
11. **REQ-AUDIO-012A: Совместимость параметров с библиотеками записи** ⭐ КРИТИЧНО
12. **REQ-AUDIO-012B: Совместимость параметров с библиотеками воспроизведения** ⭐ КРИТИЧНО
13. **REQ-AUDIO-012C: Правильная конвертация форматов данных** ⭐ КРИТИЧНО
14. REQ-AUDIO-012: Нормализация параметров устройства
15. **REQ-AUDIO-033: Обязательные метрики производительности** ⭐ КРИТИЧНО
16. **REQ-AUDIO-035: Конфигурация Bluetooth-специфичных параметров** ⭐ КРИТИЧНО
17. REQ-AUDIO-023: Контракт EventBus для аудиосистемы
18. REQ-AUDIO-026: Интеграция с VoiceRecognitionIntegration
19. REQ-AUDIO-027: Интеграция с SpeechPlaybackIntegration
20. REQ-AUDIO-028: Отсутствие дублирования с существующими модулями
21. REQ-AUDIO-030: Обработка ошибок через ErrorHandler
22. REQ-AUDIO-032: Автоматическое восстановление
23. REQ-AUDIO-007B: Режим "следовать системе" vs "прибитое устройство"
24. REQ-AUDIO-034: Метрики в структурированном формате
25. REQ-AUDIO-036: Конфигурация режима работы с устройствами

### Приоритет 3 (желательно - улучшает UX):
14. REQ-AUDIO-020: Мониторинг уровня шума
15. REQ-AUDIO-021: Адаптивная обработка по уровню шума
16. REQ-AUDIO-022: Обнаружение тишины
17. REQ-AUDIO-034-036: Метрики производительности
18. REQ-AUDIO-042-043: Тесты

---

## 15. ЗАКЛЮЧЕНИЕ

Новая аудиосистема должна быть:
1. **Простой** - минимальная сложность, понятная архитектура
2. **Надежной** - автоматическое восстановление после ошибок
3. **Быстрой** - мгновенная адаптация к устройствам
4. **Интегрированной** - правильная интеграция с остальным кодом через EventBus
5. **Без дублей** - единый источник истины для всех операций с устройствами
6. **Совместимой** - правильное взаимодействие с библиотеками записи (SpeechRecognition) и воспроизведения (sounddevice/pydub)
7. **Правильной** - правильное получение данных и переключение без ошибок

Достижение этих требований обеспечит стабильную работу аудиосистемы и устранит текущие проблемы с:
- Bluetooth устройствами (ошибки -9986, -10851)
- Переключением устройств (неправильные параметры, потеря данных)
- Дублированием кода (множественные источники логики)
- Несовместимостью форматов данных (неправильные параметры для библиотек)
