# ПРОМПТ ДЛЯ РЕШЕНИЯ ПРОБЛЕМЫ ПЕРЕЗАПУСКА И АКТИВАЦИИ ПРИЛОЖЕНИЯ

## КОНТЕКСТ ПРОБЛЕМЫ

В проекте **Nexy AI Assistant** обнаружены две критические проблемы, связанные с процессом запроса разрешений, перезапуском приложения и активацией ассистента:

### ПРОБЛЕМА 1: Приложение не перезапускается после предоставления разрешений

**Симптомы:**
- После завершения процедуры запроса разрешений при первом запуске приложение не перезапускается автоматически
- Пользователь остается в том же экземпляре приложения без перезапуска
- Система не переходит к нормальному режиму работы после получения разрешений
- В логах могут отсутствовать записи о планировании или выполнении перезапуска

**Ожидаемое поведение:**
- После выдачи всех критических разрешений приложение должно автоматически перезапуститься
- Перезапуск должен произойти через определенное время после завершения `permissions.first_run_completed`
- После перезапуска приложение должно работать в нормальном режиме

### ПРОБЛЕМА 2: Ассистент активируется во время запроса разрешений

**Симптомы:**
- VoiceRecognitionIntegration может начать работу (переход в LISTENING режим) во время процесса запроса разрешений
- Приложение может активировать микрофон или другие функции до завершения first_run flow
- В логах видны события активации voice recognition до завершения `permissions.first_run_completed`
- Активация происходит даже во время предоставления разрешений

**Ожидаемое поведение:**
- Ассистент должен быть полностью заблокирован до завершения процедуры первого запуска
- Переход в LISTENING режим должен быть запрещён пока `permissions.first_run_completed` не опубликовано
- Все интеграции должны уважать флаг `permissions_in_progress` или состояние first_run
- Активироваться ассистент должен ТОЛЬКО после перезапуска приложения

---

## ТРЕБОВАНИЯ К АНАЛИЗУ

**⚠️ КРИТИЧЕСКИ ВАЖНО:** Прежде чем предлагать решения, выполни **ПОЛНЫЙ ДИАГНОСТИЧЕСКИЙ АНАЛИЗ** согласно структуре ниже. Решения предлагаются ТОЛЬКО после того, как найден корень проблемы и проанализированы все затронутые компоненты.

---

## ЭТАП 1: АНАЛИЗ АРХИТЕКТУРЫ СИСТЕМЫ РАЗРЕШЕНИЙ И ПЕРЕЗАПУСКА

### 1.1 Изучение потока запроса разрешений

Проанализируй:

#### Порядок инициализации интеграций
**Файл**: `integration/core/simple_module_coordinator.py:492-512`

**Ключевые позиции:**
1. `instance_manager` (позиция 1) - блокирующий
2. `hardware_id` (позиция 2)
3. `first_run_permissions` (позиция 3) - **БЛОКИРУЮЩИЙ** - запрос разрешений при первом запуске
4. `permission_restart` (позиция 4) - автоматический перезапуск после выдачи критических разрешений
5. `tray` (позиция 5)
6. `mode_management` (позиция 6)
7. `input` (позиция 7)
8. `voice_recognition` (позиция 8) - распознавание речи
9. `welcome_message` (позиция 17)

**Критический код**: `simple_module_coordinator.py:526-530`
```python
if name == "first_run_permissions" and success:
    print("⏳ Ожидание завершения запроса разрешений...")
    await self._wait_for_permissions_completion()
    print("✅ Запрос разрешений завершен, продолжаем запуск...")
```

**Вопросы для анализа:**
- [ ] Как работает `_wait_for_permissions_completion()`? Он действительно ждет завершения или просто проверяет флаг?
- [ ] Блокирует ли он запуск остальных интеграций (включая voice_recognition)?
- [ ] Что происходит если `first_run_permissions` завершается быстро, но `permissions.first_run_completed` публикуется позже?
- [ ] Когда запускается `voice_recognition` относительно `first_run_permissions`?
- [ ] Может ли `voice_recognition` начать работу ДО публикации `permissions.first_run_completed`?

#### Процесс запроса разрешений
**Файл**: `integration/integrations/first_run_permissions_integration.py`

**Ключевой поток**:
1. Проверка флага `permissions_first_run_completed.flag` (строка 115)
2. Если флага нет → первый запуск
3. Публикация `permissions.first_run_started` (строка 124)
4. Установка `_permissions_in_progress = True` (строка 130)
5. Запрос разрешений последовательно: Microphone → Accessibility → Input Monitoring → Screen Capture
6. Сохранение флага (строка 138)
7. Публикация `permissions.first_run_completed` (строка 144)
8. Сброс `_permissions_in_progress = False` (строка 151)

**Вопросы для анализа:**
- [ ] Когда именно публикуется `permissions.first_run_completed`? Сразу после запроса или после паузы?
- [ ] Есть ли задержка между запросом разрешений и публикацией события?
- [ ] Что происходит если пользователь не предоставляет разрешения сразу?
- [ ] Может ли `_permissions_in_progress` быть сброшен до публикации `permissions.first_run_completed`?

### 1.2 Изучение системы перезапуска

#### PermissionRestartIntegration
**Файл**: `integration/integrations/permission_restart_integration.py`

**Ключевой метод**: `_on_first_run_completed()` (строка 175)

**Логика обработки**:
1. Получение события `permissions.first_run_completed`
2. Установка флага `_is_first_run_restart = True` (строка 205)
3. Создание синтетических transition событий для ACCESSIBILITY и INPUT_MONITORING (строка 210)
4. Обработка каждого transition через `_handle_transition()` (строка 220)

**Вопросы для анализа:**
- [ ] Почему создаются синтетические события вместо проверки реального статуса разрешений?
- [ ] Может ли `_handle_transition()` не вызвать `scheduler.maybe_schedule_restart()`?
- [ ] Есть ли условия, при которых событие `permissions.first_run_completed` не обрабатывается?
- [ ] Что происходит если PermissionRestartIntegration не подписан на событие?

#### RestartScheduler
**Файл**: `modules/permission_restart/core/restart_scheduler.py`

**Ключевой метод**: `maybe_schedule_restart()` (строка 67)

**Условия блокировки перезапуска**:
1. `_config.enabled == False` (строка 72) → немедленный отказ
2. `_attempts >= max_restart_attempts` (строка 77) → немедленный отказ
3. Если перезапуск уже запланирован → обновление метаданных (строка 92)

**Метод выполнения**: `_run_when_safe()` (строка 128)

**Условия ожидания** (до 10 минут):
1. `respect_updates && _is_update_in_progress()` (строка 143) → ждёт завершения обновления
2. `respect_active_sessions && !_is_idle_mode()` (строка 147) → **КРИТИЧЕСКОЕ** - ждёт режима SLEEPING

**Метод проверки режима**: `_is_idle_mode()` (строка 227)
```python
def _is_idle_mode(self) -> bool:
    # Специальный случай: перезапуск после first_run
    if self._is_first_run_restart:
        logger.debug("First run restart - bypassing SLEEPING mode check")
        return True
    
    current_mode = self._state_manager.get_current_mode()
    return current_mode == AppMode.SLEEPING
```

**Конфигурация перезапуска**:
- `restart_delay_sec: 5.0` (из `config/unified_config.yaml:179`)
- `respect_active_sessions: true` (по умолчанию)
- `respect_updates: true` (по умолчанию)

**Вопросы для анализа:**
- [ ] Какой режим приложения после завершения first_run? Может быть не SLEEPING?
- [ ] Может ли приложение быть в LISTENING или PROCESSING режиме после first_run?
- [ ] Что происходит если режим не становится SLEEPING в течение 10 минут?
- [ ] Работает ли проверка `_is_first_run_restart` до проверки режима?
- [ ] Может ли задержка `restart_delay_sec` быть слишком большой?
- [ ] Почему перезапуск не происходит даже при `_is_first_run_restart = True`?

### 1.3 Изучение системы активации ассистента

#### VoiceRecognitionIntegration
**Файл**: `integration/integrations/voice_recognition_integration.py`

**Блокировка активации**:
- Флаг `_first_run_in_progress` (строка 67)
- Подписка на `permissions.first_run_started` (строка 143)
- Подписка на `permissions.first_run_completed` (строка 144)
- Проверка в `_on_recording_start()` (строка 216)

**Критический код**:
```python
async def _on_recording_start(self, event: Dict[str, Any]):
    # КРИТИЧНО: Проверяем first_run перед началом записи
    if self._first_run_in_progress:
        logger.warning("⚠️ [VOICE_RECOGNITION] Блокировка активации - first_run в процессе.")
        return
```

**Вопросы для анализа:**
- [ ] Когда устанавливается `_first_run_in_progress` в VoiceRecognitionIntegration?
- [ ] Может ли событие `voice.recording_start` прийти ДО установки флага?
- [ ] Есть ли race condition между публикацией `permissions.first_run_started` и подпиской VoiceRecognitionIntegration?
- [ ] Может ли ListeningWorkflow инициировать активацию до проверки флага?

#### ListeningWorkflow
**Файл**: `integration/workflows/listening_workflow.py`

**Подписка на события**:
- `voice.recording_start` (строка 45) → может инициировать переход в LISTENING

**Вопросы для анализа:**
- [ ] Проверяет ли ListeningWorkflow флаг `permissions_in_progress` перед обработкой `voice.recording_start`?
- [ ] Может ли ListeningWorkflow инициировать переход в LISTENING во время first_run?
- [ ] Есть ли блокировка активации в ListeningWorkflow?

#### Gateways (selectors)
**Файл**: `integration/core/gateways.py`

**Метод**: `decide_start_listening()` (строка 39)

**Проверка first_run**:
```python
def decide_start_listening(s: Snapshot) -> Decision:
    # Hard stop: first_run in progress
    if s.first_run:
        logger.info("decision=abort reason=first_run_in_progress")
        return Decision.ABORT
```

**Selectors**: `integration/core/selectors.py`

**Метод**: `can_start_listening()` (строка 148)
```python
def can_start_listening(s: Snapshot) -> bool:
    return (
        not is_first_run(s)  # КРИТИЧНО: Блокируем активацию во время first_run
        and mic_ready(s)
        and device_idle(s)
        and (is_sleeping_mode(s) or is_listening_mode(s))
    )
```

**Вопросы для анализа:**
- [ ] Как формируется Snapshot? Откуда берется `first_run`?
- [ ] Обновляется ли Snapshot в реальном времени или кэшируется?
- [ ] Может ли Snapshot быть устаревшим при проверке?
- [ ] Используются ли gateways/selectors во всех местах активации?

### 1.4 Изучение состояния приложения

#### ApplicationStateManager
**Файл**: `integration/core/state_manager.py`

**Вопросы для анализа:**
- [ ] Какой режим приложения после завершения first_run?
- [ ] Как устанавливается режим при старте приложения?
- [ ] Может ли режим быть LISTENING или PROCESSING сразу после старта?
- [ ] Есть ли состояние `first_run` в StateManager?
- [ ] Обновляется ли состояние `first_run` при публикации `permissions.first_run_completed`?

---

## ЭТАП 2: ВЫЯВЛЕНИЕ КОРНЯ ПРОБЛЕМЫ

### 2.1 Анализ потока событий

Проанализируй последовательность событий при первом запуске:

**Ожидаемая последовательность:**
1. `app.startup`
2. `first_run_permissions.start()` → блокирующий
3. `permissions.first_run_started` → публикуется
4. Запрос разрешений последовательно
5. `permissions.first_run_completed` → публикуется
6. `permission_restart._on_first_run_completed()` → обработка
7. `RestartScheduler.maybe_schedule_restart()` → планирование
8. `RestartScheduler._run_when_safe()` → ожидание безопасных условий
9. Перезапуск приложения
10. После перезапуска: нормальный режим работы

**Вопросы для анализа:**
- [ ] На каком этапе нарушается последовательность?
- [ ] Какие события могут прийти раньше времени?
- [ ] Есть ли параллельные процессы, которые могут нарушить последовательность?
- [ ] Может ли активация ассистента начаться до завершения first_run?

### 2.2 Выявление race conditions

**Вопросы для анализа:**
- [ ] Есть ли race condition между публикацией `permissions.first_run_started` и подпиской VoiceRecognitionIntegration?
- [ ] Может ли `voice.recording_start` прийти до установки `_first_run_in_progress`?
- [ ] Есть ли race condition между завершением first_run и активацией ассистента?
- [ ] Может ли перезапуск не произойти из-за параллельных процессов?

### 2.3 Выявление условий блокировки

**Вопросы для анализа:**
- [ ] Почему перезапуск не происходит даже при `_is_first_run_restart = True`?
- [ ] Какие условия в `_run_when_safe()` могут блокировать перезапуск?
- [ ] Может ли проверка режима SLEEPING блокировать перезапуск даже при `_is_first_run_restart = True`?
- [ ] Работает ли обход проверки режима для first_run?

---

## ЭТАП 3: ПРОЕКТИРОВАНИЕ РЕШЕНИЯ

### 3.1 Требования к решению

**Для ПРОБЛЕМЫ 1 (перезапуск):**
1. Перезапуск должен происходить **гарантированно** после завершения `permissions.first_run_completed`
2. Перезапуск должен происходить через **определенное время** (настраиваемое в конфиге)
3. Перезапуск должен происходить **независимо** от текущего режима приложения (SLEEPING/LISTENING/PROCESSING)
4. Перезапуск не должен блокироваться проверками режима для first_run

**Для ПРОБЛЕМЫ 2 (активация):**
1. Активация ассистента должна быть **полностью заблокирована** до завершения first_run
2. Блокировка должна работать на всех уровнях: VoiceRecognitionIntegration, ListeningWorkflow, Gateways
3. Блокировка должна быть **надежной** - без race conditions
4. Активация должна быть разрешена **только после перезапуска** приложения

### 3.2 Архитектурные ограничения

**При проектировании решения учитывай:**

1. **Порядок инициализации** - не нарушай существующий порядок интеграций
2. **EventBus архитектура** - используй события для коммуникации
3. **Selectors/Gateways** - используй существующую архитектуру принятия решений
4. **Конфигурация** - изменения через `unified_config.yaml`
5. **Логирование** - обязательное логирование всех решений и событий
6. **Обратная совместимость** - не ломай существующий функционал

### 3.3 План реализации

**Шаг 1: Исправление перезапуска**
- [ ] Проверка работы `_is_first_run_restart` флага
- [ ] Исправление проверки режима для first_run перезапуска
- [ ] Убедиться что перезапуск происходит независимо от режима
- [ ] Добавить гарантированную задержку перед перезапуском
- [ ] Тестирование перезапуска после first_run

**Шаг 2: Усиление блокировки активации**
- [ ] Проверка всех точек активации ассистента
- [ ] Добавить проверку first_run в ListeningWorkflow
- [ ] Убедиться что Snapshot обновляется в реальном времени
- [ ] Добавить дополнительные проверки в Gateways
- [ ] Устранить race conditions

**Шаг 3: Координация блокировки и перезапуска**
- [ ] Убедиться что блокировка снимается только после перезапуска
- [ ] Добавить явную синхронизацию между first_run и перезапуском
- [ ] Тестирование полного потока

---

## ЭТАП 4: ДЕТАЛЬНЫЙ ПЛАН РЕАЛИЗАЦИИ

### 4.1 Компоненты для изменения

**Обязательно проанализируй все затронутые файлы:**

1. `modules/permission_restart/core/restart_scheduler.py`
   - Метод `_is_idle_mode()` - проверка режима для first_run
   - Метод `_run_when_safe()` - логика ожидания безопасных условий
   - Флаг `_is_first_run_restart` - использование для обхода проверок

2. `integration/integrations/permission_restart_integration.py`
   - Метод `_on_first_run_completed()` - обработка завершения first_run
   - Планирование перезапуска
   - Синхронизация с состоянием приложения

3. `integration/integrations/voice_recognition_integration.py`
   - Метод `_on_recording_start()` - проверка блокировки
   - Флаг `_first_run_in_progress` - управление блокировкой
   - Подписка на события first_run

4. `integration/workflows/listening_workflow.py`
   - Метод `_on_recording_start()` - обработка начала записи
   - Проверка блокировки активации
   - Координация с VoiceRecognitionIntegration

5. `integration/core/gateways.py`
   - Метод `decide_start_listening()` - принятие решений
   - Проверка first_run через Snapshot

6. `integration/core/selectors.py`
   - Метод `can_start_listening()` - проверка условий
   - Формирование Snapshot с first_run

7. `integration/core/state_manager.py`
   - Управление состоянием first_run
   - Обновление Snapshot
   - Синхронизация с событиями

8. `integration/core/simple_module_coordinator.py`
   - Метод `_wait_for_permissions_completion()` - ожидание завершения
   - Порядок инициализации интеграций
   - Координация между интеграциями

### 4.2 Риски и ограничения

**Учти следующие риски:**

1. **Race conditions** - события могут прийти в неправильном порядке
2. **Состояние приложения** - режим может быть неожиданным после first_run
3. **Таймауты** - перезапуск может не произойти из-за таймаутов
4. **Блокировки** - проверки режима могут блокировать перезапуск
5. **Параллельные процессы** - активация может начаться параллельно с перезапуском

### 4.3 Стратегия тестирования

**Обязательные тесты:**

1. **Тест перезапуска:**
   - После завершения first_run приложение перезапускается
   - Перезапуск происходит через заданное время
   - Перезапуск происходит независимо от режима

2. **Тест блокировки активации:**
   - Ассистент не активируется во время first_run
   - Попытки активации блокируются на всех уровнях
   - Блокировка снимается только после перезапуска

3. **Тест полного потока:**
   - Запрос разрешений → блокировка → завершение → перезапуск → активация
   - Все события приходят в правильном порядке
   - Нет race conditions

---

## ЭТАП 5: ФОРМАТ ОТВЕТА

### 5.1 Структура ответа

Твой ответ должен содержать:

1. **Краткое резюме проблемы** - что обнаружено
2. **Корень проблемы** - почему это происходит
3. **Затронутые компоненты** - список всех файлов и методов
4. **Детальный план решения** - пошаговый план исправления
5. **Изменения в коде** - конкретные изменения для каждого файла
6. **Тесты** - план тестирования
7. **Риски** - возможные побочные эффекты

### 5.2 Приоритеты

**Критически важно:**
- Перезапуск должен работать гарантированно
- Блокировка активации должна быть надежной
- Не должно быть race conditions

**Важно:**
- Решение должно соответствовать архитектуре проекта
- Изменения должны быть минимальными
- Обратная совместимость должна быть сохранена

**Желательно:**
- Логирование всех решений
- Документация изменений
- Комментарии в коде

---

## ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ

### Архитектурные принципы проекта

См. `.cursorrules` разделы:
- Раздел 21: Selectors и Gateways (архитектура принятия решений)
- Раздел 15: Мини-спецификации качества
- Раздел 4: Порядок модулей и инициализации
- Раздел 5: Паттерн интеграции

### Документация

- `Docs/PERMISSION_RESTART_LOGIC.md` - логика перезапуска
- `Docs/PERMISSION_RESTART_ACTIVATION_PROBLEM_PROMPT.md` - описание проблемы
- `Docs/PERMISSION_RESTART_BLOCKERS.md` - блокеры перезапуска
- `Docs/FIRST_RUN_TESTING_PLAN.md` - план тестирования

### Конфигурация

- `config/unified_config.yaml` - настройки permission_restart (строка 172-179)
- `restart_delay_sec: 5.0` - задержка перед перезапуском
- `respect_active_sessions: true` - учитывать активные сессии
- `respect_updates: true` - учитывать обновления

---

## ЗАКЛЮЧЕНИЕ

Проанализируй архитектуру проекта, найди корень проблемы в перезапуске и активации ассистента, спроектируй решение с учетом существующей структуры и создай детальный план реализации с минимальными изменениями кода.

**Главная цель:** Приложение должно перезапускаться после предоставления разрешений, а ассистент должен активироваться только после перезапуска.

