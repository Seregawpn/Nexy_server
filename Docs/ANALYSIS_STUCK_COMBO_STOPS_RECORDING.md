# Анализ проблемы: принудительный сброс комбинации останавливает запись

## Дата
2025-12-12

## Проблема

Пользователь зажимает комбинацию для активации микрофона, но запись не начинается или сразу останавливается.

### Симптомы из логов:

1. **Строка 186-187**: `⚠️ ЗАЛИПАНИЕ: Control зажат без событий слишком долго (10.0s > 10.0s), combo_active=True, принудительно сбрасываем`
2. **Строка 188-189**: `Деактивация комбинации: control_pressed=False, n_pressed=True`
3. **Строка 190**: `Combo deactivation: LONG_PRESS уже был, генерируем RELEASE`
4. **Строка 340-341**: `✅ LONG_PRESS: запрос на LISTENING отправлен СРАЗУ` и `✅ LONG_PRESS: _recording_started установлен`
5. **Строка 345-350**: `RELEASE: микрофон активен (mic_active=True) или запись начата (_recording_started=True) или есть сессия (session=1765581892.2596) - принудительно останавливаем`

## Корневая причина

### Проблема 1: Логика определения "залипания" срабатывает при активной комбинации

**Местоположение**: `modules/input_processing/keyboard/mac/quartz_monitor.py::_check_and_reset_stuck_state()` (строки 854-882)

**Что происходит**:
- Система проверяет, что Control зажат без событий `flagsChanged` более 10 секунд
- Но `flagsChanged` НЕ генерируется при удержании модификатора - это нормальное поведение macOS
- Если комбинация активна и N получает автоповтор - это означает, что Control реально зажат
- Но система все равно сбрасывает комбинацию из-за отсутствия событий `flagsChanged`

**Проблема**: Логика не учитывает, что при активной комбинации и автоповторе N, отсутствие `flagsChanged` - это нормально.

### Проблема 2: Принудительный сброс генерирует RELEASE, который останавливает запись

**Местоположение**: `modules/input_processing/keyboard/mac/quartz_monitor.py::_update_combo_state()` (строки 348-374)

**Что происходит**:
- При принудительном сбросе вызывается `_update_combo_state()`
- Если `_long_sent == True`, генерируется RELEASE
- RELEASE обрабатывается в `_handle_key_release()`
- `_should_stop_recording()` возвращает `True` (микрофон активен ИЛИ запись начата)
- `voice.recording_stop` публикуется и останавливает только что начатую запись

**Проблема**: RELEASE не должен останавливать запись, если она только что началась (< 0.1s) или если это принудительный сброс.

## Решение

### Решение 1: Улучшить логику определения "залипания"

**Изменения в `quartz_monitor.py::_check_and_reset_stuck_state()`**:

1. **Не сбрасывать Control, если комбинация активна и N получает автоповтор**:
   - Если `_combo_active == True` и `_n_last_event_time` обновляется (автоповтор N), то Control реально зажат
   - Не нужно сбрасывать комбинацию из-за отсутствия `flagsChanged`

2. **Увеличить таймаут для Control при активной комбинации**:
   - Если комбинация активна, таймаут должен быть больше (например, 30 секунд вместо 10)
   - Это учитывает, что модификаторы не генерируют повторные события

### Решение 2: RELEASE не должен останавливать запись при принудительном сбросе

**Изменения в `input_processing_integration.py::_handle_key_release()`**:

1. **Проверять время между LONG_PRESS и RELEASE**:
   - Если между `voice.recording_start` и RELEASE прошло < 0.1 секунды, не останавливать запись
   - Это защита от принудительного сброса сразу после LONG_PRESS

2. **Проверять причину RELEASE**:
   - Если `event.duration > 9.0s` (принудительный сброс), не останавливать активную запись
   - Это защита от принудительного сброса во время активной записи

3. **Использовать флаг "принудительный сброс"**:
   - Добавить поле `is_forced_reset` в `KeyEvent`
   - RELEASE с `is_forced_reset=True` не должен останавливать активную запись

## План исправления

1. ✅ **Исправить синтаксическую ошибку** в `voice_recognition_integration.py`
2. ⏳ **Улучшить логику определения "залипания"** в `quartz_monitor.py`
3. ⏳ **Добавить защиту от остановки записи при принудительном сбросе** в `input_processing_integration.py`
4. ⏳ **Создать изолированный тест** для проверки исправления
5. ⏳ **Протестировать в реальном приложении**

## Следующие шаги

1. Исправить логику определения "залипания" - не сбрасывать при активной комбинации и автоповторе N
2. Добавить защиту в RELEASE - не останавливать запись при принудительном сбросе
3. Протестировать исправления

