# ПРОМПТ ДЛЯ ДИАГНОСТИКИ И РЕШЕНИЯ ПРОБЛЕМ В NEXY AI ASSISTANT

## КОНТЕКСТ ПРОБЛЕМЫ

В проекте Nexy AI Assistant обнаружены две критические проблемы:

### ПРОБЛЕМА 1: Повторение речи об обновлении
**Симптомы:**
- Речь про обновление повторяется после перезапуска приложения
- Речь про обновление повторяется при активации приложения
- Система озвучивает уже завершенное обновление заново

**Ожидаемое поведение:**
- Если обновление уже завершено, оно не должно озвучиваться повторно
- Речь про обновление должна воспроизводиться только во время активного процесса обновления
- После перезапуска приложения система должна помнить статус завершенного обновления

### ПРОБЛЕМА 2: Залипание микрофона
**Симптомы:**
- Микрофон остается открытым после завершения использования
- Микрофон не закрывается корректно при смене режимов
- Возможны конфликты при одновременном использовании микрофона несколькими компонентами

**Ожидаемое поведение:**
- Микрофон должен корректно закрываться после завершения записи
- При смене режимов микрофон должен освобождаться
- Не должно быть race conditions при управлении микрофоном

---

## ТРЕБОВАНИЯ К АНАЛИЗУ

**⚠️ КРИТИЧЕСКИ ВАЖНО:** Прежде чем предлагать решения, выполни ПОЛНЫЙ ДИАГНОСТИЧЕСКИЙ АНАЛИЗ согласно структуре ниже. Решения предлагаются ТОЛЬКО после того, как найден корень проблемы.

---

## ЭТАП 1: АНАЛИЗ АРХИТЕКТУРЫ И ПОТОКОВ СОБЫТИЙ

### 1.1 Изучение структуры проекта
Проанализируй:
- [ ] Порядок инициализации интеграций в `SimpleModuleCoordinator._create_integrations()`
- [ ] Жизненный цикл интеграций: `initialize()` → `start()` → `stop()`
- [ ] Зависимости между интеграциями через EventBus
- [ ] Механизмы персистентного хранения состояния между перезапусками

**Файлы для анализа:**
- `integration/core/simple_module_coordinator.py`
- `integration/integrations/update_notification_integration.py`
- `integration/integrations/updater_integration.py`
- `integration/core/event_bus.py`
- `integration/core/state_manager.py`

### 1.2 Трассировка событий об обновлении
Проанализируй поток событий:
- [ ] Какие события публикует `UpdaterIntegration` при старте (`updater.update_started`, `updater.update_completed`)
- [ ] Когда и как подписывается `UpdateNotificationIntegration` на эти события
- [ ] Что происходит при перезапуске: подписывается ли интеграция заново?
- [ ] Сохраняется ли состояние `_update_completed` между перезапусками?
- [ ] Есть ли проверка уже завершенных обновлений перед озвучиванием?

**Ключевые вопросы:**
- Где хранится информация о завершенных обновлениях?
- Как система отличает новое обновление от уже завершенного?
- Что происходит с подписками на события после завершения обновления?

### 1.3 Трассировка управления микрофоном
Проанализируй поток управления микрофоном:
- [ ] Какие события управляют открытием/закрытием микрофона (`voice.recording_start`, `voice.recording_stop`, `voice.mic_opened`, `voice.mic_closed`)
- [ ] Как `SpeechRecognizer` управляет `_current_stream` (открытие, закрытие, очистка)
- [ ] Где и когда вызывается `stop_listening()` и гарантирует ли она закрытие потока?
- [ ] Есть ли принудительная остановка микрофона в `InputProcessingIntegration._reset_session()`?
- [ ] Как `VoiceRecognitionIntegration` обрабатывает события остановки записи?

**Ключевые вопросы:**
- Все ли пути выполнения гарантируют закрытие потока?
- Есть ли race conditions при одновременных запросах на открытие/закрытие?
- Корректно ли обрабатываются ошибки при закрытии потока?

---

## ЭТАП 2: АНАЛИЗ ЛОГОВ И ДИАГНОСТИКА

### 2.1 Анализ логов об обновлении
Изучи логи `log.md` и найди:
- [ ] События `updater.update_started` и `updater.update_completed` - сколько раз они публикуются?
- [ ] События `voice.recognition_completed` с `source="update_notification"` - когда они происходят?
- [ ] Последовательность инициализации интеграций при перезапуске
- [ ] Моменты подписки/отписки `UpdateNotificationIntegration` от событий
- [ ] Наличие дублирующихся уведомлений об обновлении

**Создай временную шкалу:**
- Время запуска приложения
- Моменты инициализации `UpdaterIntegration` и `UpdateNotificationIntegration`
- События обновления и их повторения
- Озвучивание уведомлений и их дублирование

### 2.2 Анализ логов микрофона
Изучи логи `log.md` и найди:
- [ ] События `voice.recording_start` и `voice.recording_stop` - их последовательность
- [ ] Состояние `MXCoreSession` - когда микрофон остается в состоянии `recording`
- [ ] Управление `_current_stream` - открытие и закрытие потока
- [ ] Принудительные остановки микрофона и их причины
- [ ] Ошибки при закрытии потока или освобождении ресурсов

**Создай временную шкалу:**
- Открытие микрофона
- Запись аудио
- Попытки закрытия
- Фактическое состояние микрофона

---

## ЭТАП 3: ПОИСК КОРНЯ ПРОБЛЕМЫ

### 3.1 Для проблемы повторения речи об обновлении
Проверь гипотезы:

**Гипотеза 1: Отсутствие персистентного хранилища**
- [ ] Проверь: сохраняется ли `_update_completed` флаг между перезапусками?
- [ ] Результат: если НЕТ → это корень проблемы

**Гипотеза 2: Повторная подписка на события**
- [ ] Проверь: подписывается ли `UpdateNotificationIntegration` заново при каждом старте, даже после завершения обновления?
- [ ] Проверь: отписывается ли интеграция от событий после завершения, и сохраняется ли это состояние?
- [ ] Результат: если подписка происходит заново, а проверка завершения отсутствует → это корень проблемы

**Гипотеза 3: Повторная публикация событий**
- [ ] Проверь: публикует ли `UpdaterIntegration` события при старте, даже если обновление уже завершено?
- [ ] Результат: если да → это корень проблемы

**Гипотеза 4: Отсутствие проверки версии**
- [ ] Проверь: проверяет ли система, что версия уже обновлена перед публикацией событий?
- [ ] Результат: если нет → это корень проблемы

### 3.2 Для проблемы залипания микрофона
Проверь гипотезы:

**Гипотеза 1: Неполное закрытие потока**
- [ ] Проверь: гарантирует ли `stop_listening()` закрытие `_current_stream` во всех случаях?
- [ ] Проверь: обрабатываются ли исключения при закрытии потока?
- [ ] Результат: если поток не закрывается в некоторых сценариях → это корень проблемы

**Гипотеза 2: Race conditions**
- [ ] Проверь: могут ли одновременно происходить `start_listening()` и `stop_listening()`?
- [ ] Проверь: корректно ли работает `_start_lock` в асинхронном контексте?
- [ ] Результат: если да → это корень проблемы

**Гипотеза 3: Отсутствие принудительной очистки**
- [ ] Проверь: есть ли механизм принудительного закрытия потока при ошибках или таймаутах?
- [ ] Проверь: очищается ли `_current_stream` при переходе в состояние IDLE?
- [ ] Результат: если нет → это корень проблемы

**Гипотеза 4: Проблемы с lifecycle потока**
- [ ] Проверь: корректно ли вызывается `_current_stream.stop()` и `_current_stream.close()`?
- [ ] Проверь: устанавливается ли `_current_stream = None` после закрытия?
- [ ] Результат: если нет → это корень проблемы

---

## ЭТАП 4: ФОРМУЛИРОВКА КОРНЯ ПРОБЛЕМЫ

**После проверки всех гипотез:**

### 4.1 Для проблемы 1 (повторение речи)
**Сформулируй корень проблемы:**
```
КОРЕНЬ ПРОБЛЕМЫ 1: [конкретное описание найденной причины]
Обоснование:
- [аргумент 1 из анализа]
- [аргумент 2 из анализа]
- [аргумент 3 из анализа]
Затронутые компоненты:
- [компонент 1]: [как он связан с проблемой]
- [компонент 2]: [как он связан с проблемой]
```

### 4.2 Для проблемы 2 (залипание микрофона)
**Сформулируй корень проблемы:**
```
КОРЕНЬ ПРОБЛЕМЫ 2: [конкретное описание найденной причины]
Обоснование:
- [аргумент 1 из анализа]
- [аргумент 2 из анализа]
- [аргумент 3 из анализа]
Затронутые компоненты:
- [компонент 1]: [как он связан с проблемой]
- [компонент 2]: [как он связан с проблемой]
```

---

## ЭТАП 5: ПРОЕКТИРОВАНИЕ РЕШЕНИЯ

**ТОЛЬКО ПОСЛЕ ОПРЕДЕЛЕНИЯ КОРНЯ ПРОБЛЕМЫ:**

### 5.1 Решение для проблемы 1
**Спроектируй решение:**
- [ ] Описание решения с учетом найденного корня проблемы
- [ ] Список изменяемых компонентов и файлов
- [ ] Механизм персистентного хранения статуса обновления (если нужен)
- [ ] Логика проверки завершенных обновлений
- [ ] Изменения в подписках на события
- [ ] Миграция существующих состояний (если применимо)

### 5.2 Решение для проблемы 2
**Спроектируй решение:**
- [ ] Описание решения с учетом найденного корня проблемы
- [ ] Список изменяемых компонентов и файлов
- [ ] Механизм гарантированного закрытия потока
- [ ] Защита от race conditions
- [ ] Обработка ошибок и edge cases
- [ ] Принудительная очистка при необходимости

### 5.3 План реализации
**Создай детальный план:**
- [ ] Шаг 1: [описание изменений]
- [ ] Шаг 2: [описание изменений]
- [ ] Шаг 3: [описание изменений]
- [ ] Тестирование: [сценарии проверки]
- [ ] Риски и митигация: [потенциальные проблемы и способы их решения]

---

## ЭТАП 6: ВАЛИДАЦИЯ РЕШЕНИЯ

### 6.1 Проверка соответствия архитектуре
Убедись, что решение:
- [ ] Не нарушает порядок инициализации интеграций
- [ ] Соблюдает принципы EventBus (события, а не прямые вызовы)
- [ ] Не создает циклических зависимостей
- [ ] Соответствует существующим паттернам в коде
- [ ] Сохраняет обратную совместимость

### 6.2 Проверка рисков
Оцени:
- [ ] Риск регрессий в других компонентах
- [ ] Риск производительности или памяти
- [ ] Риск усложнения архитектуры
- [ ] Риск конфликтов с будущими изменениями

---

## ВЫХОДНЫЕ ТРЕБОВАНИЯ

### Требуемый результат анализа:
1. **ДИАГНОСТИЧЕСКИЙ ОТЧЕТ** с заполненными чек-листами этапов 1-3
2. **ФОРМУЛИРОВКА КОРНЯ ПРОБЛЕМЫ** для каждой проблемы (этап 4)
3. **ПРОЕКТ РЕШЕНИЯ** с детальным планом реализации (этап 5)
4. **ВАЛИДАЦИЯ** решения на соответствие архитектуре (этап 6)

### Формат отчета:
```markdown
# ДИАГНОСТИЧЕСКИЙ ОТЧЕТ: Проблемы обновления и микрофона

## ЭТАП 1: АНАЛИЗ АРХИТЕКТУРЫ
[результаты анализа]

## ЭТАП 2: АНАЛИЗ ЛОГОВ
[результаты анализа логов]

## ЭТАП 3: КОРЕНЬ ПРОБЛЕМЫ
### Проблема 1: [корень проблемы]
### Проблема 2: [корень проблемы]

## ЭТАП 5: РЕШЕНИЕ
[проект решения]

## ЭТАП 6: ВАЛИДАЦИЯ
[проверки и риски]
```

---

## ВАЖНЫЕ ЗАМЕЧАНИЯ

1. **Не пропускай этапы диагностики** - решения без анализа корня проблемы не принимаются
2. **Используй логи** - они содержат важную информацию о последовательности событий
3. **Учитывай архитектуру** - все решения должны соответствовать существующим принципам
4. **Проверяй зависимости** - изменение одного компонента может влиять на другие
5. **Документируй анализ** - каждый этап должен быть четко документирован

---

## РЕСУРСЫ ДЛЯ АНАЛИЗА

- Логи: `log.md`
- Архитектура: `Docs/ARCHITECTURE_OVERVIEW.md`
- Правила разработки: `.cursorrules`
- Ключевые файлы:
  - `integration/core/simple_module_coordinator.py`
  - `integration/integrations/update_notification_integration.py`
  - `integration/integrations/updater_integration.py`
  - `integration/integrations/voice_recognition_integration.py`
  - `modules/voice_recognition/core/speech_recognizer.py`
  - `integration/integrations/input_processing_integration.py`


