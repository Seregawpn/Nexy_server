# Nexy Server Development Rules

## 1. Базовый контекст
Перед изменениями обнови контекст по ключевым файлам:
- `Docs/PRODUCT_CONCEPT.md` — пользовательские сценарии и режимы
- `Docs/ARCHITECTURE_OVERVIEW.md` — связь модулей и интеграций
- `Docs/PACKAGING_FINAL_GUIDE.md` и `client/modules/*/MACOS_PACKAGING_GUIDE.md` — пайплайн сборки и подписи
- `Docs/CURRENT_STATUS_REPORT.md` — актуальные истории и фичи
- `Docs/GLOBAL_DELIVERY_PLAN.md` — требования к доставке и Azure VM
- `Docs/GO_TO_MARKET_BETA_PLAN_RU.md` — план выхода на рынок

## 2. Среда и запуск
- Python 3.11+, разворачивай в отдельном `venv`; зависимости — `server/requirements.txt`
- Точка входа: `python server/main.py` (aiohttp health-check 8080, gRPC 50051, update-сервер 8081 при доступности)
- Перед запуском загрузи переменные окружения из `server/config.env`
- Для регенерации gRPC артефактов используй:
  ```bash
  cd server/modules/grpc_service
  python -m grpc_tools.protoc \
      -I. \
      --python_out=. \
      --grpc_python_out=. \
      streaming.proto
  ```
- Health-check `/health` и `/status` должны оставаться доступными для Azure Container Apps

## 3. Архитектурный каркас
- `server/modules/` — чистые модули (text_processing, audio_generation, session_management, database, memory_management, interrupt_handling, text_filtering, update, grpc_service)
- `server/integrations/`
  - `core/` — универсальные интерфейсы (`UniversalModuleInterface`, `UniversalGrpcIntegration`, `UniversalProviderInterface`, `UniversalFallbackManager`)
  - `service_integrations/` — обвязка gRPC (`GrpcServiceIntegration`, `ModuleCoordinatorIntegration`)
  - `workflow_integrations/` — сценарные пайплайны (streaming, memory, interrupt и т.д.)
- gRPC менеджер собирает активные модули через Module Coordinator; прямых вызовов между модулями быть не должно
- Модули считаются стабильными; расширяем их конфигурацией, провайдерами или событиями. Новый модуль/интеграция допускается только когда нужного поведения нет и нельзя разумно добавить его в существующие блоки. В таком случае документируй мотивацию и зависимости в `Docs/ARCHITECTURE_OVERVIEW.md` и обновляй конфиг/тесты.

## 4. Паттерны модулей и интеграций
- Каждый модуль наследует `UniversalModuleInterface`: реализуй `initialize`, `process`, `cleanup`, обновляй `ModuleStatus`
- Интеграции наследуют `UniversalGrpcIntegration` или профильные базовые классы; вся координация идёт через них
- Влияние на выполнение пайплайнов фиксируй через workflow-интеграции, а не внутри модулей
- Fallback-логика и провайдеры подключаются через `UniversalFallbackManager`

## 5. gRPC контракт и взаимодействие с клиентом
- Любые правки `streaming.proto` → регенерация `streaming_pb2*.py`, обновление клиента, запись изменений в CHANGELOG/документацию
- Поддерживай обратную совместимость; если невозможна — объяви версию и уведомь клиентскую команду
- Тестируй новые методы и поля вместе с клиентом (минимум локальный smoke-тест)

## 6. Конфигурация и секреты
- Основные настройки: `server/config/unified_config_example.yaml` и `server/config/unified_config.py`
- Ожидаемые переменные берутся из `.env`/`config.env`; секреты (API-ключи, токены) храним вне репозитория
- Новые параметры документируй в `Docs/ARCHITECTURE_OVERVIEW.md` и добавляй в пример конфигурации
- Не создавай рассыпанные YAML/JSON; используй существующие загрузчики

## 7. Логирование и мониторинг
- Единый формат: `%(asctime)s - %(name)s - %(levelname)s - %(message)s`
- Обязательно логируй старт/остановку сервисов, сигналы обновлений, ошибки gRPC и статусы модулей
- Не допускается логирование PII и секретов
- При расширении логгирования используй стандартный `logging` и централизованные настройки из `main.py`
- Система мониторинга: используй `server/monitoring/` для отслеживания производительности и ошибок
- Масштабирование: сервер настроен на 100 пользователей с оптимизированными параметрами

## 8. Тестирование
- Для каждого модуля есть сценарий тестирования (например, `python modules/text_processing/test_text_processing.py`)
- Сохраняй последовательность тестов, указанную в гиде, чтобы не нарушить зависимости
- Для регрессии gRPC сервиса используй `modules/grpc_service/test_grpc_service.py`
- При добавлении модулей/интеграций обеспечь отдельный тестовый скрипт и обнови гайд

## 9. Чеклист изменений
**Перед началом**
- Проверь актуальность модульного плана и зависимостей между модулями
- Уточни, затрагивает ли задача gRPC контракт или конфиг, и подготовь план уведомления клиента
- Обнови `config.env`/секреты локально (не коммить)

**Во время**
- Соблюдай разделение: бизнес-логика в модулях, координация в интеграциях
- Не нарушай статусы модулей (инициализация → ready → processing → cleanup)
- При необходимости fallback/провайдера — используй `UniversalProviderInterface`
- Поддерживай чистое async-API, избегай блокирующих вызовов

**Перед мерджем — Impact-гейт**

- [ ] Приложен `change_impact.yaml` (оси условий, инварианты, guards, тест-стратегия, метрики, роллаут)
- [ ] Обновлены `Docs/STATE_CATALOG.md` и/или `client/config/interaction_matrix.yaml` (если задето)
- [ ] Есть минимум 8–14 pairwise тестов по выбранным осям + 2 негативных
- [ ] Логи решений видны локально: `decision=<...> ctx={...} source=<domain>`
- [ ] Фича-флаг + kill-switch прописаны (см. раздел «Роллаут»)

**После**
- Прогоняй релевантные модульные тесты + smoke gRPC (`modules/grpc_service/test_grpc_service.py`)
- Проверь, что health-checkи и статусы модулей возвращают ожидаемые данные
- Обнови документацию/планы, если тронул архитектуру, контракты или конфиг
- Синхронизируй изменения с клиентской командой, если есть новые поля/события

## 10. Наблюдаемые риски
- Несогласованные правки `streaming.proto`
- Отключение health-check (Azure Container Apps остановит сервис)
- Вмешательство в последовательность инициализации Module Coordinator
- Утечка секретов через коммиты или логи
- Отсутствие тестов/обновления гида после изменений

## 11. Напоминание
Все серверные изменения должны оставаться совместимыми с актуальной клиентской реализацией и не ломать уже завершённые модули. При сомнениях — синхронизируйся с владельцем клиентской части до мержа.


## 12. Каталог состояний и матрица взаимодействий

### 12.1 STATE_CATALOG (Docs/STATE_CATALOG.md)
- Оси/флаги: `permissions.mic|screen|accessibility`, `device.input`, `network`, `firstRun`, `appMode`, ...
- Для каждой оси: допустимые состояния, владелец, кто пишет/читает, источник истины, метрики.
- Ответственный: один владелец документа (по умолчанию: Tech Lead клиента).

### 12.2 INTERACTION_MATRIX (client/config/interaction_matrix.yaml)
- Фиксирует только взаимозависимые оси (без полного перебора).
- Формат правила:
  - `when: {Permission.mic: denied, appMode: listen} -> decision: abort_listen`
  - `priority: hard_stop | graceful | preference`
- Любое изменение >2 осей должно обновлять эту матрицу.

Пример `interaction_matrix.yaml`:

```yaml
axes:
  Permission.mic: [granted, denied, prompt_blocked]
  Device.input: [default_ok, busy]
  Network: [online, offline]
  FirstRun: [true, false]
rules:
  - when: {Permission.mic: denied}
    decision: abort_listen
    priority: hard_stop
  - when: {Permission.mic: granted, Device.input: busy, appMode: LISTENING}
    decision: retry_backoff
    priority: graceful
  - when: {Network: offline, appMode: PROCESSING}
    decision: degrade_offline
    priority: graceful
```


## 13. FSM + guard-условия на домены

- Для доменов `audio`, `permissions`, `mode_management` решения принимаются через FSM-таблицы: `(state, event) --[guard]--> (new_state, action)`.
- Guard-условия обязаны проверять критичные оси: permissions, device, network, firstRun.
- Запрещены скрытые записи состояний в чужие домены — только через EventBus.

Мини-образец решения из снапшота состояния:

```python
def decide_listen_action(s):
    if s.perm.mic != "granted":
        return Abort("mic_denied", ui="open_settings_mic")
    if s.device.input == "busy" and s.appMode == "LISTENING":
        return Retry("device_busy_backoff")
    if s.network == "offline":
        return Degrade("offline_mode")
    return Start()
```


## 14. Decision-логи (наблюдаемость решений)

Обязательны для FSM/интеграций:

`decision=<start|abort|retry|degrade> ctx={mic=...,screen=...,device=...,network=...,firstRun=...,appMode=...} source=<domain> duration_ms=<int>`

Метрики:
- `decision_rate{type}` — распределение решений
- `stream_open_success_rate` — доля удачных запусков аудио
- `tcc_prompt_duration_ms` — длительность последовательности разрешений (p95)


## 15. Политика роллаута изменяющих взаимодействия

- Любое изменение, затрагивающее >2 осей, включается через фича-флаг.
- Этапы: 1% → 25% → 100% (config-driven), с возможностью shadow-mode (считаем решение, но не применяем).
- Kill-switch: `NEXY_KS_<FEATURE>` в окружении/конфиге, выключает поведение немедленно без релиза.
- В `change_impact.yaml` обязательно указать: флаг, план раскатки, условие отката.


## 16. SLO и стоп-релизы (beta)

- `p95 start_listening ≤ 600ms`
- `stream_open_success_rate ≥ 98%`
- `permission_flow_success ≥ 99%` (микрофон+экран на first-run)
- Если SLO пробит на beta-канале — стоп всех функциональных релизов до восстановления.


## 17. Дополнительные улучшения

- ADR-минимум: один абзац «что/почему/альтернативы/дата» для любого изменения модуля или матрицы взаимодействий.
- Правила приоритетов условий (для 12.2):
  1. `hard_stop`: безопасность/разрешения/инварианты — всегда прерывают действие;
  2. `graceful`: деградация (сеть/квоты) — урезаем функционал, но живём;
  3. `preference`: UX-предпочтения — только если не конфликтуют с 1–2.
- Назначить владельца `STATE_CATALOG.md` и `interaction_matrix.yaml` (иначе зачерствеют).
- Контракт-тесты как decision-tables: входной снапшот → ожидаемое решение, без знания внутренностей модуля.
